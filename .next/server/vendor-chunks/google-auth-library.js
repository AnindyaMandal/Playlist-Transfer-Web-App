"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/google-auth-library";
exports.ids = ["vendor-chunks/google-auth-library"];
exports.modules = {

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/authclient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/authclient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2012 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AuthClient = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = exports.DEFAULT_UNIVERSE = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(action-browser)/./node_modules/google-auth-library/build/src/transporters.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"(action-browser)/./node_modules/google-auth-library/build/src/util.js\");\n/**\n * The default cloud universe\n *\n * @see {@link AuthJSONOptions.universe_domain}\n */ exports.DEFAULT_UNIVERSE = \"googleapis.com\";\n/**\n * The default {@link AuthClientOptions.eagerRefreshThresholdMillis}\n */ exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1000;\nclass AuthClient extends events_1.EventEmitter {\n    constructor(opts = {}){\n        var _a, _b, _c, _d, _e;\n        super();\n        this.credentials = {};\n        this.eagerRefreshThresholdMillis = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS;\n        this.forceRefreshOnFailure = false;\n        this.universeDomain = exports.DEFAULT_UNIVERSE;\n        const options = (0, util_1.originalOrCamelOptions)(opts);\n        // Shared auth options\n        this.projectId = (_a = options.get(\"project_id\")) !== null && _a !== void 0 ? _a : null;\n        this.quotaProjectId = options.get(\"quota_project_id\");\n        this.credentials = (_b = options.get(\"credentials\")) !== null && _b !== void 0 ? _b : {};\n        this.universeDomain = (_c = options.get(\"universe_domain\")) !== null && _c !== void 0 ? _c : exports.DEFAULT_UNIVERSE;\n        // Shared client options\n        this.transporter = (_d = opts.transporter) !== null && _d !== void 0 ? _d : new transporters_1.DefaultTransporter();\n        if (opts.transporterOptions) {\n            this.transporter.defaults = opts.transporterOptions;\n        }\n        if (opts.eagerRefreshThresholdMillis) {\n            this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = (_e = opts.forceRefreshOnFailure) !== null && _e !== void 0 ? _e : false;\n    }\n    /**\n     * Sets the auth credentials.\n     */ setCredentials(credentials) {\n        this.credentials = credentials;\n    }\n    /**\n     * Append additional headers, e.g., x-goog-user-project, shared across the\n     * classes inheriting AuthClient. This method should be used by any method\n     * that overrides getRequestMetadataAsync(), which is a shared helper for\n     * setting request information in both gRPC and HTTP API calls.\n     *\n     * @param headers object to append additional headers to.\n     */ addSharedMetadataHeaders(headers) {\n        // quota_project_id, stored in application_default_credentials.json, is set in\n        // the x-goog-user-project header, to indicate an alternate account for\n        // billing and quota:\n        if (!headers[\"x-goog-user-project\"] && // don't override a value the user sets.\n        this.quotaProjectId) {\n            headers[\"x-goog-user-project\"] = this.quotaProjectId;\n        }\n        return headers;\n    }\n}\nexports.AuthClient = AuthClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2F1dGhjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBR0EsOENBQThDLEdBQUdBLHdCQUF3QixHQUFHLEtBQUs7QUFDdEcsTUFBTUssV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsaUJBQWlCRCxtQkFBT0EsQ0FBQyxzR0FBaUI7QUFDaEQsTUFBTUUsU0FBU0YsbUJBQU9BLENBQUMsc0ZBQVM7QUFDaEM7Ozs7Q0FJQyxHQUNETix3QkFBd0IsR0FBRztBQUMzQjs7Q0FFQyxHQUNEQSw4Q0FBOEMsR0FBRyxJQUFJLEtBQUs7QUFDMUQsTUFBTUUsbUJBQW1CRyxTQUFTSSxZQUFZO0lBQzFDQyxZQUFZQyxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQ25CLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDO1FBQ3BCLEtBQUs7UUFDTCxJQUFJLENBQUNDLFdBQVcsR0FBRyxDQUFDO1FBQ3BCLElBQUksQ0FBQ0MsMkJBQTJCLEdBQUdsQixRQUFRRyxzQ0FBc0M7UUFDakYsSUFBSSxDQUFDZ0IscUJBQXFCLEdBQUc7UUFDN0IsSUFBSSxDQUFDQyxjQUFjLEdBQUdwQixRQUFRSSxnQkFBZ0I7UUFDOUMsTUFBTWlCLFVBQVUsQ0FBQyxHQUFHYixPQUFPYyxzQkFBc0IsRUFBRVg7UUFDbkQsc0JBQXNCO1FBQ3RCLElBQUksQ0FBQ1ksU0FBUyxHQUFHLENBQUNYLEtBQUtTLFFBQVFHLEdBQUcsQ0FBQyxhQUFZLE1BQU8sUUFBUVosT0FBTyxLQUFLLElBQUlBLEtBQUs7UUFDbkYsSUFBSSxDQUFDYSxjQUFjLEdBQUdKLFFBQVFHLEdBQUcsQ0FBQztRQUNsQyxJQUFJLENBQUNQLFdBQVcsR0FBRyxDQUFDSixLQUFLUSxRQUFRRyxHQUFHLENBQUMsY0FBYSxNQUFPLFFBQVFYLE9BQU8sS0FBSyxJQUFJQSxLQUFLLENBQUM7UUFDdkYsSUFBSSxDQUFDTyxjQUFjLEdBQUcsQ0FBQ04sS0FBS08sUUFBUUcsR0FBRyxDQUFDLGtCQUFpQixNQUFPLFFBQVFWLE9BQU8sS0FBSyxJQUFJQSxLQUFLZCxRQUFRSSxnQkFBZ0I7UUFDckgsd0JBQXdCO1FBQ3hCLElBQUksQ0FBQ3NCLFdBQVcsR0FBRyxDQUFDWCxLQUFLSixLQUFLZSxXQUFXLE1BQU0sUUFBUVgsT0FBTyxLQUFLLElBQUlBLEtBQUssSUFBSVIsZUFBZW9CLGtCQUFrQjtRQUNqSCxJQUFJaEIsS0FBS2lCLGtCQUFrQixFQUFFO1lBQ3pCLElBQUksQ0FBQ0YsV0FBVyxDQUFDRyxRQUFRLEdBQUdsQixLQUFLaUIsa0JBQWtCO1FBQ3ZEO1FBQ0EsSUFBSWpCLEtBQUtPLDJCQUEyQixFQUFFO1lBQ2xDLElBQUksQ0FBQ0EsMkJBQTJCLEdBQUdQLEtBQUtPLDJCQUEyQjtRQUN2RTtRQUNBLElBQUksQ0FBQ0MscUJBQXFCLEdBQUcsQ0FBQ0gsS0FBS0wsS0FBS1EscUJBQXFCLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUlBLEtBQUs7SUFDcEc7SUFDQTs7S0FFQyxHQUNEYyxlQUFlYixXQUFXLEVBQUU7UUFDeEIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ3ZCO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNEYyx5QkFBeUJDLE9BQU8sRUFBRTtRQUM5Qiw4RUFBOEU7UUFDOUUsdUVBQXVFO1FBQ3ZFLHFCQUFxQjtRQUNyQixJQUFJLENBQUNBLE9BQU8sQ0FBQyxzQkFBc0IsSUFBSSx3Q0FBd0M7UUFDM0UsSUFBSSxDQUFDUCxjQUFjLEVBQUU7WUFDckJPLE9BQU8sQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUNQLGNBQWM7UUFDeEQ7UUFDQSxPQUFPTztJQUNYO0FBQ0o7QUFDQWhDLGtCQUFrQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb3RpZnktdG8teW91dHViZS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2F1dGhjbGllbnQuanM/M2NlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDEyIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdXRoQ2xpZW50ID0gZXhwb3J0cy5ERUZBVUxUX0VBR0VSX1JFRlJFU0hfVEhSRVNIT0xEX01JTExJUyA9IGV4cG9ydHMuREVGQVVMVF9VTklWRVJTRSA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHRyYW5zcG9ydGVyc18xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydGVyc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBjbG91ZCB1bml2ZXJzZVxuICpcbiAqIEBzZWUge0BsaW5rIEF1dGhKU09OT3B0aW9ucy51bml2ZXJzZV9kb21haW59XG4gKi9cbmV4cG9ydHMuREVGQVVMVF9VTklWRVJTRSA9ICdnb29nbGVhcGlzLmNvbSc7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHtAbGluayBBdXRoQ2xpZW50T3B0aW9ucy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXN9XG4gKi9cbmV4cG9ydHMuREVGQVVMVF9FQUdFUl9SRUZSRVNIX1RIUkVTSE9MRF9NSUxMSVMgPSA1ICogNjAgKiAxMDAwO1xuY2xhc3MgQXV0aENsaWVudCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB7fTtcbiAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSBleHBvcnRzLkRFRkFVTFRfRUFHRVJfUkVGUkVTSF9USFJFU0hPTERfTUlMTElTO1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVuaXZlcnNlRG9tYWluID0gZXhwb3J0cy5ERUZBVUxUX1VOSVZFUlNFO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gKDAsIHV0aWxfMS5vcmlnaW5hbE9yQ2FtZWxPcHRpb25zKShvcHRzKTtcbiAgICAgICAgLy8gU2hhcmVkIGF1dGggb3B0aW9uc1xuICAgICAgICB0aGlzLnByb2plY3RJZCA9IChfYSA9IG9wdGlvbnMuZ2V0KCdwcm9qZWN0X2lkJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgIHRoaXMucXVvdGFQcm9qZWN0SWQgPSBvcHRpb25zLmdldCgncXVvdGFfcHJvamVjdF9pZCcpO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gKF9iID0gb3B0aW9ucy5nZXQoJ2NyZWRlbnRpYWxzJykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICAgICAgICB0aGlzLnVuaXZlcnNlRG9tYWluID0gKF9jID0gb3B0aW9ucy5nZXQoJ3VuaXZlcnNlX2RvbWFpbicpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBleHBvcnRzLkRFRkFVTFRfVU5JVkVSU0U7XG4gICAgICAgIC8vIFNoYXJlZCBjbGllbnQgb3B0aW9uc1xuICAgICAgICB0aGlzLnRyYW5zcG9ydGVyID0gKF9kID0gb3B0cy50cmFuc3BvcnRlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbmV3IHRyYW5zcG9ydGVyc18xLkRlZmF1bHRUcmFuc3BvcnRlcigpO1xuICAgICAgICBpZiAob3B0cy50cmFuc3BvcnRlck9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ZXIuZGVmYXVsdHMgPSBvcHRzLnRyYW5zcG9ydGVyT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMpIHtcbiAgICAgICAgICAgIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gb3B0cy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUgPSAoX2UgPSBvcHRzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGF1dGggY3JlZGVudGlhbHMuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYWRkaXRpb25hbCBoZWFkZXJzLCBlLmcuLCB4LWdvb2ctdXNlci1wcm9qZWN0LCBzaGFyZWQgYWNyb3NzIHRoZVxuICAgICAqIGNsYXNzZXMgaW5oZXJpdGluZyBBdXRoQ2xpZW50LiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCBieSBhbnkgbWV0aG9kXG4gICAgICogdGhhdCBvdmVycmlkZXMgZ2V0UmVxdWVzdE1ldGFkYXRhQXN5bmMoKSwgd2hpY2ggaXMgYSBzaGFyZWQgaGVscGVyIGZvclxuICAgICAqIHNldHRpbmcgcmVxdWVzdCBpbmZvcm1hdGlvbiBpbiBib3RoIGdSUEMgYW5kIEhUVFAgQVBJIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhlYWRlcnMgb2JqZWN0IHRvIGFwcGVuZCBhZGRpdGlvbmFsIGhlYWRlcnMgdG8uXG4gICAgICovXG4gICAgYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgLy8gcXVvdGFfcHJvamVjdF9pZCwgc3RvcmVkIGluIGFwcGxpY2F0aW9uX2RlZmF1bHRfY3JlZGVudGlhbHMuanNvbiwgaXMgc2V0IGluXG4gICAgICAgIC8vIHRoZSB4LWdvb2ctdXNlci1wcm9qZWN0IGhlYWRlciwgdG8gaW5kaWNhdGUgYW4gYWx0ZXJuYXRlIGFjY291bnQgZm9yXG4gICAgICAgIC8vIGJpbGxpbmcgYW5kIHF1b3RhOlxuICAgICAgICBpZiAoIWhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSAmJiAvLyBkb24ndCBvdmVycmlkZSBhIHZhbHVlIHRoZSB1c2VyIHNldHMuXG4gICAgICAgICAgICB0aGlzLnF1b3RhUHJvamVjdElkKSB7XG4gICAgICAgICAgICBoZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10gPSB0aGlzLnF1b3RhUHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbn1cbmV4cG9ydHMuQXV0aENsaWVudCA9IEF1dGhDbGllbnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBdXRoQ2xpZW50IiwiREVGQVVMVF9FQUdFUl9SRUZSRVNIX1RIUkVTSE9MRF9NSUxMSVMiLCJERUZBVUxUX1VOSVZFUlNFIiwiZXZlbnRzXzEiLCJyZXF1aXJlIiwidHJhbnNwb3J0ZXJzXzEiLCJ1dGlsXzEiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiY3JlZGVudGlhbHMiLCJlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMiLCJmb3JjZVJlZnJlc2hPbkZhaWx1cmUiLCJ1bml2ZXJzZURvbWFpbiIsIm9wdGlvbnMiLCJvcmlnaW5hbE9yQ2FtZWxPcHRpb25zIiwicHJvamVjdElkIiwiZ2V0IiwicXVvdGFQcm9qZWN0SWQiLCJ0cmFuc3BvcnRlciIsIkRlZmF1bHRUcmFuc3BvcnRlciIsInRyYW5zcG9ydGVyT3B0aW9ucyIsImRlZmF1bHRzIiwic2V0Q3JlZGVudGlhbHMiLCJhZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMiLCJoZWFkZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/authclient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/awsclient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/awsclient.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AwsClient = void 0;\nconst awsrequestsigner_1 = __webpack_require__(/*! ./awsrequestsigner */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n/**\n * AWS external account client. This is used for AWS workloads, where\n * AWS STS GetCallerIdentity serialized signed requests are exchanged for\n * GCP access token.\n */ class AwsClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiates an AwsClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid AWS credential.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        super(options, additionalOptions);\n        this.environmentId = options.credential_source.environment_id;\n        // This is only required if the AWS region is not available in the\n        // AWS_REGION or AWS_DEFAULT_REGION environment variables.\n        this.regionUrl = options.credential_source.region_url;\n        // This is only required if AWS security credentials are not available in\n        // environment variables.\n        this.securityCredentialsUrl = options.credential_source.url;\n        this.regionalCredVerificationUrl = options.credential_source.regional_cred_verification_url;\n        this.imdsV2SessionTokenUrl = options.credential_source.imdsv2_session_token_url;\n        this.awsRequestSigner = null;\n        this.region = \"\";\n        this.credentialSourceType = \"aws\";\n        // Data validators.\n        this.validateEnvironmentId();\n    }\n    validateEnvironmentId() {\n        var _a;\n        const match = (_a = this.environmentId) === null || _a === void 0 ? void 0 : _a.match(/^(aws)(\\d+)$/);\n        if (!match || !this.regionalCredVerificationUrl) {\n            throw new Error('No valid AWS \"credential_source\" provided');\n        } else if (parseInt(match[2], 10) !== 1) {\n            throw new Error(`aws version \"${match[2]}\" is not supported in the current build.`);\n        }\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this uses a serialized AWS signed request to the STS GetCallerIdentity\n     * endpoint.\n     * The logic is summarized as:\n     * 1. If imdsv2_session_token_url is provided in the credential source, then\n     *    fetch the aws session token and include it in the headers of the\n     *    metadata requests. This is a requirement for IDMSv2 but optional\n     *    for IDMSv1.\n     * 2. Retrieve AWS region from availability-zone.\n     * 3a. Check AWS credentials in environment variables. If not found, get\n     *     from security-credentials endpoint.\n     * 3b. Get AWS credentials from security-credentials endpoint. In order\n     *     to retrieve this, the AWS role needs to be determined by calling\n     *     security-credentials endpoint without any argument. Then the\n     *     credentials can be retrieved via: security-credentials/role_name\n     * 4. Generate the signed request to AWS STS GetCallerIdentity action.\n     * 5. Inject x-goog-cloud-target-resource into header and serialize the\n     *    signed request. This will be the subject-token to pass to GCP STS.\n     * @return A promise that resolves with the external subject token.\n     */ async retrieveSubjectToken() {\n        // Initialize AWS request signer if not already initialized.\n        if (!this.awsRequestSigner) {\n            const metadataHeaders = {};\n            // Only retrieve the IMDSv2 session token if both the security credentials and region are\n            // not retrievable through the environment.\n            // The credential config contains all the URLs by default but clients may be running this\n            // where the metadata server is not available and returning the credentials through the environment.\n            // Removing this check may break them.\n            if (this.shouldUseMetadataServer() && this.imdsV2SessionTokenUrl) {\n                metadataHeaders[\"x-aws-ec2-metadata-token\"] = await this.getImdsV2SessionToken();\n            }\n            this.region = await this.getAwsRegion(metadataHeaders);\n            this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async ()=>{\n                // Check environment variables for permanent credentials first.\n                // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n                if (this.securityCredentialsFromEnv) {\n                    return this.securityCredentialsFromEnv;\n                }\n                // Since the role on a VM can change, we don't need to cache it.\n                const roleName = await this.getAwsRoleName(metadataHeaders);\n                // Temporary credentials typically last for several hours.\n                // Expiration is returned in response.\n                // Consider future optimization of this logic to cache AWS tokens\n                // until their natural expiration.\n                const awsCreds = await this.getAwsSecurityCredentials(roleName, metadataHeaders);\n                return {\n                    accessKeyId: awsCreds.AccessKeyId,\n                    secretAccessKey: awsCreds.SecretAccessKey,\n                    token: awsCreds.Token\n                };\n            }, this.region);\n        }\n        // Generate signed request to AWS STS GetCallerIdentity API.\n        // Use the required regional endpoint. Otherwise, the request will fail.\n        const options = await this.awsRequestSigner.getRequestOptions({\n            url: this.regionalCredVerificationUrl.replace(\"{region}\", this.region),\n            method: \"POST\"\n        });\n        // The GCP STS endpoint expects the headers to be formatted as:\n        // [\n        //   {key: 'x-amz-date', value: '...'},\n        //   {key: 'Authorization', value: '...'},\n        //   ...\n        // ]\n        // And then serialized as:\n        // encodeURIComponent(JSON.stringify({\n        //   url: '...',\n        //   method: 'POST',\n        //   headers: [{key: 'x-amz-date', value: '...'}, ...]\n        // }))\n        const reformattedHeader = [];\n        const extendedHeaders = Object.assign({\n            // The full, canonical resource name of the workload identity pool\n            // provider, with or without the HTTPS prefix.\n            // Including this header as part of the signature is recommended to\n            // ensure data integrity.\n            \"x-goog-cloud-target-resource\": this.audience\n        }, options.headers);\n        // Reformat header to GCP STS expected format.\n        for(const key in extendedHeaders){\n            reformattedHeader.push({\n                key,\n                value: extendedHeaders[key]\n            });\n        }\n        // Serialize the reformatted signed request.\n        return encodeURIComponent(JSON.stringify({\n            url: options.url,\n            method: options.method,\n            headers: reformattedHeader\n        }));\n    }\n    /**\n     * @return A promise that resolves with the IMDSv2 Session Token.\n     */ async getImdsV2SessionToken() {\n        const opts = {\n            url: this.imdsV2SessionTokenUrl,\n            method: \"PUT\",\n            responseType: \"text\",\n            headers: {\n                \"x-aws-ec2-metadata-token-ttl-seconds\": \"300\"\n            }\n        };\n        const response = await this.transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the current AWS region.\n     */ async getAwsRegion(headers) {\n        // Priority order for region determination:\n        // AWS_REGION > AWS_DEFAULT_REGION > metadata server.\n        if (this.regionFromEnv) {\n            return this.regionFromEnv;\n        }\n        if (!this.regionUrl) {\n            throw new Error(\"Unable to determine AWS region due to missing \" + '\"options.credential_source.region_url\"');\n        }\n        const opts = {\n            url: this.regionUrl,\n            method: \"GET\",\n            responseType: \"text\",\n            headers: headers\n        };\n        const response = await this.transporter.request(opts);\n        // Remove last character. For example, if us-east-2b is returned,\n        // the region would be us-east-2.\n        return response.data.substr(0, response.data.length - 1);\n    }\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the assigned role to the current\n     *   AWS VM. This is needed for calling the security-credentials endpoint.\n     */ async getAwsRoleName(headers) {\n        if (!this.securityCredentialsUrl) {\n            throw new Error(\"Unable to determine AWS role name due to missing \" + '\"options.credential_source.url\"');\n        }\n        const opts = {\n            url: this.securityCredentialsUrl,\n            method: \"GET\",\n            responseType: \"text\",\n            headers: headers\n        };\n        const response = await this.transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * Retrieves the temporary AWS credentials by calling the security-credentials\n     * endpoint as specified in the `credential_source` object.\n     * @param roleName The role attached to the current VM.\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the temporary AWS credentials\n     *   needed for creating the GetCallerIdentity signed request.\n     */ async getAwsSecurityCredentials(roleName, headers) {\n        const response = await this.transporter.request({\n            url: `${this.securityCredentialsUrl}/${roleName}`,\n            responseType: \"json\",\n            headers: headers\n        });\n        return response.data;\n    }\n    shouldUseMetadataServer() {\n        // The metadata server must be used when either the AWS region or AWS security\n        // credentials cannot be retrieved through their defined environment variables.\n        return !this.regionFromEnv || !this.securityCredentialsFromEnv;\n    }\n    get regionFromEnv() {\n        // The AWS region can be provided through AWS_REGION or AWS_DEFAULT_REGION.\n        // Only one is required.\n        return process.env[\"AWS_REGION\"] || process.env[\"AWS_DEFAULT_REGION\"] || null;\n    }\n    get securityCredentialsFromEnv() {\n        // Both AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required.\n        if (process.env[\"AWS_ACCESS_KEY_ID\"] && process.env[\"AWS_SECRET_ACCESS_KEY\"]) {\n            return {\n                accessKeyId: process.env[\"AWS_ACCESS_KEY_ID\"],\n                secretAccessKey: process.env[\"AWS_SECRET_ACCESS_KEY\"],\n                token: process.env[\"AWS_SESSION_TOKEN\"]\n            };\n        }\n        return null;\n    }\n}\nexports.AwsClient = AwsClient;\nAwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = \"169.254.169.254\";\nAwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = \"fd00:ec2::254\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2F3c2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsTUFBTUcscUJBQXFCQyxtQkFBT0EsQ0FBQyxrSEFBb0I7QUFDdkQsTUFBTUMsdUJBQXVCRCxtQkFBT0EsQ0FBQyxzSEFBc0I7QUFDM0Q7Ozs7Q0FJQyxHQUNELE1BQU1GLGtCQUFrQkcscUJBQXFCQyx5QkFBeUI7SUFDbEU7Ozs7Ozs7Ozs7S0FVQyxHQUNEQyxZQUFZQyxPQUFPLEVBQUVDLGlCQUFpQixDQUFFO1FBQ3BDLEtBQUssQ0FBQ0QsU0FBU0M7UUFDZixJQUFJLENBQUNDLGFBQWEsR0FBR0YsUUFBUUcsaUJBQWlCLENBQUNDLGNBQWM7UUFDN0Qsa0VBQWtFO1FBQ2xFLDBEQUEwRDtRQUMxRCxJQUFJLENBQUNDLFNBQVMsR0FBR0wsUUFBUUcsaUJBQWlCLENBQUNHLFVBQVU7UUFDckQseUVBQXlFO1FBQ3pFLHlCQUF5QjtRQUN6QixJQUFJLENBQUNDLHNCQUFzQixHQUFHUCxRQUFRRyxpQkFBaUIsQ0FBQ0ssR0FBRztRQUMzRCxJQUFJLENBQUNDLDJCQUEyQixHQUM1QlQsUUFBUUcsaUJBQWlCLENBQUNPLDhCQUE4QjtRQUM1RCxJQUFJLENBQUNDLHFCQUFxQixHQUN0QlgsUUFBUUcsaUJBQWlCLENBQUNTLHdCQUF3QjtRQUN0RCxJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FB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QyxvQkFBb0I7WUFDM0M7UUFDSjtRQUNBLE9BQU87SUFDWDtBQUNKO0FBQ0FyRSxpQkFBaUIsR0FBR0U7QUFDcEJBLFVBQVVvRSw2QkFBNkIsR0FBRztBQUMxQ3BFLFVBQVVxRSw2QkFBNkIsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb3RpZnktdG8teW91dHViZS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2F3c2NsaWVudC5qcz80OGIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF3c0NsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGF3c3JlcXVlc3RzaWduZXJfMSA9IHJlcXVpcmUoXCIuL2F3c3JlcXVlc3RzaWduZXJcIik7XG5jb25zdCBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2Jhc2VleHRlcm5hbGNsaWVudFwiKTtcbi8qKlxuICogQVdTIGV4dGVybmFsIGFjY291bnQgY2xpZW50LiBUaGlzIGlzIHVzZWQgZm9yIEFXUyB3b3JrbG9hZHMsIHdoZXJlXG4gKiBBV1MgU1RTIEdldENhbGxlcklkZW50aXR5IHNlcmlhbGl6ZWQgc2lnbmVkIHJlcXVlc3RzIGFyZSBleGNoYW5nZWQgZm9yXG4gKiBHQ1AgYWNjZXNzIHRva2VuLlxuICovXG5jbGFzcyBBd3NDbGllbnQgZXh0ZW5kcyBiYXNlZXh0ZXJuYWxjbGllbnRfMS5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gQXdzQ2xpZW50IGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OXG4gICAgICogb2JqZWN0IGxvYWRlZCBmcm9tIGFuIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbHMgZmlsZS5cbiAgICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGNyZWRlbnRpYWwgaXMgbm90IGEgdmFsaWQgQVdTIGNyZWRlbnRpYWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGV4dGVybmFsIGFjY291bnQgb3B0aW9ucyBvYmplY3QgdHlwaWNhbGx5IGxvYWRlZFxuICAgICAqICAgZnJvbSB0aGUgZXh0ZXJuYWwgYWNjb3VudCBKU09OIGNyZWRlbnRpYWwgZmlsZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnMgKipERVBSRUNBVEVELCBhbGwgb3B0aW9ucyBhcmUgYXZhaWxhYmxlIGluIHRoZVxuICAgICAqICAgYG9wdGlvbnNgIHBhcmFtZXRlci4qKiBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb24gb3B0aW9ucy5cbiAgICAgKiAgIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmQgd2hldGhlciB0byByZXRyeVxuICAgICAqICAgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVudmlyb25tZW50SWQgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmVudmlyb25tZW50X2lkO1xuICAgICAgICAvLyBUaGlzIGlzIG9ubHkgcmVxdWlyZWQgaWYgdGhlIEFXUyByZWdpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGVcbiAgICAgICAgLy8gQVdTX1JFR0lPTiBvciBBV1NfREVGQVVMVF9SRUdJT04gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAgICB0aGlzLnJlZ2lvblVybCA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UucmVnaW9uX3VybDtcbiAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHJlcXVpcmVkIGlmIEFXUyBzZWN1cml0eSBjcmVkZW50aWFscyBhcmUgbm90IGF2YWlsYWJsZSBpblxuICAgICAgICAvLyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICAgIHRoaXMuc2VjdXJpdHlDcmVkZW50aWFsc1VybCA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UudXJsO1xuICAgICAgICB0aGlzLnJlZ2lvbmFsQ3JlZFZlcmlmaWNhdGlvblVybCA9XG4gICAgICAgICAgICBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLnJlZ2lvbmFsX2NyZWRfdmVyaWZpY2F0aW9uX3VybDtcbiAgICAgICAgdGhpcy5pbWRzVjJTZXNzaW9uVG9rZW5VcmwgPVxuICAgICAgICAgICAgb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5pbWRzdjJfc2Vzc2lvbl90b2tlbl91cmw7XG4gICAgICAgIHRoaXMuYXdzUmVxdWVzdFNpZ25lciA9IG51bGw7XG4gICAgICAgIHRoaXMucmVnaW9uID0gJyc7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbFNvdXJjZVR5cGUgPSAnYXdzJztcbiAgICAgICAgLy8gRGF0YSB2YWxpZGF0b3JzLlxuICAgICAgICB0aGlzLnZhbGlkYXRlRW52aXJvbm1lbnRJZCgpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUVudmlyb25tZW50SWQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAoX2EgPSB0aGlzLmVudmlyb25tZW50SWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXRjaCgvXihhd3MpKFxcZCspJC8pO1xuICAgICAgICBpZiAoIW1hdGNoIHx8ICF0aGlzLnJlZ2lvbmFsQ3JlZFZlcmlmaWNhdGlvblVybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBBV1MgXCJjcmVkZW50aWFsX3NvdXJjZVwiIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VJbnQobWF0Y2hbMl0sIDEwKSAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhd3MgdmVyc2lvbiBcIiR7bWF0Y2hbMl19XCIgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBidWlsZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhbiBleHRlcm5hbCBzdWJqZWN0IHRva2VuIGlzIG5lZWRlZCB0byBiZSBleGNoYW5nZWQgZm9yIGFcbiAgICAgKiBHQ1AgYWNjZXNzIHRva2VuIHZpYSBHQ1AgU1RTIGVuZHBvaW50LlxuICAgICAqIFRoaXMgdXNlcyB0aGUgYG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2VgIG9iamVjdCB0byBmaWd1cmUgb3V0IGhvd1xuICAgICAqIHRvIHJldHJpZXZlIHRoZSB0b2tlbiB1c2luZyB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gSW4gdGhpcyBjYXNlLFxuICAgICAqIHRoaXMgdXNlcyBhIHNlcmlhbGl6ZWQgQVdTIHNpZ25lZCByZXF1ZXN0IHRvIHRoZSBTVFMgR2V0Q2FsbGVySWRlbnRpdHlcbiAgICAgKiBlbmRwb2ludC5cbiAgICAgKiBUaGUgbG9naWMgaXMgc3VtbWFyaXplZCBhczpcbiAgICAgKiAxLiBJZiBpbWRzdjJfc2Vzc2lvbl90b2tlbl91cmwgaXMgcHJvdmlkZWQgaW4gdGhlIGNyZWRlbnRpYWwgc291cmNlLCB0aGVuXG4gICAgICogICAgZmV0Y2ggdGhlIGF3cyBzZXNzaW9uIHRva2VuIGFuZCBpbmNsdWRlIGl0IGluIHRoZSBoZWFkZXJzIG9mIHRoZVxuICAgICAqICAgIG1ldGFkYXRhIHJlcXVlc3RzLiBUaGlzIGlzIGEgcmVxdWlyZW1lbnQgZm9yIElETVN2MiBidXQgb3B0aW9uYWxcbiAgICAgKiAgICBmb3IgSURNU3YxLlxuICAgICAqIDIuIFJldHJpZXZlIEFXUyByZWdpb24gZnJvbSBhdmFpbGFiaWxpdHktem9uZS5cbiAgICAgKiAzYS4gQ2hlY2sgQVdTIGNyZWRlbnRpYWxzIGluIGVudmlyb25tZW50IHZhcmlhYmxlcy4gSWYgbm90IGZvdW5kLCBnZXRcbiAgICAgKiAgICAgZnJvbSBzZWN1cml0eS1jcmVkZW50aWFscyBlbmRwb2ludC5cbiAgICAgKiAzYi4gR2V0IEFXUyBjcmVkZW50aWFscyBmcm9tIHNlY3VyaXR5LWNyZWRlbnRpYWxzIGVuZHBvaW50LiBJbiBvcmRlclxuICAgICAqICAgICB0byByZXRyaWV2ZSB0aGlzLCB0aGUgQVdTIHJvbGUgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZCBieSBjYWxsaW5nXG4gICAgICogICAgIHNlY3VyaXR5LWNyZWRlbnRpYWxzIGVuZHBvaW50IHdpdGhvdXQgYW55IGFyZ3VtZW50LiBUaGVuIHRoZVxuICAgICAqICAgICBjcmVkZW50aWFscyBjYW4gYmUgcmV0cmlldmVkIHZpYTogc2VjdXJpdHktY3JlZGVudGlhbHMvcm9sZV9uYW1lXG4gICAgICogNC4gR2VuZXJhdGUgdGhlIHNpZ25lZCByZXF1ZXN0IHRvIEFXUyBTVFMgR2V0Q2FsbGVySWRlbnRpdHkgYWN0aW9uLlxuICAgICAqIDUuIEluamVjdCB4LWdvb2ctY2xvdWQtdGFyZ2V0LXJlc291cmNlIGludG8gaGVhZGVyIGFuZCBzZXJpYWxpemUgdGhlXG4gICAgICogICAgc2lnbmVkIHJlcXVlc3QuIFRoaXMgd2lsbCBiZSB0aGUgc3ViamVjdC10b2tlbiB0byBwYXNzIHRvIEdDUCBTVFMuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBleHRlcm5hbCBzdWJqZWN0IHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIHJldHJpZXZlU3ViamVjdFRva2VuKCkge1xuICAgICAgICAvLyBJbml0aWFsaXplIEFXUyByZXF1ZXN0IHNpZ25lciBpZiBub3QgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgICAgICAgaWYgKCF0aGlzLmF3c1JlcXVlc3RTaWduZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhSGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgLy8gT25seSByZXRyaWV2ZSB0aGUgSU1EU3YyIHNlc3Npb24gdG9rZW4gaWYgYm90aCB0aGUgc2VjdXJpdHkgY3JlZGVudGlhbHMgYW5kIHJlZ2lvbiBhcmVcbiAgICAgICAgICAgIC8vIG5vdCByZXRyaWV2YWJsZSB0aHJvdWdoIHRoZSBlbnZpcm9ubWVudC5cbiAgICAgICAgICAgIC8vIFRoZSBjcmVkZW50aWFsIGNvbmZpZyBjb250YWlucyBhbGwgdGhlIFVSTHMgYnkgZGVmYXVsdCBidXQgY2xpZW50cyBtYXkgYmUgcnVubmluZyB0aGlzXG4gICAgICAgICAgICAvLyB3aGVyZSB0aGUgbWV0YWRhdGEgc2VydmVyIGlzIG5vdCBhdmFpbGFibGUgYW5kIHJldHVybmluZyB0aGUgY3JlZGVudGlhbHMgdGhyb3VnaCB0aGUgZW52aXJvbm1lbnQuXG4gICAgICAgICAgICAvLyBSZW1vdmluZyB0aGlzIGNoZWNrIG1heSBicmVhayB0aGVtLlxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVXNlTWV0YWRhdGFTZXJ2ZXIoKSAmJiB0aGlzLmltZHNWMlNlc3Npb25Ub2tlblVybCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhSGVhZGVyc1sneC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuJ10gPVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldEltZHNWMlNlc3Npb25Ub2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWdpb24gPSBhd2FpdCB0aGlzLmdldEF3c1JlZ2lvbihtZXRhZGF0YUhlYWRlcnMpO1xuICAgICAgICAgICAgdGhpcy5hd3NSZXF1ZXN0U2lnbmVyID0gbmV3IGF3c3JlcXVlc3RzaWduZXJfMS5Bd3NSZXF1ZXN0U2lnbmVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIHBlcm1hbmVudCBjcmVkZW50aWFscyBmaXJzdC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2VuZXJhbC9sYXRlc3QvZ3IvYXdzLXNlYy1jcmVkLXR5cGVzLmh0bWxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzRnJvbUVudikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzRnJvbUVudjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIHJvbGUgb24gYSBWTSBjYW4gY2hhbmdlLCB3ZSBkb24ndCBuZWVkIHRvIGNhY2hlIGl0LlxuICAgICAgICAgICAgICAgIGNvbnN0IHJvbGVOYW1lID0gYXdhaXQgdGhpcy5nZXRBd3NSb2xlTmFtZShtZXRhZGF0YUhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIC8vIFRlbXBvcmFyeSBjcmVkZW50aWFscyB0eXBpY2FsbHkgbGFzdCBmb3Igc2V2ZXJhbCBob3Vycy5cbiAgICAgICAgICAgICAgICAvLyBFeHBpcmF0aW9uIGlzIHJldHVybmVkIGluIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGZ1dHVyZSBvcHRpbWl6YXRpb24gb2YgdGhpcyBsb2dpYyB0byBjYWNoZSBBV1MgdG9rZW5zXG4gICAgICAgICAgICAgICAgLy8gdW50aWwgdGhlaXIgbmF0dXJhbCBleHBpcmF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGF3c0NyZWRzID0gYXdhaXQgdGhpcy5nZXRBd3NTZWN1cml0eUNyZWRlbnRpYWxzKHJvbGVOYW1lLCBtZXRhZGF0YUhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc0tleUlkOiBhd3NDcmVkcy5BY2Nlc3NLZXlJZCxcbiAgICAgICAgICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiBhd3NDcmVkcy5TZWNyZXRBY2Nlc3NLZXksXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBhd3NDcmVkcy5Ub2tlbixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgdGhpcy5yZWdpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdlbmVyYXRlIHNpZ25lZCByZXF1ZXN0IHRvIEFXUyBTVFMgR2V0Q2FsbGVySWRlbnRpdHkgQVBJLlxuICAgICAgICAvLyBVc2UgdGhlIHJlcXVpcmVkIHJlZ2lvbmFsIGVuZHBvaW50LiBPdGhlcndpc2UsIHRoZSByZXF1ZXN0IHdpbGwgZmFpbC5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IHRoaXMuYXdzUmVxdWVzdFNpZ25lci5nZXRSZXF1ZXN0T3B0aW9ucyh7XG4gICAgICAgICAgICB1cmw6IHRoaXMucmVnaW9uYWxDcmVkVmVyaWZpY2F0aW9uVXJsLnJlcGxhY2UoJ3tyZWdpb259JywgdGhpcy5yZWdpb24pLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgR0NQIFNUUyBlbmRwb2ludCBleHBlY3RzIHRoZSBoZWFkZXJzIHRvIGJlIGZvcm1hdHRlZCBhczpcbiAgICAgICAgLy8gW1xuICAgICAgICAvLyAgIHtrZXk6ICd4LWFtei1kYXRlJywgdmFsdWU6ICcuLi4nfSxcbiAgICAgICAgLy8gICB7a2V5OiAnQXV0aG9yaXphdGlvbicsIHZhbHVlOiAnLi4uJ30sXG4gICAgICAgIC8vICAgLi4uXG4gICAgICAgIC8vIF1cbiAgICAgICAgLy8gQW5kIHRoZW4gc2VyaWFsaXplZCBhczpcbiAgICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgLy8gICB1cmw6ICcuLi4nLFxuICAgICAgICAvLyAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAvLyAgIGhlYWRlcnM6IFt7a2V5OiAneC1hbXotZGF0ZScsIHZhbHVlOiAnLi4uJ30sIC4uLl1cbiAgICAgICAgLy8gfSkpXG4gICAgICAgIGNvbnN0IHJlZm9ybWF0dGVkSGVhZGVyID0gW107XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkSGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgLy8gVGhlIGZ1bGwsIGNhbm9uaWNhbCByZXNvdXJjZSBuYW1lIG9mIHRoZSB3b3JrbG9hZCBpZGVudGl0eSBwb29sXG4gICAgICAgICAgICAvLyBwcm92aWRlciwgd2l0aCBvciB3aXRob3V0IHRoZSBIVFRQUyBwcmVmaXguXG4gICAgICAgICAgICAvLyBJbmNsdWRpbmcgdGhpcyBoZWFkZXIgYXMgcGFydCBvZiB0aGUgc2lnbmF0dXJlIGlzIHJlY29tbWVuZGVkIHRvXG4gICAgICAgICAgICAvLyBlbnN1cmUgZGF0YSBpbnRlZ3JpdHkuXG4gICAgICAgICAgICAneC1nb29nLWNsb3VkLXRhcmdldC1yZXNvdXJjZSc6IHRoaXMuYXVkaWVuY2UsXG4gICAgICAgIH0sIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIC8vIFJlZm9ybWF0IGhlYWRlciB0byBHQ1AgU1RTIGV4cGVjdGVkIGZvcm1hdC5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZXh0ZW5kZWRIZWFkZXJzKSB7XG4gICAgICAgICAgICByZWZvcm1hdHRlZEhlYWRlci5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4dGVuZGVkSGVhZGVyc1trZXldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VyaWFsaXplIHRoZSByZWZvcm1hdHRlZCBzaWduZWQgcmVxdWVzdC5cbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlZm9ybWF0dGVkSGVhZGVyLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgSU1EU3YyIFNlc3Npb24gVG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SW1kc1YyU2Vzc2lvblRva2VuKCkge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsOiB0aGlzLmltZHNWMlNlc3Npb25Ub2tlblVybCxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ3gtYXdzLWVjMi1tZXRhZGF0YS10b2tlbi10dGwtc2Vjb25kcyc6ICczMDAnIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGhlYWRlcnMgVGhlIGhlYWRlcnMgdG8gYmUgdXNlZCBpbiB0aGUgbWV0YWRhdGEgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGN1cnJlbnQgQVdTIHJlZ2lvbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBd3NSZWdpb24oaGVhZGVycykge1xuICAgICAgICAvLyBQcmlvcml0eSBvcmRlciBmb3IgcmVnaW9uIGRldGVybWluYXRpb246XG4gICAgICAgIC8vIEFXU19SRUdJT04gPiBBV1NfREVGQVVMVF9SRUdJT04gPiBtZXRhZGF0YSBzZXJ2ZXIuXG4gICAgICAgIGlmICh0aGlzLnJlZ2lvbkZyb21FbnYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lvbkZyb21FbnY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlZ2lvblVybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGV0ZXJtaW5lIEFXUyByZWdpb24gZHVlIHRvIG1pc3NpbmcgJyArXG4gICAgICAgICAgICAgICAgJ1wib3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5yZWdpb25fdXJsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsOiB0aGlzLnJlZ2lvblVybCxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICAvLyBSZW1vdmUgbGFzdCBjaGFyYWN0ZXIuIEZvciBleGFtcGxlLCBpZiB1cy1lYXN0LTJiIGlzIHJldHVybmVkLFxuICAgICAgICAvLyB0aGUgcmVnaW9uIHdvdWxkIGJlIHVzLWVhc3QtMi5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuc3Vic3RyKDAsIHJlc3BvbnNlLmRhdGEubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBoZWFkZXJzIFRoZSBoZWFkZXJzIHRvIGJlIHVzZWQgaW4gdGhlIG1ldGFkYXRhIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBhc3NpZ25lZCByb2xlIHRvIHRoZSBjdXJyZW50XG4gICAgICogICBBV1MgVk0uIFRoaXMgaXMgbmVlZGVkIGZvciBjYWxsaW5nIHRoZSBzZWN1cml0eS1jcmVkZW50aWFscyBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBd3NSb2xlTmFtZShoZWFkZXJzKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzVXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZXRlcm1pbmUgQVdTIHJvbGUgbmFtZSBkdWUgdG8gbWlzc2luZyAnICtcbiAgICAgICAgICAgICAgICAnXCJvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLnVybFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIHVybDogdGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzVXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHRlbXBvcmFyeSBBV1MgY3JlZGVudGlhbHMgYnkgY2FsbGluZyB0aGUgc2VjdXJpdHktY3JlZGVudGlhbHNcbiAgICAgKiBlbmRwb2ludCBhcyBzcGVjaWZpZWQgaW4gdGhlIGBjcmVkZW50aWFsX3NvdXJjZWAgb2JqZWN0LlxuICAgICAqIEBwYXJhbSByb2xlTmFtZSBUaGUgcm9sZSBhdHRhY2hlZCB0byB0aGUgY3VycmVudCBWTS5cbiAgICAgKiBAcGFyYW0gaGVhZGVycyBUaGUgaGVhZGVycyB0byBiZSB1c2VkIGluIHRoZSBtZXRhZGF0YSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdGVtcG9yYXJ5IEFXUyBjcmVkZW50aWFsc1xuICAgICAqICAgbmVlZGVkIGZvciBjcmVhdGluZyB0aGUgR2V0Q2FsbGVySWRlbnRpdHkgc2lnbmVkIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXdzU2VjdXJpdHlDcmVkZW50aWFscyhyb2xlTmFtZSwgaGVhZGVycykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7XG4gICAgICAgICAgICB1cmw6IGAke3RoaXMuc2VjdXJpdHlDcmVkZW50aWFsc1VybH0vJHtyb2xlTmFtZX1gLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIHNob3VsZFVzZU1ldGFkYXRhU2VydmVyKCkge1xuICAgICAgICAvLyBUaGUgbWV0YWRhdGEgc2VydmVyIG11c3QgYmUgdXNlZCB3aGVuIGVpdGhlciB0aGUgQVdTIHJlZ2lvbiBvciBBV1Mgc2VjdXJpdHlcbiAgICAgICAgLy8gY3JlZGVudGlhbHMgY2Fubm90IGJlIHJldHJpZXZlZCB0aHJvdWdoIHRoZWlyIGRlZmluZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAgICByZXR1cm4gIXRoaXMucmVnaW9uRnJvbUVudiB8fCAhdGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzRnJvbUVudjtcbiAgICB9XG4gICAgZ2V0IHJlZ2lvbkZyb21FbnYoKSB7XG4gICAgICAgIC8vIFRoZSBBV1MgcmVnaW9uIGNhbiBiZSBwcm92aWRlZCB0aHJvdWdoIEFXU19SRUdJT04gb3IgQVdTX0RFRkFVTFRfUkVHSU9OLlxuICAgICAgICAvLyBPbmx5IG9uZSBpcyByZXF1aXJlZC5cbiAgICAgICAgcmV0dXJuIChwcm9jZXNzLmVudlsnQVdTX1JFR0lPTiddIHx8IHByb2Nlc3MuZW52WydBV1NfREVGQVVMVF9SRUdJT04nXSB8fCBudWxsKTtcbiAgICB9XG4gICAgZ2V0IHNlY3VyaXR5Q3JlZGVudGlhbHNGcm9tRW52KCkge1xuICAgICAgICAvLyBCb3RoIEFXU19BQ0NFU1NfS0VZX0lEIGFuZCBBV1NfU0VDUkVUX0FDQ0VTU19LRVkgYXJlIHJlcXVpcmVkLlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnZbJ0FXU19BQ0NFU1NfS0VZX0lEJ10gJiZcbiAgICAgICAgICAgIHByb2Nlc3MuZW52WydBV1NfU0VDUkVUX0FDQ0VTU19LRVknXSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NLZXlJZDogcHJvY2Vzcy5lbnZbJ0FXU19BQ0NFU1NfS0VZX0lEJ10sXG4gICAgICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiBwcm9jZXNzLmVudlsnQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZJ10sXG4gICAgICAgICAgICAgICAgdG9rZW46IHByb2Nlc3MuZW52WydBV1NfU0VTU0lPTl9UT0tFTiddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkF3c0NsaWVudCA9IEF3c0NsaWVudDtcbkF3c0NsaWVudC5BV1NfRUMyX01FVEFEQVRBX0lQVjRfQUREUkVTUyA9ICcxNjkuMjU0LjE2OS4yNTQnO1xuQXdzQ2xpZW50LkFXU19FQzJfTUVUQURBVEFfSVBWNl9BRERSRVNTID0gJ2ZkMDA6ZWMyOjoyNTQnO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXdzQ2xpZW50IiwiYXdzcmVxdWVzdHNpZ25lcl8xIiwicmVxdWlyZSIsImJhc2VleHRlcm5hbGNsaWVudF8xIiwiQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImFkZGl0aW9uYWxPcHRpb25zIiwiZW52aXJvbm1lbnRJZCIsImNyZWRlbnRpYWxfc291cmNlIiwiZW52aXJvbm1lbnRfaWQiLCJyZWdpb25VcmwiLCJyZWdpb25fdXJsIiwic2VjdXJpdHlDcmVkZW50aWFsc1VybCIsInVybCIsInJlZ2lvbmFsQ3JlZFZlcmlmaWNhdGlvblVybCIsInJlZ2lvbmFsX2NyZWRfdmVyaWZpY2F0aW9uX3VybCIsImltZHNWMlNlc3Npb25Ub2tlblVybCIsImltZHN2Ml9zZXNzaW9uX3Rva2VuX3VybCIsImF3c1JlcXVlc3RTaWduZXIiLCJyZWdpb24iLCJjcmVkZW50aWFsU291cmNlVHlwZSIsInZhbGlkYXRlRW52aXJvbm1lbnRJZCIsIl9hIiwibWF0Y2giLCJFcnJvciIsInBhcnNlSW50IiwicmV0cmlldmVTdWJqZWN0VG9rZW4iLCJtZXRhZGF0YUhlYWRlcnMiLCJzaG91bGRVc2VNZXRhZGF0YVNlcnZlciIsImdldEltZHNWMlNlc3Npb25Ub2tlbiIsImdldEF3c1JlZ2lvbiIsIkF3c1JlcXVlc3RTaWduZXIiLCJzZWN1cml0eUNyZWRlbnRpYWxzRnJvbUVudiIsInJvbGVOYW1lIiwiZ2V0QXdzUm9sZU5hbWUiLCJhd3NDcmVkcyIsImdldEF3c1NlY3VyaXR5Q3JlZGVudGlhbHMiLCJhY2Nlc3NLZXlJZCIsIkFjY2Vzc0tleUlkIiwic2VjcmV0QWNjZXNzS2V5IiwiU2VjcmV0QWNjZXNzS2V5IiwidG9rZW4iLCJUb2tlbiIsImdldFJlcXVlc3RPcHRpb25zIiwicmVwbGFjZSIsIm1ldGhvZCIsInJlZm9ybWF0dGVkSGVhZGVyIiwiZXh0ZW5kZWRIZWFkZXJzIiwiYXNzaWduIiwiYXVkaWVuY2UiLCJoZWFkZXJzIiwia2V5IiwicHVzaCIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJvcHRzIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2UiLCJ0cmFuc3BvcnRlciIsInJlcXVlc3QiLCJkYXRhIiwicmVnaW9uRnJvbUVudiIsInN1YnN0ciIsImxlbmd0aCIsInByb2Nlc3MiLCJlbnYiLCJBV1NfRUMyX01FVEFEQVRBX0lQVjRfQUREUkVTUyIsIkFXU19FQzJfTUVUQURBVEFfSVBWNl9BRERSRVNTIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/awsclient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AwsRequestSigner = void 0;\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(action-browser)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\n/** AWS Signature Version 4 signing algorithm identifier.  */ const AWS_ALGORITHM = \"AWS4-HMAC-SHA256\";\n/**\n * The termination string for the AWS credential scope value as defined in\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n */ const AWS_REQUEST_TYPE = \"aws4_request\";\n/**\n * Implements an AWS API request signer based on the AWS Signature Version 4\n * signing process.\n * https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */ class AwsRequestSigner {\n    /**\n     * Instantiates an AWS API request signer used to send authenticated signed\n     * requests to AWS APIs based on the AWS Signature Version 4 signing process.\n     * This also provides a mechanism to generate the signed request without\n     * sending it.\n     * @param getCredentials A mechanism to retrieve AWS security credentials\n     *   when needed.\n     * @param region The AWS region to use.\n     */ constructor(getCredentials, region){\n        this.getCredentials = getCredentials;\n        this.region = region;\n        this.crypto = (0, crypto_1.createCrypto)();\n    }\n    /**\n     * Generates the signed request for the provided HTTP request for calling\n     * an AWS API. This follows the steps described at:\n     * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html\n     * @param amzOptions The AWS request options that need to be signed.\n     * @return A promise that resolves with the GaxiosOptions containing the\n     *   signed HTTP request parameters.\n     */ async getRequestOptions(amzOptions) {\n        if (!amzOptions.url) {\n            throw new Error('\"url\" is required in \"amzOptions\"');\n        }\n        // Stringify JSON requests. This will be set in the request body of the\n        // generated signed request.\n        const requestPayloadData = typeof amzOptions.data === \"object\" ? JSON.stringify(amzOptions.data) : amzOptions.data;\n        const url = amzOptions.url;\n        const method = amzOptions.method || \"GET\";\n        const requestPayload = amzOptions.body || requestPayloadData;\n        const additionalAmzHeaders = amzOptions.headers;\n        const awsSecurityCredentials = await this.getCredentials();\n        const uri = new URL(url);\n        const headerMap = await generateAuthenticationHeaderMap({\n            crypto: this.crypto,\n            host: uri.host,\n            canonicalUri: uri.pathname,\n            canonicalQuerystring: uri.search.substr(1),\n            method,\n            region: this.region,\n            securityCredentials: awsSecurityCredentials,\n            requestPayload,\n            additionalAmzHeaders\n        });\n        // Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.\n        const headers = Object.assign(// Add x-amz-date if available.\n        headerMap.amzDate ? {\n            \"x-amz-date\": headerMap.amzDate\n        } : {}, {\n            Authorization: headerMap.authorizationHeader,\n            host: uri.host\n        }, additionalAmzHeaders || {});\n        if (awsSecurityCredentials.token) {\n            Object.assign(headers, {\n                \"x-amz-security-token\": awsSecurityCredentials.token\n            });\n        }\n        const awsSignedReq = {\n            url,\n            method: method,\n            headers\n        };\n        if (typeof requestPayload !== \"undefined\") {\n            awsSignedReq.body = requestPayload;\n        }\n        return awsSignedReq;\n    }\n}\nexports.AwsRequestSigner = AwsRequestSigner;\n/**\n * Creates the HMAC-SHA256 hash of the provided message using the\n * provided key.\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The HMAC-SHA256 key to use.\n * @param msg The message to hash.\n * @return The computed hash bytes.\n */ async function sign(crypto, key, msg) {\n    return await crypto.signWithHmacSha256(key, msg);\n}\n/**\n * Calculates the signing key used to calculate the signature for\n * AWS Signature Version 4 based on:\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The AWS secret access key.\n * @param dateStamp The '%Y%m%d' date format.\n * @param region The AWS region.\n * @param serviceName The AWS service name, eg. sts.\n * @return The signing key bytes.\n */ async function getSigningKey(crypto, key, dateStamp, region, serviceName) {\n    const kDate = await sign(crypto, `AWS4${key}`, dateStamp);\n    const kRegion = await sign(crypto, kDate, region);\n    const kService = await sign(crypto, kRegion, serviceName);\n    const kSigning = await sign(crypto, kService, \"aws4_request\");\n    return kSigning;\n}\n/**\n * Generates the authentication header map needed for generating the AWS\n * Signature Version 4 signed request.\n *\n * @param option The options needed to compute the authentication header map.\n * @return The AWS authentication header map which constitutes of the following\n *   components: amz-date, authorization header and canonical query string.\n */ async function generateAuthenticationHeaderMap(options) {\n    const additionalAmzHeaders = options.additionalAmzHeaders || {};\n    const requestPayload = options.requestPayload || \"\";\n    // iam.amazonaws.com host => iam service.\n    // sts.us-east-2.amazonaws.com => sts service.\n    const serviceName = options.host.split(\".\")[0];\n    const now = new Date();\n    // Format: '%Y%m%dT%H%M%SZ'.\n    const amzDate = now.toISOString().replace(/[-:]/g, \"\").replace(/\\.[0-9]+/, \"\");\n    // Format: '%Y%m%d'.\n    const dateStamp = now.toISOString().replace(/[-]/g, \"\").replace(/T.*/, \"\");\n    // Change all additional headers to be lower case.\n    const reformattedAdditionalAmzHeaders = {};\n    Object.keys(additionalAmzHeaders).forEach((key)=>{\n        reformattedAdditionalAmzHeaders[key.toLowerCase()] = additionalAmzHeaders[key];\n    });\n    // Add AWS token if available.\n    if (options.securityCredentials.token) {\n        reformattedAdditionalAmzHeaders[\"x-amz-security-token\"] = options.securityCredentials.token;\n    }\n    // Header keys need to be sorted alphabetically.\n    const amzHeaders = Object.assign({\n        host: options.host\n    }, // Previously the date was not fixed with x-amz- and could be provided manually.\n    // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\n    reformattedAdditionalAmzHeaders.date ? {} : {\n        \"x-amz-date\": amzDate\n    }, reformattedAdditionalAmzHeaders);\n    let canonicalHeaders = \"\";\n    const signedHeadersList = Object.keys(amzHeaders).sort();\n    signedHeadersList.forEach((key)=>{\n        canonicalHeaders += `${key}:${amzHeaders[key]}\\n`;\n    });\n    const signedHeaders = signedHeadersList.join(\";\");\n    const payloadHash = await options.crypto.sha256DigestHex(requestPayload);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n    const canonicalRequest = `${options.method}\\n` + `${options.canonicalUri}\\n` + `${options.canonicalQuerystring}\\n` + `${canonicalHeaders}\\n` + `${signedHeaders}\\n` + `${payloadHash}`;\n    const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n    const stringToSign = `${AWS_ALGORITHM}\\n` + `${amzDate}\\n` + `${credentialScope}\\n` + await options.crypto.sha256DigestHex(canonicalRequest);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n    const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);\n    const signature = await sign(options.crypto, signingKey, stringToSign);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n    const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/` + `${credentialScope}, SignedHeaders=${signedHeaders}, ` + `Signature=${(0, crypto_1.fromArrayBufferToHex)(signature)}`;\n    return {\n        // Do not return x-amz-date if date is available.\n        amzDate: reformattedAdditionalAmzHeaders.date ? undefined : amzDate,\n        authorizationHeader,\n        canonicalQuerystring: options.canonicalQuerystring\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2F3c3JlcXVlc3RzaWduZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBRyxLQUFLO0FBQ2hDLE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLHdHQUFrQjtBQUMzQywyREFBMkQsR0FDM0QsTUFBTUMsZ0JBQWdCO0FBQ3RCOzs7Q0FHQyxHQUNELE1BQU1DLG1CQUFtQjtBQUN6Qjs7OztDQUlDLEdBQ0QsTUFBTUo7SUFDRjs7Ozs7Ozs7S0FRQyxHQUNESyxZQUFZQyxjQUFjLEVBQUVDLE1BQU0sQ0FBRTtRQUNoQyxJQUFJLENBQUNELGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxHQUFHUCxTQUFTUSxZQUFZO0lBQzNDO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNELE1BQU1DLGtCQUFrQkMsVUFBVSxFQUFFO1FBQ2hDLElBQUksQ0FBQ0EsV0FBV0MsR0FBRyxFQUFFO1lBQ2pCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLHVFQUF1RTtRQUN2RSw0QkFBNEI7UUFDNUIsTUFBTUMscUJBQXFCLE9BQU9ILFdBQVdJLElBQUksS0FBSyxXQUNoREMsS0FBS0MsU0FBUyxDQUFDTixXQUFXSSxJQUFJLElBQzlCSixXQUFXSSxJQUFJO1FBQ3JCLE1BQU1ILE1BQU1ELFdBQVdDLEdBQUc7UUFDMUIsTUFBTU0s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QyxDQUFDLEVBQUV3QyxZQUFZLENBQUMsRUFBRTNDLGlCQUFpQixDQUFDO0lBQzNGLGlGQUFpRjtJQUNqRixNQUFNcUUsZUFBZSxDQUFDLEVBQUV0RSxjQUFjLEVBQUUsQ0FBQyxHQUNyQyxDQUFDLEVBQUVpQyxRQUFRLEVBQUUsQ0FBQyxHQUNkLENBQUMsRUFBRW9DLGdCQUFnQixFQUFFLENBQUMsR0FDckIsTUFBTXBCLFFBQVE1QyxNQUFNLENBQUM4RCxlQUFlLENBQUNDO0lBQzFDLCtFQUErRTtJQUMvRSxNQUFNRyxhQUFhLE1BQU03QixjQUFjTyxRQUFRNUMsTUFBTSxFQUFFNEMsUUFBUWxCLG1CQUFtQixDQUFDeUMsZUFBZSxFQUFFN0IsV0FBV00sUUFBUTdDLE1BQU0sRUFBRXdDO0lBQy9ILE1BQU02QixZQUFZLE1BQU1uQyxLQUFLVyxRQUFRNUMsTUFBTSxFQUFFa0UsWUFBWUQ7SUFDekQsb0ZBQW9GO0lBQ3BGLE1BQU1uQyxzQkFBc0IsQ0FBQyxFQUFFbkMsY0FBYyxZQUFZLEVBQUVpRCxRQUFRbEIsbUJBQW1CLENBQUMyQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQ2pHLENBQUMsRUFBRUwsZ0JBQWdCLGdCQUFnQixFQUFFTCxjQUFjLEVBQUUsQ0FBQyxHQUN0RCxDQUFDLFVBQVUsRUFBRSxDQUFDLEdBQUdsRSxTQUFTNkUsb0JBQW9CLEVBQUVGLFdBQVcsQ0FBQztJQUNoRSxPQUFPO1FBQ0gsaURBQWlEO1FBQ2pEeEMsU0FBU3NCLGdDQUFnQ0ssSUFBSSxHQUFHZ0IsWUFBWTNDO1FBQzVERTtRQUNBUCxzQkFBc0JxQixRQUFRckIsb0JBQW9CO0lBQ3REO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hd3NyZXF1ZXN0c2lnbmVyLmpzPzk1ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXdzUmVxdWVzdFNpZ25lciA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9jcnlwdG9cIik7XG4vKiogQVdTIFNpZ25hdHVyZSBWZXJzaW9uIDQgc2lnbmluZyBhbGdvcml0aG0gaWRlbnRpZmllci4gICovXG5jb25zdCBBV1NfQUxHT1JJVEhNID0gJ0FXUzQtSE1BQy1TSEEyNTYnO1xuLyoqXG4gKiBUaGUgdGVybWluYXRpb24gc3RyaW5nIGZvciB0aGUgQVdTIGNyZWRlbnRpYWwgc2NvcGUgdmFsdWUgYXMgZGVmaW5lZCBpblxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNyZWF0ZS1zdHJpbmctdG8tc2lnbi5odG1sXG4gKi9cbmNvbnN0IEFXU19SRVFVRVNUX1RZUEUgPSAnYXdzNF9yZXF1ZXN0Jztcbi8qKlxuICogSW1wbGVtZW50cyBhbiBBV1MgQVBJIHJlcXVlc3Qgc2lnbmVyIGJhc2VkIG9uIHRoZSBBV1MgU2lnbmF0dXJlIFZlcnNpb24gNFxuICogc2lnbmluZyBwcm9jZXNzLlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ25hdHVyZS12ZXJzaW9uLTQuaHRtbFxuICovXG5jbGFzcyBBd3NSZXF1ZXN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gQVdTIEFQSSByZXF1ZXN0IHNpZ25lciB1c2VkIHRvIHNlbmQgYXV0aGVudGljYXRlZCBzaWduZWRcbiAgICAgKiByZXF1ZXN0cyB0byBBV1MgQVBJcyBiYXNlZCBvbiB0aGUgQVdTIFNpZ25hdHVyZSBWZXJzaW9uIDQgc2lnbmluZyBwcm9jZXNzLlxuICAgICAqIFRoaXMgYWxzbyBwcm92aWRlcyBhIG1lY2hhbmlzbSB0byBnZW5lcmF0ZSB0aGUgc2lnbmVkIHJlcXVlc3Qgd2l0aG91dFxuICAgICAqIHNlbmRpbmcgaXQuXG4gICAgICogQHBhcmFtIGdldENyZWRlbnRpYWxzIEEgbWVjaGFuaXNtIHRvIHJldHJpZXZlIEFXUyBzZWN1cml0eSBjcmVkZW50aWFsc1xuICAgICAqICAgd2hlbiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHJlZ2lvbiBUaGUgQVdTIHJlZ2lvbiB0byB1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2V0Q3JlZGVudGlhbHMsIHJlZ2lvbikge1xuICAgICAgICB0aGlzLmdldENyZWRlbnRpYWxzID0gZ2V0Q3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgICAgICB0aGlzLmNyeXB0byA9ICgwLCBjcnlwdG9fMS5jcmVhdGVDcnlwdG8pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgc2lnbmVkIHJlcXVlc3QgZm9yIHRoZSBwcm92aWRlZCBIVFRQIHJlcXVlc3QgZm9yIGNhbGxpbmdcbiAgICAgKiBhbiBBV1MgQVBJLiBUaGlzIGZvbGxvd3MgdGhlIHN0ZXBzIGRlc2NyaWJlZCBhdDpcbiAgICAgKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2VuZXJhbC9sYXRlc3QvZ3Ivc2lndjRfc2lnbmluZy5odG1sXG4gICAgICogQHBhcmFtIGFtek9wdGlvbnMgVGhlIEFXUyByZXF1ZXN0IG9wdGlvbnMgdGhhdCBuZWVkIHRvIGJlIHNpZ25lZC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEdheGlvc09wdGlvbnMgY29udGFpbmluZyB0aGVcbiAgICAgKiAgIHNpZ25lZCBIVFRQIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0T3B0aW9ucyhhbXpPcHRpb25zKSB7XG4gICAgICAgIGlmICghYW16T3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJ1cmxcIiBpcyByZXF1aXJlZCBpbiBcImFtek9wdGlvbnNcIicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cmluZ2lmeSBKU09OIHJlcXVlc3RzLiBUaGlzIHdpbGwgYmUgc2V0IGluIHRoZSByZXF1ZXN0IGJvZHkgb2YgdGhlXG4gICAgICAgIC8vIGdlbmVyYXRlZCBzaWduZWQgcmVxdWVzdC5cbiAgICAgICAgY29uc3QgcmVxdWVzdFBheWxvYWREYXRhID0gdHlwZW9mIGFtek9wdGlvbnMuZGF0YSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYW16T3B0aW9ucy5kYXRhKVxuICAgICAgICAgICAgOiBhbXpPcHRpb25zLmRhdGE7XG4gICAgICAgIGNvbnN0IHVybCA9IGFtek9wdGlvbnMudXJsO1xuICAgICAgICBjb25zdCBtZXRob2QgPSBhbXpPcHRpb25zLm1ldGhvZCB8fCAnR0VUJztcbiAgICAgICAgY29uc3QgcmVxdWVzdFBheWxvYWQgPSBhbXpPcHRpb25zLmJvZHkgfHwgcmVxdWVzdFBheWxvYWREYXRhO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsQW16SGVhZGVycyA9IGFtek9wdGlvbnMuaGVhZGVycztcbiAgICAgICAgY29uc3QgYXdzU2VjdXJpdHlDcmVkZW50aWFscyA9IGF3YWl0IHRoaXMuZ2V0Q3JlZGVudGlhbHMoKTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICBjb25zdCBoZWFkZXJNYXAgPSBhd2FpdCBnZW5lcmF0ZUF1dGhlbnRpY2F0aW9uSGVhZGVyTWFwKHtcbiAgICAgICAgICAgIGNyeXB0bzogdGhpcy5jcnlwdG8sXG4gICAgICAgICAgICBob3N0OiB1cmkuaG9zdCxcbiAgICAgICAgICAgIGNhbm9uaWNhbFVyaTogdXJpLnBhdGhuYW1lLFxuICAgICAgICAgICAgY2Fub25pY2FsUXVlcnlzdHJpbmc6IHVyaS5zZWFyY2guc3Vic3RyKDEpLFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVnaW9uOiB0aGlzLnJlZ2lvbixcbiAgICAgICAgICAgIHNlY3VyaXR5Q3JlZGVudGlhbHM6IGF3c1NlY3VyaXR5Q3JlZGVudGlhbHMsXG4gICAgICAgICAgICByZXF1ZXN0UGF5bG9hZCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxBbXpIZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXBwZW5kIGFkZGl0aW9uYWwgb3B0aW9uYWwgaGVhZGVycywgZWcuIFgtQW16LVRhcmdldCwgQ29udGVudC1UeXBlLCBldGMuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAvLyBBZGQgeC1hbXotZGF0ZSBpZiBhdmFpbGFibGUuXG4gICAgICAgIGhlYWRlck1hcC5hbXpEYXRlID8geyAneC1hbXotZGF0ZSc6IGhlYWRlck1hcC5hbXpEYXRlIH0gOiB7fSwge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogaGVhZGVyTWFwLmF1dGhvcml6YXRpb25IZWFkZXIsXG4gICAgICAgICAgICBob3N0OiB1cmkuaG9zdCxcbiAgICAgICAgfSwgYWRkaXRpb25hbEFtekhlYWRlcnMgfHwge30pO1xuICAgICAgICBpZiAoYXdzU2VjdXJpdHlDcmVkZW50aWFscy50b2tlbikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgJ3gtYW16LXNlY3VyaXR5LXRva2VuJzogYXdzU2VjdXJpdHlDcmVkZW50aWFscy50b2tlbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF3c1NpZ25lZFJlcSA9IHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UGF5bG9hZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGF3c1NpZ25lZFJlcS5ib2R5ID0gcmVxdWVzdFBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3c1NpZ25lZFJlcTtcbiAgICB9XG59XG5leHBvcnRzLkF3c1JlcXVlc3RTaWduZXIgPSBBd3NSZXF1ZXN0U2lnbmVyO1xuLyoqXG4gKiBDcmVhdGVzIHRoZSBITUFDLVNIQTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZCBtZXNzYWdlIHVzaW5nIHRoZVxuICogcHJvdmlkZWQga2V5LlxuICpcbiAqIEBwYXJhbSBjcnlwdG8gVGhlIGNyeXB0byBpbnN0YW5jZSB1c2VkIHRvIGZhY2lsaXRhdGUgY3J5cHRvZ3JhcGhpY1xuICogICBvcGVyYXRpb25zLlxuICogQHBhcmFtIGtleSBUaGUgSE1BQy1TSEEyNTYga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtc2cgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEByZXR1cm4gVGhlIGNvbXB1dGVkIGhhc2ggYnl0ZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ24oY3J5cHRvLCBrZXksIG1zZykge1xuICAgIHJldHVybiBhd2FpdCBjcnlwdG8uc2lnbldpdGhIbWFjU2hhMjU2KGtleSwgbXNnKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc2lnbmluZyBrZXkgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIEFXUyBTaWduYXR1cmUgVmVyc2lvbiA0IGJhc2VkIG9uOlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNhbGN1bGF0ZS1zaWduYXR1cmUuaHRtbFxuICpcbiAqIEBwYXJhbSBjcnlwdG8gVGhlIGNyeXB0byBpbnN0YW5jZSB1c2VkIHRvIGZhY2lsaXRhdGUgY3J5cHRvZ3JhcGhpY1xuICogICBvcGVyYXRpb25zLlxuICogQHBhcmFtIGtleSBUaGUgQVdTIHNlY3JldCBhY2Nlc3Mga2V5LlxuICogQHBhcmFtIGRhdGVTdGFtcCBUaGUgJyVZJW0lZCcgZGF0ZSBmb3JtYXQuXG4gKiBAcGFyYW0gcmVnaW9uIFRoZSBBV1MgcmVnaW9uLlxuICogQHBhcmFtIHNlcnZpY2VOYW1lIFRoZSBBV1Mgc2VydmljZSBuYW1lLCBlZy4gc3RzLlxuICogQHJldHVybiBUaGUgc2lnbmluZyBrZXkgYnl0ZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFNpZ25pbmdLZXkoY3J5cHRvLCBrZXksIGRhdGVTdGFtcCwgcmVnaW9uLCBzZXJ2aWNlTmFtZSkge1xuICAgIGNvbnN0IGtEYXRlID0gYXdhaXQgc2lnbihjcnlwdG8sIGBBV1M0JHtrZXl9YCwgZGF0ZVN0YW1wKTtcbiAgICBjb25zdCBrUmVnaW9uID0gYXdhaXQgc2lnbihjcnlwdG8sIGtEYXRlLCByZWdpb24pO1xuICAgIGNvbnN0IGtTZXJ2aWNlID0gYXdhaXQgc2lnbihjcnlwdG8sIGtSZWdpb24sIHNlcnZpY2VOYW1lKTtcbiAgICBjb25zdCBrU2lnbmluZyA9IGF3YWl0IHNpZ24oY3J5cHRvLCBrU2VydmljZSwgJ2F3czRfcmVxdWVzdCcpO1xuICAgIHJldHVybiBrU2lnbmluZztcbn1cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBhdXRoZW50aWNhdGlvbiBoZWFkZXIgbWFwIG5lZWRlZCBmb3IgZ2VuZXJhdGluZyB0aGUgQVdTXG4gKiBTaWduYXR1cmUgVmVyc2lvbiA0IHNpZ25lZCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBvcHRpb24gVGhlIG9wdGlvbnMgbmVlZGVkIHRvIGNvbXB1dGUgdGhlIGF1dGhlbnRpY2F0aW9uIGhlYWRlciBtYXAuXG4gKiBAcmV0dXJuIFRoZSBBV1MgYXV0aGVudGljYXRpb24gaGVhZGVyIG1hcCB3aGljaCBjb25zdGl0dXRlcyBvZiB0aGUgZm9sbG93aW5nXG4gKiAgIGNvbXBvbmVudHM6IGFtei1kYXRlLCBhdXRob3JpemF0aW9uIGhlYWRlciBhbmQgY2Fub25pY2FsIHF1ZXJ5IHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVBdXRoZW50aWNhdGlvbkhlYWRlck1hcChvcHRpb25zKSB7XG4gICAgY29uc3QgYWRkaXRpb25hbEFtekhlYWRlcnMgPSBvcHRpb25zLmFkZGl0aW9uYWxBbXpIZWFkZXJzIHx8IHt9O1xuICAgIGNvbnN0IHJlcXVlc3RQYXlsb2FkID0gb3B0aW9ucy5yZXF1ZXN0UGF5bG9hZCB8fCAnJztcbiAgICAvLyBpYW0uYW1hem9uYXdzLmNvbSBob3N0ID0+IGlhbSBzZXJ2aWNlLlxuICAgIC8vIHN0cy51cy1lYXN0LTIuYW1hem9uYXdzLmNvbSA9PiBzdHMgc2VydmljZS5cbiAgICBjb25zdCBzZXJ2aWNlTmFtZSA9IG9wdGlvbnMuaG9zdC5zcGxpdCgnLicpWzBdO1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgLy8gRm9ybWF0OiAnJVklbSVkVCVIJU0lU1onLlxuICAgIGNvbnN0IGFtekRhdGUgPSBub3dcbiAgICAgICAgLnRvSVNPU3RyaW5nKClcbiAgICAgICAgLnJlcGxhY2UoL1stOl0vZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9cXC5bMC05XSsvLCAnJyk7XG4gICAgLy8gRm9ybWF0OiAnJVklbSVkJy5cbiAgICBjb25zdCBkYXRlU3RhbXAgPSBub3cudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bLV0vZywgJycpLnJlcGxhY2UoL1QuKi8sICcnKTtcbiAgICAvLyBDaGFuZ2UgYWxsIGFkZGl0aW9uYWwgaGVhZGVycyB0byBiZSBsb3dlciBjYXNlLlxuICAgIGNvbnN0IHJlZm9ybWF0dGVkQWRkaXRpb25hbEFtekhlYWRlcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsQW16SGVhZGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICByZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9XG4gICAgICAgICAgICBhZGRpdGlvbmFsQW16SGVhZGVyc1trZXldO1xuICAgIH0pO1xuICAgIC8vIEFkZCBBV1MgdG9rZW4gaWYgYXZhaWxhYmxlLlxuICAgIGlmIChvcHRpb25zLnNlY3VyaXR5Q3JlZGVudGlhbHMudG9rZW4pIHtcbiAgICAgICAgcmVmb3JtYXR0ZWRBZGRpdGlvbmFsQW16SGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXSA9XG4gICAgICAgICAgICBvcHRpb25zLnNlY3VyaXR5Q3JlZGVudGlhbHMudG9rZW47XG4gICAgfVxuICAgIC8vIEhlYWRlciBrZXlzIG5lZWQgdG8gYmUgc29ydGVkIGFscGhhYmV0aWNhbGx5LlxuICAgIGNvbnN0IGFtekhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgaG9zdDogb3B0aW9ucy5ob3N0LFxuICAgIH0sIFxuICAgIC8vIFByZXZpb3VzbHkgdGhlIGRhdGUgd2FzIG5vdCBmaXhlZCB3aXRoIHgtYW16LSBhbmQgY291bGQgYmUgcHJvdmlkZWQgbWFudWFsbHkuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JvdG8vYm90b2NvcmUvYmxvYi84NzlmODQ0MGE0ZTlhY2U1ZDNjZjE0NWNlOGIzZDVlNWZmYjg5MmVmL3Rlc3RzL3VuaXQvYXV0aC9hd3M0X3Rlc3RzdWl0ZS9nZXQtaGVhZGVyLXZhbHVlLXRyaW0ucmVxXG4gICAgcmVmb3JtYXR0ZWRBZGRpdGlvbmFsQW16SGVhZGVycy5kYXRlID8ge30gOiB7ICd4LWFtei1kYXRlJzogYW16RGF0ZSB9LCByZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzKTtcbiAgICBsZXQgY2Fub25pY2FsSGVhZGVycyA9ICcnO1xuICAgIGNvbnN0IHNpZ25lZEhlYWRlcnNMaXN0ID0gT2JqZWN0LmtleXMoYW16SGVhZGVycykuc29ydCgpO1xuICAgIHNpZ25lZEhlYWRlcnNMaXN0LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY2Fub25pY2FsSGVhZGVycyArPSBgJHtrZXl9OiR7YW16SGVhZGVyc1trZXldfVxcbmA7XG4gICAgfSk7XG4gICAgY29uc3Qgc2lnbmVkSGVhZGVycyA9IHNpZ25lZEhlYWRlcnNMaXN0LmpvaW4oJzsnKTtcbiAgICBjb25zdCBwYXlsb2FkSGFzaCA9IGF3YWl0IG9wdGlvbnMuY3J5cHRvLnNoYTI1NkRpZ2VzdEhleChyZXF1ZXN0UGF5bG9hZCk7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNyZWF0ZS1jYW5vbmljYWwtcmVxdWVzdC5odG1sXG4gICAgY29uc3QgY2Fub25pY2FsUmVxdWVzdCA9IGAke29wdGlvbnMubWV0aG9kfVxcbmAgK1xuICAgICAgICBgJHtvcHRpb25zLmNhbm9uaWNhbFVyaX1cXG5gICtcbiAgICAgICAgYCR7b3B0aW9ucy5jYW5vbmljYWxRdWVyeXN0cmluZ31cXG5gICtcbiAgICAgICAgYCR7Y2Fub25pY2FsSGVhZGVyc31cXG5gICtcbiAgICAgICAgYCR7c2lnbmVkSGVhZGVyc31cXG5gICtcbiAgICAgICAgYCR7cGF5bG9hZEhhc2h9YDtcbiAgICBjb25zdCBjcmVkZW50aWFsU2NvcGUgPSBgJHtkYXRlU3RhbXB9LyR7b3B0aW9ucy5yZWdpb259LyR7c2VydmljZU5hbWV9LyR7QVdTX1JFUVVFU1RfVFlQRX1gO1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWd2NC1jcmVhdGUtc3RyaW5nLXRvLXNpZ24uaHRtbFxuICAgIGNvbnN0IHN0cmluZ1RvU2lnbiA9IGAke0FXU19BTEdPUklUSE19XFxuYCArXG4gICAgICAgIGAke2FtekRhdGV9XFxuYCArXG4gICAgICAgIGAke2NyZWRlbnRpYWxTY29wZX1cXG5gICtcbiAgICAgICAgKGF3YWl0IG9wdGlvbnMuY3J5cHRvLnNoYTI1NkRpZ2VzdEhleChjYW5vbmljYWxSZXF1ZXN0KSk7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNhbGN1bGF0ZS1zaWduYXR1cmUuaHRtbFxuICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBhd2FpdCBnZXRTaWduaW5nS2V5KG9wdGlvbnMuY3J5cHRvLCBvcHRpb25zLnNlY3VyaXR5Q3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5LCBkYXRlU3RhbXAsIG9wdGlvbnMucmVnaW9uLCBzZXJ2aWNlTmFtZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbihvcHRpb25zLmNyeXB0bywgc2lnbmluZ0tleSwgc3RyaW5nVG9TaWduKTtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2VuZXJhbC9sYXRlc3QvZ3Ivc2lndjQtYWRkLXNpZ25hdHVyZS10by1yZXF1ZXN0Lmh0bWxcbiAgICBjb25zdCBhdXRob3JpemF0aW9uSGVhZGVyID0gYCR7QVdTX0FMR09SSVRITX0gQ3JlZGVudGlhbD0ke29wdGlvbnMuc2VjdXJpdHlDcmVkZW50aWFscy5hY2Nlc3NLZXlJZH0vYCArXG4gICAgICAgIGAke2NyZWRlbnRpYWxTY29wZX0sIFNpZ25lZEhlYWRlcnM9JHtzaWduZWRIZWFkZXJzfSwgYCArXG4gICAgICAgIGBTaWduYXR1cmU9JHsoMCwgY3J5cHRvXzEuZnJvbUFycmF5QnVmZmVyVG9IZXgpKHNpZ25hdHVyZSl9YDtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBEbyBub3QgcmV0dXJuIHgtYW16LWRhdGUgaWYgZGF0ZSBpcyBhdmFpbGFibGUuXG4gICAgICAgIGFtekRhdGU6IHJlZm9ybWF0dGVkQWRkaXRpb25hbEFtekhlYWRlcnMuZGF0ZSA/IHVuZGVmaW5lZCA6IGFtekRhdGUsXG4gICAgICAgIGF1dGhvcml6YXRpb25IZWFkZXIsXG4gICAgICAgIGNhbm9uaWNhbFF1ZXJ5c3RyaW5nOiBvcHRpb25zLmNhbm9uaWNhbFF1ZXJ5c3RyaW5nLFxuICAgIH07XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBd3NSZXF1ZXN0U2lnbmVyIiwiY3J5cHRvXzEiLCJyZXF1aXJlIiwiQVdTX0FMR09SSVRITSIsIkFXU19SRVFVRVNUX1RZUEUiLCJjb25zdHJ1Y3RvciIsImdldENyZWRlbnRpYWxzIiwicmVnaW9uIiwiY3J5cHRvIiwiY3JlYXRlQ3J5cHRvIiwiZ2V0UmVxdWVzdE9wdGlvbnMiLCJhbXpPcHRpb25zIiwidXJsIiwiRXJyb3IiLCJyZXF1ZXN0UGF5bG9hZERhdGEiLCJkYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1ldGhvZCIsInJlcXVlc3RQYXlsb2FkIiwiYm9keSIsImFkZGl0aW9uYWxBbXpIZWFkZXJzIiwiaGVhZGVycyIsImF3c1NlY3VyaXR5Q3JlZGVudGlhbHMiLCJ1cmkiLCJVUkwiLCJoZWFkZXJNYXAiLCJnZW5lcmF0ZUF1dGhlbnRpY2F0aW9uSGVhZGVyTWFwIiwiaG9zdCIsImNhbm9uaWNhbFVyaSIsInBhdGhuYW1lIiwiY2Fub25pY2FsUXVlcnlzdHJpbmciLCJzZWFyY2giLCJzdWJzdHIiLCJzZWN1cml0eUNyZWRlbnRpYWxzIiwiYXNzaWduIiwiYW16RGF0ZSIsIkF1dGhvcml6YXRpb24iLCJhdXRob3JpemF0aW9uSGVhZGVyIiwidG9rZW4iLCJhd3NTaWduZWRSZXEiLCJzaWduIiwia2V5IiwibXNnIiwic2lnbldpdGhIbWFjU2hhMjU2IiwiZ2V0U2lnbmluZ0tleSIsImRhdGVTdGFtcCIsInNlcnZpY2VOYW1lIiwia0RhdGUiLCJrUmVnaW9uIiwia1NlcnZpY2UiLCJrU2lnbmluZyIsIm9wdGlvbnMiLCJzcGxpdCIsIm5vdyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJyZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzIiwia2V5cyIsImZvckVhY2giLCJ0b0xvd2VyQ2FzZSIsImFtekhlYWRlcnMiLCJkYXRlIiwiY2Fub25pY2FsSGVhZGVycyIsInNpZ25lZEhlYWRlcnNMaXN0Iiwic29ydCIsInNpZ25lZEhlYWRlcnMiLCJqb2luIiwicGF5bG9hZEhhc2giLCJzaGEyNTZEaWdlc3RIZXgiLCJjYW5vbmljYWxSZXF1ZXN0IiwiY3JlZGVudGlhbFNjb3BlIiwic3RyaW5nVG9TaWduIiwic2lnbmluZ0tleSIsInNlY3JldEFjY2Vzc0tleSIsInNpZ25hdHVyZSIsImFjY2Vzc0tleUlkIiwiZnJvbUFycmF5QnVmZmVyVG9IZXgiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/baseexternalclient.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseExternalAccountClient = exports.DEFAULT_UNIVERSE = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst sts = __webpack_require__(/*! ./stscredentials */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"(action-browser)/./node_modules/google-auth-library/build/src/util.js\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */ const STS_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\";\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */ const STS_REQUEST_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\";\n/** The default OAuth scope to request when none is provided. */ const DEFAULT_OAUTH_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\n/** Default impersonated token lifespan in seconds.*/ const DEFAULT_TOKEN_LIFESPAN = 3600;\n/**\n * Offset to take into account network delays and server clock skews.\n */ exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */ exports.EXTERNAL_ACCOUNT_TYPE = \"external_account\";\n/**\n * Cloud resource manager URL used to retrieve project information.\n *\n * @deprecated use {@link BaseExternalAccountClient.cloudResourceManagerURL} instead\n **/ exports.CLOUD_RESOURCE_MANAGER = \"https://cloudresourcemanager.googleapis.com/v1/projects/\";\n/** The workforce audience pattern. */ const WORKFORCE_AUDIENCE_PATTERN = \"//iam\\\\.googleapis\\\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+\";\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst pkg = __webpack_require__(/*! ../../../package.json */ \"(action-browser)/./node_modules/google-auth-library/package.json\");\n/**\n * For backwards compatibility.\n */ var authclient_2 = __webpack_require__(/*! ./authclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nObject.defineProperty(exports, \"DEFAULT_UNIVERSE\", ({\n    enumerable: true,\n    get: function() {\n        return authclient_2.DEFAULT_UNIVERSE;\n    }\n}));\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */ class BaseExternalAccountClient extends authclient_1.AuthClient {\n    /**\n     * Instantiate a BaseExternalAccountClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file. The camelCased options\n     *   are aliases for the snake_cased options.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        super({\n            ...options,\n            ...additionalOptions\n        });\n        const opts = (0, util_1.originalOrCamelOptions)(options);\n        if (opts.get(\"type\") !== exports.EXTERNAL_ACCOUNT_TYPE) {\n            throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` + `received \"${options.type}\"`);\n        }\n        const clientId = opts.get(\"client_id\");\n        const clientSecret = opts.get(\"client_secret\");\n        const tokenUrl = opts.get(\"token_url\");\n        const subjectTokenType = opts.get(\"subject_token_type\");\n        const workforcePoolUserProject = opts.get(\"workforce_pool_user_project\");\n        const serviceAccountImpersonationUrl = opts.get(\"service_account_impersonation_url\");\n        const serviceAccountImpersonation = opts.get(\"service_account_impersonation\");\n        const serviceAccountImpersonationLifetime = (0, util_1.originalOrCamelOptions)(serviceAccountImpersonation).get(\"token_lifetime_seconds\");\n        this.cloudResourceManagerURL = new URL(opts.get(\"cloud_resource_manager_url\") || `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`);\n        if (clientId) {\n            this.clientAuth = {\n                confidentialClientType: \"basic\",\n                clientId,\n                clientSecret\n            };\n        }\n        this.stsCredential = new sts.StsCredentials(tokenUrl, this.clientAuth);\n        this.scopes = opts.get(\"scopes\") || [\n            DEFAULT_OAUTH_SCOPE\n        ];\n        this.cachedAccessToken = null;\n        this.audience = opts.get(\"audience\");\n        this.subjectTokenType = subjectTokenType;\n        this.workforcePoolUserProject = workforcePoolUserProject;\n        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n        if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {\n            throw new Error(\"workforcePoolUserProject should not be set for non-workforce pool \" + \"credentials.\");\n        }\n        this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;\n        this.serviceAccountImpersonationLifetime = serviceAccountImpersonationLifetime;\n        if (this.serviceAccountImpersonationLifetime) {\n            this.configLifetimeRequested = true;\n        } else {\n            this.configLifetimeRequested = false;\n            this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;\n        }\n        this.projectNumber = this.getProjectNumber(this.audience);\n    }\n    /** The service account email to be impersonated, if available. */ getServiceAccountEmail() {\n        var _a;\n        if (this.serviceAccountImpersonationUrl) {\n            if (this.serviceAccountImpersonationUrl.length > 256) {\n                /**\n                 * Prevents DOS attacks.\n                 * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/84}\n                 **/ throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);\n            }\n            // Parse email from URL. The formal looks as follows:\n            // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n            const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n            const result = re.exec(this.serviceAccountImpersonationUrl);\n            return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\n        }\n        return null;\n    }\n    /**\n     * Provides a mechanism to inject GCP access tokens directly.\n     * When the provided credential expires, a new credential, using the\n     * external account options, is retrieved.\n     * @param credentials The Credentials object to set on the current client.\n     */ setCredentials(credentials) {\n        super.setCredentials(credentials);\n        this.cachedAccessToken = credentials;\n    }\n    /**\n     * @return A promise that resolves with the current GCP access token\n     *   response. If the current credential is expired, a new one is retrieved.\n     */ async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */ async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * @return A promise that resolves with the project ID corresponding to the\n     *   current workload identity pool or current workforce pool if\n     *   determinable. For workforce pool credential, it returns the project ID\n     *   corresponding to the workforcePoolUserProject.\n     *   This is introduced to match the current pattern of using the Auth\n     *   library:\n     *   const projectId = await auth.getProjectId();\n     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n     *   const res = await client.request({ url });\n     *   The resource may not have permission\n     *   (resourcemanager.projects.get) to call this API or the required\n     *   scopes may not be selected:\n     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n     */ async getProjectId() {\n        const projectNumber = this.projectNumber || this.workforcePoolUserProject;\n        if (this.projectId) {\n            // Return previously determined project ID.\n            return this.projectId;\n        } else if (projectNumber) {\n            // Preferable not to use request() to avoid retrial policies.\n            const headers = await this.getRequestHeaders();\n            const response = await this.transporter.request({\n                headers,\n                url: `${this.cloudResourceManagerURL.toString()}${projectNumber}`,\n                responseType: \"json\"\n            });\n            this.projectId = response.data.projectId;\n            return this.projectId;\n        }\n        return null;\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */ async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = requestHeaders[\"x-goog-user-project\"];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * External credentials are exchanged for GCP access tokens via the token\n     * exchange endpoint and other settings provided in the client options\n     * object.\n     * If the service_account_impersonation_url is provided, an additional\n     * step to exchange the external account GCP access token for a service\n     * account impersonated token is performed.\n     * @return A promise that resolves with the fresh GCP access tokens.\n     */ async refreshAccessTokenAsync() {\n        // Retrieve the external credential.\n        const subjectToken = await this.retrieveSubjectToken();\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            audience: this.audience,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken,\n            subjectTokenType: this.subjectTokenType,\n            // generateAccessToken requires the provided access token to have\n            // scopes:\n            // https://www.googleapis.com/auth/iam or\n            // https://www.googleapis.com/auth/cloud-platform\n            // The new service account access token scopes will match the user\n            // provided ones.\n            scope: this.serviceAccountImpersonationUrl ? [\n                DEFAULT_OAUTH_SCOPE\n            ] : this.getScopesArray()\n        };\n        // Exchange the external credentials for a GCP access token.\n        // Client auth is prioritized over passing the workforcePoolUserProject\n        // parameter for STS token exchange.\n        const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? {\n            userProject: this.workforcePoolUserProject\n        } : undefined;\n        const additionalHeaders = {\n            \"x-goog-api-client\": this.getMetricsHeaderValue()\n        };\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);\n        if (this.serviceAccountImpersonationUrl) {\n            this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n        } else if (stsResponse.expires_in) {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n                res: stsResponse.res\n            };\n        } else {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                res: stsResponse.res\n            };\n        }\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit(\"tokens\", {\n            refresh_token: null,\n            expiry_date: this.cachedAccessToken.expiry_date,\n            access_token: this.cachedAccessToken.access_token,\n            token_type: \"Bearer\",\n            id_token: null\n        });\n        // Return the cached access token.\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns the workload identity pool project number if it is determinable\n     * from the audience resource name.\n     * @param audience The STS audience used to determine the project number.\n     * @return The project number associated with the workload identity pool, if\n     *   this can be determined from the STS audience field. Otherwise, null is\n     *   returned.\n     */ getProjectNumber(audience) {\n        // STS audience pattern:\n        // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n        const match = audience.match(/\\/projects\\/([^/]+)/);\n        if (!match) {\n            return null;\n        }\n        return match[1];\n    }\n    /**\n     * Exchanges an external account GCP access token for a service\n     * account impersonated access token using iamcredentials\n     * GenerateAccessToken API.\n     * @param token The access token to exchange for a service account access\n     *   token.\n     * @return A promise that resolves with the service account impersonated\n     *   credentials response.\n     */ async getImpersonatedAccessToken(token) {\n        const opts = {\n            url: this.serviceAccountImpersonationUrl,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${token}`\n            },\n            data: {\n                scope: this.getScopesArray(),\n                lifetime: this.serviceAccountImpersonationLifetime + \"s\"\n            },\n            responseType: \"json\"\n        };\n        const response = await this.transporter.request(opts);\n        const successResponse = response.data;\n        return {\n            access_token: successResponse.accessToken,\n            // Convert from ISO format to timestamp.\n            expiry_date: new Date(successResponse.expireTime).getTime(),\n            res: response\n        };\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param accessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */ isExpired(accessToken) {\n        const now = new Date().getTime();\n        return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n    /**\n     * @return The list of scopes for the requested GCP access token.\n     */ getScopesArray() {\n        // Since scopes can be provided as string or array, the type should\n        // be normalized.\n        if (typeof this.scopes === \"string\") {\n            return [\n                this.scopes\n            ];\n        }\n        return this.scopes || [\n            DEFAULT_OAUTH_SCOPE\n        ];\n    }\n    getMetricsHeaderValue() {\n        const nodeVersion = process.version.replace(/^v/, \"\");\n        const saImpersonation = this.serviceAccountImpersonationUrl !== undefined;\n        const credentialSourceType = this.credentialSourceType ? this.credentialSourceType : \"unknown\";\n        return `gl-node/${nodeVersion} auth/${pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;\n    }\n}\nexports.BaseExternalAccountClient = BaseExternalAccountClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2Jhc2VleHRlcm5hbGNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlDQUFpQyxHQUFHQSx3QkFBd0IsR0FBR0EsOEJBQThCLEdBQUdBLDZCQUE2QixHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQ3RLLE1BQU1PLFNBQVNDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQy9CLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLHNHQUFjO0FBQzNDLE1BQU1FLE1BQU1GLG1CQUFPQSxDQUFDLDhHQUFrQjtBQUN0QyxNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQyxzRkFBUztBQUNoQzs7Q0FFQyxHQUNELE1BQU1JLGlCQUFpQjtBQUN2Qjs7Q0FFQyxHQUNELE1BQU1DLHlCQUF5QjtBQUMvQiw4REFBOEQsR0FDOUQsTUFBTUMsc0JBQXNCO0FBQzVCLG1EQUFtRCxHQUNuRCxNQUFNQyx5QkFBeUI7QUFDL0I7O0NBRUMsR0FDRGYsOEJBQThCLEdBQUcsSUFBSSxLQUFLO0FBQzFDOzs7Ozs7Q0FNQyxHQUNEQSw2QkFBNkIsR0FBRztBQUNoQzs7OztFQUlFLEdBQ0ZBLDhCQUE4QixHQUFHO0FBQ2pDLG9DQUFvQyxHQUNwQyxNQUFNZ0IsNkJBQTZCO0FBQ25DLDhEQUE4RDtBQUM5RCxNQUFNQyxNQUFNVCxtQkFBT0EsQ0FBQztBQUNwQjs7Q0FFQyxHQUNELElBQUlVLGVBQWVWLG1CQUFPQSxDQUFDLHNHQUFj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LGdCQUFnQkMsV0FBVztZQUN6Qyx3Q0FBd0M7WUFDeENYLGFBQWEsSUFBSUMsS0FBS1MsZ0JBQWdCRSxVQUFVLEVBQUVWLE9BQU87WUFDekQ5QyxLQUFLWTtRQUNUO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEaEIsVUFBVTJELFdBQVcsRUFBRTtRQUNuQixNQUFNRSxNQUFNLElBQUlaLE9BQU9DLE9BQU87UUFDOUIsT0FBT1MsWUFBWVgsV0FBVyxHQUN4QmEsT0FBT0YsWUFBWVgsV0FBVyxHQUFHLElBQUksQ0FBQ2MsMkJBQTJCLEdBQ2pFO0lBQ1Y7SUFDQTs7S0FFQyxHQUNEdkIsaUJBQWlCO1FBQ2IsbUVBQW1FO1FBQ25FLGlCQUFpQjtRQUNqQixJQUFJLE9BQU8sSUFBSSxDQUFDNUQsTUFBTSxLQUFLLFVBQVU7WUFDakMsT0FBTztnQkFBQyxJQUFJLENBQUNBLE1BQU07YUFBQztRQUN4QjtRQUNBLE9BQU8sSUFBSSxDQUFDQSxNQUFNLElBQUk7WUFBQzlCO1NBQW9CO0lBQy9DO0lBQ0E4Rix3QkFBd0I7UUFDcEIsTUFBTW9CLGNBQWNDLFFBQVFDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLE1BQU07UUFDbEQsTUFBTUMsa0JBQWtCLElBQUksQ0FBQ2xHLDhCQUE4QixLQUFLd0U7UUFDaEUsTUFBTTJCLHVCQUF1QixJQUFJLENBQUNBLG9CQUFvQixHQUNoRCxJQUFJLENBQUNBLG9CQUFvQixHQUN6QjtRQUNOLE9BQU8sQ0FBQyxRQUFRLEVBQUVMLFlBQVksTUFBTSxFQUFFL0csSUFBSWlILE9BQU8sQ0FBQyx5QkFBeUIsRUFBRUcscUJBQXFCLGtCQUFrQixFQUFFRCxnQkFBZ0IsaUJBQWlCLEVBQUUsSUFBSSxDQUFDbEYsdUJBQXVCLENBQUMsQ0FBQztJQUMzTDtBQUNKO0FBQ0FsRCxpQ0FBaUMsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9iYXNlZXh0ZXJuYWxjbGllbnQuanM/NjA3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50ID0gZXhwb3J0cy5ERUZBVUxUX1VOSVZFUlNFID0gZXhwb3J0cy5DTE9VRF9SRVNPVVJDRV9NQU5BR0VSID0gZXhwb3J0cy5FWFRFUk5BTF9BQ0NPVU5UX1RZUEUgPSBleHBvcnRzLkVYUElSQVRJT05fVElNRV9PRkZTRVQgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aGNsaWVudFwiKTtcbmNvbnN0IHN0cyA9IHJlcXVpcmUoXCIuL3N0c2NyZWRlbnRpYWxzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIFRoZSByZXF1aXJlZCB0b2tlbiBleGNoYW5nZSBncmFudF90eXBlOiByZmM4NjkzI3NlY3Rpb24tMi4xXG4gKi9cbmNvbnN0IFNUU19HUkFOVF9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOnRva2VuLWV4Y2hhbmdlJztcbi8qKlxuICogVGhlIHJlcXVlc3RlZCB0b2tlbiBleGNoYW5nZSByZXF1ZXN0ZWRfdG9rZW5fdHlwZTogcmZjODY5MyNzZWN0aW9uLTIuMVxuICovXG5jb25zdCBTVFNfUkVRVUVTVF9UT0tFTl9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOmFjY2Vzc190b2tlbic7XG4vKiogVGhlIGRlZmF1bHQgT0F1dGggc2NvcGUgdG8gcmVxdWVzdCB3aGVuIG5vbmUgaXMgcHJvdmlkZWQuICovXG5jb25zdCBERUZBVUxUX09BVVRIX1NDT1BFID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0nO1xuLyoqIERlZmF1bHQgaW1wZXJzb25hdGVkIHRva2VuIGxpZmVzcGFuIGluIHNlY29uZHMuKi9cbmNvbnN0IERFRkFVTFRfVE9LRU5fTElGRVNQQU4gPSAzNjAwO1xuLyoqXG4gKiBPZmZzZXQgdG8gdGFrZSBpbnRvIGFjY291bnQgbmV0d29yayBkZWxheXMgYW5kIHNlcnZlciBjbG9jayBza2V3cy5cbiAqL1xuZXhwb3J0cy5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUID0gNSAqIDYwICogMTAwMDtcbi8qKlxuICogVGhlIGNyZWRlbnRpYWxzIEpTT04gZmlsZSB0eXBlIGZvciBleHRlcm5hbCBhY2NvdW50IGNsaWVudHMuXG4gKiBUaGVyZSBhcmUgMyB0eXBlcyBvZiBKU09OIGNvbmZpZ3M6XG4gKiAxLiBhdXRob3JpemVkX3VzZXIgPT4gR29vZ2xlIGVuZCB1c2VyIGNyZWRlbnRpYWxcbiAqIDIuIHNlcnZpY2VfYWNjb3VudCA9PiBHb29nbGUgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxcbiAqIDMuIGV4dGVybmFsX0FjY291bnQgPT4gbm9uLUdDUCBzZXJ2aWNlIChlZy4gQVdTLCBBenVyZSwgSzhzKVxuICovXG5leHBvcnRzLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSA9ICdleHRlcm5hbF9hY2NvdW50Jztcbi8qKlxuICogQ2xvdWQgcmVzb3VyY2UgbWFuYWdlciBVUkwgdXNlZCB0byByZXRyaWV2ZSBwcm9qZWN0IGluZm9ybWF0aW9uLlxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgQmFzZUV4dGVybmFsQWNjb3VudENsaWVudC5jbG91ZFJlc291cmNlTWFuYWdlclVSTH0gaW5zdGVhZFxuICoqL1xuZXhwb3J0cy5DTE9VRF9SRVNPVVJDRV9NQU5BR0VSID0gJ2h0dHBzOi8vY2xvdWRyZXNvdXJjZW1hbmFnZXIuZ29vZ2xlYXBpcy5jb20vdjEvcHJvamVjdHMvJztcbi8qKiBUaGUgd29ya2ZvcmNlIGF1ZGllbmNlIHBhdHRlcm4uICovXG5jb25zdCBXT1JLRk9SQ0VfQVVESUVOQ0VfUEFUVEVSTiA9ICcvL2lhbVxcXFwuZ29vZ2xlYXBpc1xcXFwuY29tL2xvY2F0aW9ucy9bXi9dKy93b3JrZm9yY2VQb29scy9bXi9dKy9wcm92aWRlcnMvLisnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbmNvbnN0IHBrZyA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhY2thZ2UuanNvbicpO1xuLyoqXG4gKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKi9cbnZhciBhdXRoY2xpZW50XzIgPSByZXF1aXJlKFwiLi9hdXRoY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiREVGQVVMVF9VTklWRVJTRVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXV0aGNsaWVudF8yLkRFRkFVTFRfVU5JVkVSU0U7IH0gfSk7XG4vKipcbiAqIEJhc2UgZXh0ZXJuYWwgYWNjb3VudCBjbGllbnQuIFRoaXMgaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBBdXRoQ2xpZW50cyBmb3JcbiAqIGV4Y2hhbmdpbmcgZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFscyBmb3IgR0NQIGFjY2VzcyB0b2tlbiBhbmQgYXV0aG9yaXppbmdcbiAqIHJlcXVlc3RzIHRvIEdDUCBBUElzLlxuICogVGhlIGJhc2UgY2xhc3MgaW1wbGVtZW50cyBjb21tb24gbG9naWMgZm9yIGV4Y2hhbmdpbmcgdmFyaW91cyB0eXBlIG9mXG4gKiBleHRlcm5hbCBjcmVkZW50aWFscyBmb3IgR0NQIGFjY2VzcyB0b2tlbi4gVGhlIGxvZ2ljIG9mIGRldGVybWluaW5nIGFuZFxuICogcmV0cmlldmluZyB0aGUgZXh0ZXJuYWwgY3JlZGVudGlhbCBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQgYW5kXG4gKiBjcmVkZW50aWFsX3NvdXJjZSB3aWxsIGJlIGxlZnQgZm9yIHRoZSBzdWJjbGFzc2VzLlxuICovXG5jbGFzcyBCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IGV4dGVuZHMgYXV0aGNsaWVudF8xLkF1dGhDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCBpbnN0YW5jZSB1c2luZyB0aGUgcHJvdmlkZWQgSlNPTlxuICAgICAqIG9iamVjdCBsb2FkZWQgZnJvbSBhbiBleHRlcm5hbCBhY2NvdW50IGNyZWRlbnRpYWxzIGZpbGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGV4dGVybmFsIGFjY291bnQgb3B0aW9ucyBvYmplY3QgdHlwaWNhbGx5IGxvYWRlZFxuICAgICAqICAgZnJvbSB0aGUgZXh0ZXJuYWwgYWNjb3VudCBKU09OIGNyZWRlbnRpYWwgZmlsZS4gVGhlIGNhbWVsQ2FzZWQgb3B0aW9uc1xuICAgICAqICAgYXJlIGFsaWFzZXMgZm9yIHRoZSBzbmFrZV9jYXNlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9ucyAqKkRFUFJFQ0FURUQsIGFsbCBvcHRpb25zIGFyZSBhdmFpbGFibGUgaW4gdGhlXG4gICAgICogICBgb3B0aW9uc2AgcGFyYW1ldGVyLioqIE9wdGlvbmFsIGFkZGl0aW9uYWwgYmVoYXZpb3IgY3VzdG9taXphdGlvbiBvcHRpb25zLlxuICAgICAqICAgVGhlc2UgY3VycmVudGx5IGN1c3RvbWl6ZSBleHBpcmF0aW9uIHRocmVzaG9sZCB0aW1lIGFuZCB3aGV0aGVyIHRvIHJldHJ5XG4gICAgICogICBvbiA0MDEvNDAzIEFQSSByZXF1ZXN0IGVycm9ycy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICBzdXBlcih7IC4uLm9wdGlvbnMsIC4uLmFkZGl0aW9uYWxPcHRpb25zIH0pO1xuICAgICAgICBjb25zdCBvcHRzID0gKDAsIHV0aWxfMS5vcmlnaW5hbE9yQ2FtZWxPcHRpb25zKShvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdHMuZ2V0KCd0eXBlJykgIT09IGV4cG9ydHMuRVhURVJOQUxfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFwiJHtleHBvcnRzLkVYVEVSTkFMX0FDQ09VTlRfVFlQRX1cIiB0eXBlIGJ1dCBgICtcbiAgICAgICAgICAgICAgICBgcmVjZWl2ZWQgXCIke29wdGlvbnMudHlwZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudElkID0gb3B0cy5nZXQoJ2NsaWVudF9pZCcpO1xuICAgICAgICBjb25zdCBjbGllbnRTZWNyZXQgPSBvcHRzLmdldCgnY2xpZW50X3NlY3JldCcpO1xuICAgICAgICBjb25zdCB0b2tlblVybCA9IG9wdHMuZ2V0KCd0b2tlbl91cmwnKTtcbiAgICAgICAgY29uc3Qgc3ViamVjdFRva2VuVHlwZSA9IG9wdHMuZ2V0KCdzdWJqZWN0X3Rva2VuX3R5cGUnKTtcbiAgICAgICAgY29uc3Qgd29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0ID0gb3B0cy5nZXQoJ3dvcmtmb3JjZV9wb29sX3VzZXJfcHJvamVjdCcpO1xuICAgICAgICBjb25zdCBzZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwgPSBvcHRzLmdldCgnc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsJyk7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvbiA9IG9wdHMuZ2V0KCdzZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbicpO1xuICAgICAgICBjb25zdCBzZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25MaWZldGltZSA9ICgwLCB1dGlsXzEub3JpZ2luYWxPckNhbWVsT3B0aW9ucykoc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uKS5nZXQoJ3Rva2VuX2xpZmV0aW1lX3NlY29uZHMnKTtcbiAgICAgICAgdGhpcy5jbG91ZFJlc291cmNlTWFuYWdlclVSTCA9IG5ldyBVUkwob3B0cy5nZXQoJ2Nsb3VkX3Jlc291cmNlX21hbmFnZXJfdXJsJykgfHxcbiAgICAgICAgICAgIGBodHRwczovL2Nsb3VkcmVzb3VyY2VtYW5hZ2VyLiR7dGhpcy51bml2ZXJzZURvbWFpbn0vdjEvcHJvamVjdHMvYCk7XG4gICAgICAgIGlmIChjbGllbnRJZCkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnRBdXRoID0ge1xuICAgICAgICAgICAgICAgIGNvbmZpZGVudGlhbENsaWVudFR5cGU6ICdiYXNpYycsXG4gICAgICAgICAgICAgICAgY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgY2xpZW50U2VjcmV0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0c0NyZWRlbnRpYWwgPSBuZXcgc3RzLlN0c0NyZWRlbnRpYWxzKHRva2VuVXJsLCB0aGlzLmNsaWVudEF1dGgpO1xuICAgICAgICB0aGlzLnNjb3BlcyA9IG9wdHMuZ2V0KCdzY29wZXMnKSB8fCBbREVGQVVMVF9PQVVUSF9TQ09QRV07XG4gICAgICAgIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmF1ZGllbmNlID0gb3B0cy5nZXQoJ2F1ZGllbmNlJyk7XG4gICAgICAgIHRoaXMuc3ViamVjdFRva2VuVHlwZSA9IHN1YmplY3RUb2tlblR5cGU7XG4gICAgICAgIHRoaXMud29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0ID0gd29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0O1xuICAgICAgICBjb25zdCB3b3JrZm9yY2VBdWRpZW5jZVBhdHRlcm4gPSBuZXcgUmVnRXhwKFdPUktGT1JDRV9BVURJRU5DRV9QQVRURVJOKTtcbiAgICAgICAgaWYgKHRoaXMud29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0ICYmXG4gICAgICAgICAgICAhdGhpcy5hdWRpZW5jZS5tYXRjaCh3b3JrZm9yY2VBdWRpZW5jZVBhdHRlcm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvcmtmb3JjZVBvb2xVc2VyUHJvamVjdCBzaG91bGQgbm90IGJlIHNldCBmb3Igbm9uLXdvcmtmb3JjZSBwb29sICcgK1xuICAgICAgICAgICAgICAgICdjcmVkZW50aWFscy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybCA9IHNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybDtcbiAgICAgICAgdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25MaWZldGltZSA9XG4gICAgICAgICAgICBzZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25MaWZldGltZTtcbiAgICAgICAgaWYgKHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uTGlmZXRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnTGlmZXRpbWVSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25maWdMaWZldGltZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25MaWZldGltZSA9IERFRkFVTFRfVE9LRU5fTElGRVNQQU47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9qZWN0TnVtYmVyID0gdGhpcy5nZXRQcm9qZWN0TnVtYmVyKHRoaXMuYXVkaWVuY2UpO1xuICAgIH1cbiAgICAvKiogVGhlIHNlcnZpY2UgYWNjb3VudCBlbWFpbCB0byBiZSBpbXBlcnNvbmF0ZWQsIGlmIGF2YWlsYWJsZS4gKi9cbiAgICBnZXRTZXJ2aWNlQWNjb3VudEVtYWlsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsLmxlbmd0aCA+IDI1Nikge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFByZXZlbnRzIERPUyBhdHRhY2tzLlxuICAgICAgICAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL2dvb2dsZS1hdXRoLWxpYnJhcnktbm9kZWpzL3NlY3VyaXR5L2NvZGUtc2Nhbm5pbmcvODR9XG4gICAgICAgICAgICAgICAgICoqL1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVUkwgaXMgdG9vIGxvbmc6ICR7dGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25Vcmx9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBlbWFpbCBmcm9tIFVSTC4gVGhlIGZvcm1hbCBsb29rcyBhcyBmb2xsb3dzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9pYW1jcmVkZW50aWFscy5nb29nbGVhcGlzLmNvbS92MS9wcm9qZWN0cy8tL3NlcnZpY2VBY2NvdW50cy9uYW1lQHByb2plY3QtaWQuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb206Z2VuZXJhdGVBY2Nlc3NUb2tlblxuICAgICAgICAgICAgY29uc3QgcmUgPSAvc2VydmljZUFjY291bnRzXFwvKD88ZW1haWw+W146XSspOmdlbmVyYXRlQWNjZXNzVG9rZW4kLztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlLmV4ZWModGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwpO1xuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZ3JvdXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1haWwpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIGluamVjdCBHQ1AgYWNjZXNzIHRva2VucyBkaXJlY3RseS5cbiAgICAgKiBXaGVuIHRoZSBwcm92aWRlZCBjcmVkZW50aWFsIGV4cGlyZXMsIGEgbmV3IGNyZWRlbnRpYWwsIHVzaW5nIHRoZVxuICAgICAqIGV4dGVybmFsIGFjY291bnQgb3B0aW9ucywgaXMgcmV0cmlldmVkLlxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgQ3JlZGVudGlhbHMgb2JqZWN0IHRvIHNldCBvbiB0aGUgY3VycmVudCBjbGllbnQuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgc3VwZXIuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0gY3JlZGVudGlhbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY3VycmVudCBHQ1AgYWNjZXNzIHRva2VuXG4gICAgICogICByZXNwb25zZS4gSWYgdGhlIGN1cnJlbnQgY3JlZGVudGlhbCBpcyBleHBpcmVkLCBhIG5ldyBvbmUgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICAvLyBJZiBjYWNoZWQgYWNjZXNzIHRva2VuIGlzIHVuYXZhaWxhYmxlIG9yIGV4cGlyZWQsIGZvcmNlIHJlZnJlc2guXG4gICAgICAgIGlmICghdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiB8fCB0aGlzLmlzRXhwaXJlZCh0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBHQ1AgYWNjZXNzIHRva2VuIGluIEdldEFjY2Vzc1Rva2VuUmVzcG9uc2UgZm9ybWF0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW46IHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgcmVzOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLnJlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gYXV0aGVudGljYXRpb24gaW50ZXJmYWNlLiBJdCB0YWtlcyBhbiBvcHRpb25hbCB1cmwgd2hpY2ggd2hlblxuICAgICAqIHByZXNlbnQgaXMgdGhlIGVuZHBvaW50IGJlaW5nIGFjY2Vzc2VkLCBhbmQgcmV0dXJucyBhIFByb21pc2Ugd2hpY2hcbiAgICAgKiByZXNvbHZlcyB3aXRoIGF1dGhvcml6YXRpb24gaGVhZGVyIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHQgaGFzIHRoZSBmb3JtOlxuICAgICAqIHsgQXV0aG9yaXphdGlvbjogJ0JlYXJlciA8YWNjZXNzX3Rva2VuX3ZhbHVlPicgfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlcXVlc3RIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VuUmVzcG9uc2UudG9rZW59YCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH1cbiAgICByZXF1ZXN0KG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSwgZS5yZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHByb2plY3QgSUQgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgKiAgIGN1cnJlbnQgd29ya2xvYWQgaWRlbnRpdHkgcG9vbCBvciBjdXJyZW50IHdvcmtmb3JjZSBwb29sIGlmXG4gICAgICogICBkZXRlcm1pbmFibGUuIEZvciB3b3JrZm9yY2UgcG9vbCBjcmVkZW50aWFsLCBpdCByZXR1cm5zIHRoZSBwcm9qZWN0IElEXG4gICAgICogICBjb3JyZXNwb25kaW5nIHRvIHRoZSB3b3JrZm9yY2VQb29sVXNlclByb2plY3QuXG4gICAgICogICBUaGlzIGlzIGludHJvZHVjZWQgdG8gbWF0Y2ggdGhlIGN1cnJlbnQgcGF0dGVybiBvZiB1c2luZyB0aGUgQXV0aFxuICAgICAqICAgbGlicmFyeTpcbiAgICAgKiAgIGNvbnN0IHByb2plY3RJZCA9IGF3YWl0IGF1dGguZ2V0UHJvamVjdElkKCk7XG4gICAgICogICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9kbnMuZ29vZ2xlYXBpcy5jb20vZG5zL3YxL3Byb2plY3RzLyR7cHJvamVjdElkfWA7XG4gICAgICogICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCB9KTtcbiAgICAgKiAgIFRoZSByZXNvdXJjZSBtYXkgbm90IGhhdmUgcGVybWlzc2lvblxuICAgICAqICAgKHJlc291cmNlbWFuYWdlci5wcm9qZWN0cy5nZXQpIHRvIGNhbGwgdGhpcyBBUEkgb3IgdGhlIHJlcXVpcmVkXG4gICAgICogICBzY29wZXMgbWF5IG5vdCBiZSBzZWxlY3RlZDpcbiAgICAgKiAgIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9yZXNvdXJjZS1tYW5hZ2VyL3JlZmVyZW5jZS9yZXN0L3YxL3Byb2plY3RzL2dldCNhdXRob3JpemF0aW9uLXNjb3Blc1xuICAgICAqL1xuICAgIGFzeW5jIGdldFByb2plY3RJZCgpIHtcbiAgICAgICAgY29uc3QgcHJvamVjdE51bWJlciA9IHRoaXMucHJvamVjdE51bWJlciB8fCB0aGlzLndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdDtcbiAgICAgICAgaWYgKHRoaXMucHJvamVjdElkKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gcHJldmlvdXNseSBkZXRlcm1pbmVkIHByb2plY3QgSUQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdE51bWJlcikge1xuICAgICAgICAgICAgLy8gUHJlZmVyYWJsZSBub3QgdG8gdXNlIHJlcXVlc3QoKSB0byBhdm9pZCByZXRyaWFsIHBvbGljaWVzLlxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHVybDogYCR7dGhpcy5jbG91ZFJlc291cmNlTWFuYWdlclVSTC50b1N0cmluZygpfSR7cHJvamVjdE51bWJlcn1gLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByb2plY3RJZCA9IHJlc3BvbnNlLmRhdGEucHJvamVjdElkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdXRoZW50aWNhdGVzIHRoZSBwcm92aWRlZCBIVFRQIHJlcXVlc3QsIHByb2Nlc3NlcyBpdCBhbmQgcmVzb2x2ZXMgd2l0aCB0aGVcbiAgICAgKiByZXR1cm5lZCByZXNwb25zZS5cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgSFRUUCByZXF1ZXN0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHJldHJ5IFdoZXRoZXIgdGhlIGN1cnJlbnQgYXR0ZW1wdCBpcyBhIHJldHJ5IGFmdGVyIGEgZmFpbGVkIGF0dGVtcHQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3RBc3luYyhvcHRzLCByZXRyeSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSA9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdEhlYWRlcnMgJiYgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbikge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBlLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIFJldHJ5IHRoZSByZXF1ZXN0IGZvciBtZXRhZGF0YSBpZiB0aGUgZm9sbG93aW5nIGNyaXRlcmlhIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgIC8vIC0gV2UgaGF2ZW4ndCBhbHJlYWR5IHJldHJpZWQuICBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVzcG9uc2Ugd2FzIGEgNDAxIG9yIGEgNDAzXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVxdWVzdCBkaWRuJ3Qgc2VuZCBhIHJlYWRhYmxlU3RyZWFtXG4gICAgICAgICAgICAgICAgLy8gLSBmb3JjZVJlZnJlc2hPbkZhaWx1cmUgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSByZXMuY29uZmlnLmRhdGEgaW5zdGFuY2VvZiBzdHJlYW0uUmVhZGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdXRoRXJyID0gc3RhdHVzQ29kZSA9PT0gNDAxIHx8IHN0YXR1c0NvZGUgPT09IDQwMztcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0aEVyciAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNSZWFkYWJsZVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3RBc3luYyhvcHRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRva2VuIHJlZnJlc2gsIGV2ZW4gaWYgdW5leHBpcmVkIHRva2VucyBhcmUgY3VycmVudGx5IGNhY2hlZC5cbiAgICAgKiBFeHRlcm5hbCBjcmVkZW50aWFscyBhcmUgZXhjaGFuZ2VkIGZvciBHQ1AgYWNjZXNzIHRva2VucyB2aWEgdGhlIHRva2VuXG4gICAgICogZXhjaGFuZ2UgZW5kcG9pbnQgYW5kIG90aGVyIHNldHRpbmdzIHByb3ZpZGVkIGluIHRoZSBjbGllbnQgb3B0aW9uc1xuICAgICAqIG9iamVjdC5cbiAgICAgKiBJZiB0aGUgc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsIGlzIHByb3ZpZGVkLCBhbiBhZGRpdGlvbmFsXG4gICAgICogc3RlcCB0byBleGNoYW5nZSB0aGUgZXh0ZXJuYWwgYWNjb3VudCBHQ1AgYWNjZXNzIHRva2VuIGZvciBhIHNlcnZpY2VcbiAgICAgKiBhY2NvdW50IGltcGVyc29uYXRlZCB0b2tlbiBpcyBwZXJmb3JtZWQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBmcmVzaCBHQ1AgYWNjZXNzIHRva2Vucy5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpIHtcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGV4dGVybmFsIGNyZWRlbnRpYWwuXG4gICAgICAgIGNvbnN0IHN1YmplY3RUb2tlbiA9IGF3YWl0IHRoaXMucmV0cmlldmVTdWJqZWN0VG9rZW4oKTtcbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBTVFMgY3JlZGVudGlhbHMgb3B0aW9ucy5cbiAgICAgICAgY29uc3Qgc3RzQ3JlZGVudGlhbHNPcHRpb25zID0ge1xuICAgICAgICAgICAgZ3JhbnRUeXBlOiBTVFNfR1JBTlRfVFlQRSxcbiAgICAgICAgICAgIGF1ZGllbmNlOiB0aGlzLmF1ZGllbmNlLFxuICAgICAgICAgICAgcmVxdWVzdGVkVG9rZW5UeXBlOiBTVFNfUkVRVUVTVF9UT0tFTl9UWVBFLFxuICAgICAgICAgICAgc3ViamVjdFRva2VuLFxuICAgICAgICAgICAgc3ViamVjdFRva2VuVHlwZTogdGhpcy5zdWJqZWN0VG9rZW5UeXBlLFxuICAgICAgICAgICAgLy8gZ2VuZXJhdGVBY2Nlc3NUb2tlbiByZXF1aXJlcyB0aGUgcHJvdmlkZWQgYWNjZXNzIHRva2VuIHRvIGhhdmVcbiAgICAgICAgICAgIC8vIHNjb3BlczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvaWFtIG9yXG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtXG4gICAgICAgICAgICAvLyBUaGUgbmV3IHNlcnZpY2UgYWNjb3VudCBhY2Nlc3MgdG9rZW4gc2NvcGVzIHdpbGwgbWF0Y2ggdGhlIHVzZXJcbiAgICAgICAgICAgIC8vIHByb3ZpZGVkIG9uZXMuXG4gICAgICAgICAgICBzY29wZTogdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmxcbiAgICAgICAgICAgICAgICA/IFtERUZBVUxUX09BVVRIX1NDT1BFXVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRTY29wZXNBcnJheSgpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBFeGNoYW5nZSB0aGUgZXh0ZXJuYWwgY3JlZGVudGlhbHMgZm9yIGEgR0NQIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgLy8gQ2xpZW50IGF1dGggaXMgcHJpb3JpdGl6ZWQgb3ZlciBwYXNzaW5nIHRoZSB3b3JrZm9yY2VQb29sVXNlclByb2plY3RcbiAgICAgICAgLy8gcGFyYW1ldGVyIGZvciBTVFMgdG9rZW4gZXhjaGFuZ2UuXG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxPcHRpb25zID0gIXRoaXMuY2xpZW50QXV0aCAmJiB0aGlzLndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdFxuICAgICAgICAgICAgPyB7IHVzZXJQcm9qZWN0OiB0aGlzLndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdCB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbEhlYWRlcnMgPSB7XG4gICAgICAgICAgICAneC1nb29nLWFwaS1jbGllbnQnOiB0aGlzLmdldE1ldHJpY3NIZWFkZXJWYWx1ZSgpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdHNSZXNwb25zZSA9IGF3YWl0IHRoaXMuc3RzQ3JlZGVudGlhbC5leGNoYW5nZVRva2VuKHN0c0NyZWRlbnRpYWxzT3B0aW9ucywgYWRkaXRpb25hbEhlYWRlcnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5nZXRJbXBlcnNvbmF0ZWRBY2Nlc3NUb2tlbihzdHNSZXNwb25zZS5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0c1Jlc3BvbnNlLmV4cGlyZXNfaW4pIHtcbiAgICAgICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgaW4gY2FjaGVkIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBzdHNSZXNwb25zZS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgc3RzUmVzcG9uc2UuZXhwaXJlc19pbiAqIDEwMDAsXG4gICAgICAgICAgICAgICAgcmVzOiBzdHNSZXNwb25zZS5yZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2F2ZSByZXNwb25zZSBpbiBjYWNoZWQgYWNjZXNzIHRva2VuLlxuICAgICAgICAgICAgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiA9IHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHN0c1Jlc3BvbnNlLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICByZXM6IHN0c1Jlc3BvbnNlLnJlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2F2ZSBjcmVkZW50aWFscy5cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4pO1xuICAgICAgICBkZWxldGUgdGhpcy5jcmVkZW50aWFscy5yZXM7XG4gICAgICAgIC8vIFRyaWdnZXIgdG9rZW5zIGV2ZW50IHRvIG5vdGlmeSBleHRlcm5hbCBsaXN0ZW5lcnMuXG4gICAgICAgIHRoaXMuZW1pdCgndG9rZW5zJywge1xuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogbnVsbCxcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlLFxuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIHRva2VuX3R5cGU6ICdCZWFyZXInLFxuICAgICAgICAgICAgaWRfdG9rZW46IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGNhY2hlZCBhY2Nlc3MgdG9rZW4uXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3b3JrbG9hZCBpZGVudGl0eSBwb29sIHByb2plY3QgbnVtYmVyIGlmIGl0IGlzIGRldGVybWluYWJsZVxuICAgICAqIGZyb20gdGhlIGF1ZGllbmNlIHJlc291cmNlIG5hbWUuXG4gICAgICogQHBhcmFtIGF1ZGllbmNlIFRoZSBTVFMgYXVkaWVuY2UgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHByb2plY3QgbnVtYmVyLlxuICAgICAqIEByZXR1cm4gVGhlIHByb2plY3QgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgd29ya2xvYWQgaWRlbnRpdHkgcG9vbCwgaWZcbiAgICAgKiAgIHRoaXMgY2FuIGJlIGRldGVybWluZWQgZnJvbSB0aGUgU1RTIGF1ZGllbmNlIGZpZWxkLiBPdGhlcndpc2UsIG51bGwgaXNcbiAgICAgKiAgIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldFByb2plY3ROdW1iZXIoYXVkaWVuY2UpIHtcbiAgICAgICAgLy8gU1RTIGF1ZGllbmNlIHBhdHRlcm46XG4gICAgICAgIC8vIC8vaWFtLmdvb2dsZWFwaXMuY29tL3Byb2plY3RzLyRQUk9KRUNUX05VTUJFUi9sb2NhdGlvbnMvLi4uXG4gICAgICAgIGNvbnN0IG1hdGNoID0gYXVkaWVuY2UubWF0Y2goL1xcL3Byb2plY3RzXFwvKFteL10rKS8pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2hhbmdlcyBhbiBleHRlcm5hbCBhY2NvdW50IEdDUCBhY2Nlc3MgdG9rZW4gZm9yIGEgc2VydmljZVxuICAgICAqIGFjY291bnQgaW1wZXJzb25hdGVkIGFjY2VzcyB0b2tlbiB1c2luZyBpYW1jcmVkZW50aWFsc1xuICAgICAqIEdlbmVyYXRlQWNjZXNzVG9rZW4gQVBJLlxuICAgICAqIEBwYXJhbSB0b2tlbiBUaGUgYWNjZXNzIHRva2VuIHRvIGV4Y2hhbmdlIGZvciBhIHNlcnZpY2UgYWNjb3VudCBhY2Nlc3NcbiAgICAgKiAgIHRva2VuLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc2VydmljZSBhY2NvdW50IGltcGVyc29uYXRlZFxuICAgICAqICAgY3JlZGVudGlhbHMgcmVzcG9uc2UuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SW1wZXJzb25hdGVkQWNjZXNzVG9rZW4odG9rZW4pIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIHVybDogdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBzY29wZTogdGhpcy5nZXRTY29wZXNBcnJheSgpLFxuICAgICAgICAgICAgICAgIGxpZmV0aW1lOiB0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvbkxpZmV0aW1lICsgJ3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1Jlc3BvbnNlID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogc3VjY2Vzc1Jlc3BvbnNlLmFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgLy8gQ29udmVydCBmcm9tIElTTyBmb3JtYXQgdG8gdGltZXN0YW1wLlxuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IG5ldyBEYXRlKHN1Y2Nlc3NSZXNwb25zZS5leHBpcmVUaW1lKS5nZXRUaW1lKCksXG4gICAgICAgICAgICByZXM6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGNyZWRlbnRpYWxzIGFyZSBleHBpcmVkIG9yIG5vdC5cbiAgICAgKiBJZiB0aGVyZSBpcyBubyBleHBpcnkgdGltZSwgYXNzdW1lcyB0aGUgdG9rZW4gaXMgbm90IGV4cGlyZWQgb3IgZXhwaXJpbmcuXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIFRoZSBjcmVkZW50aWFscyB0byBjaGVjayBmb3IgZXhwaXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhlIGNyZWRlbnRpYWxzIGFyZSBleHBpcmVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBpc0V4cGlyZWQoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHJldHVybiBhY2Nlc3NUb2tlbi5leHBpcnlfZGF0ZVxuICAgICAgICAgICAgPyBub3cgPj0gYWNjZXNzVG9rZW4uZXhwaXJ5X2RhdGUgLSB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpc1xuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgbGlzdCBvZiBzY29wZXMgZm9yIHRoZSByZXF1ZXN0ZWQgR0NQIGFjY2VzcyB0b2tlbi5cbiAgICAgKi9cbiAgICBnZXRTY29wZXNBcnJheSgpIHtcbiAgICAgICAgLy8gU2luY2Ugc2NvcGVzIGNhbiBiZSBwcm92aWRlZCBhcyBzdHJpbmcgb3IgYXJyYXksIHRoZSB0eXBlIHNob3VsZFxuICAgICAgICAvLyBiZSBub3JtYWxpemVkLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2NvcGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnNjb3Blc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVzIHx8IFtERUZBVUxUX09BVVRIX1NDT1BFXTtcbiAgICB9XG4gICAgZ2V0TWV0cmljc0hlYWRlclZhbHVlKCkge1xuICAgICAgICBjb25zdCBub2RlVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbi5yZXBsYWNlKC9edi8sICcnKTtcbiAgICAgICAgY29uc3Qgc2FJbXBlcnNvbmF0aW9uID0gdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbFNvdXJjZVR5cGUgPSB0aGlzLmNyZWRlbnRpYWxTb3VyY2VUeXBlXG4gICAgICAgICAgICA/IHRoaXMuY3JlZGVudGlhbFNvdXJjZVR5cGVcbiAgICAgICAgICAgIDogJ3Vua25vd24nO1xuICAgICAgICByZXR1cm4gYGdsLW5vZGUvJHtub2RlVmVyc2lvbn0gYXV0aC8ke3BrZy52ZXJzaW9ufSBnb29nbGUtYnlvaWQtc2RrIHNvdXJjZS8ke2NyZWRlbnRpYWxTb3VyY2VUeXBlfSBzYS1pbXBlcnNvbmF0aW9uLyR7c2FJbXBlcnNvbmF0aW9ufSBjb25maWctbGlmZXRpbWUvJHt0aGlzLmNvbmZpZ0xpZmV0aW1lUmVxdWVzdGVkfWA7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50ID0gQmFzZUV4dGVybmFsQWNjb3VudENsaWVudDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQiLCJERUZBVUxUX1VOSVZFUlNFIiwiQ0xPVURfUkVTT1VSQ0VfTUFOQUdFUiIsIkVYVEVSTkFMX0FDQ09VTlRfVFlQRSIsIkVYUElSQVRJT05fVElNRV9PRkZTRVQiLCJzdHJlYW0iLCJyZXF1aXJlIiwiYXV0aGNsaWVudF8xIiwic3RzIiwidXRpbF8xIiwiU1RTX0dSQU5UX1RZUEUiLCJTVFNfUkVRVUVTVF9UT0tFTl9UWVBFIiwiREVGQVVMVF9PQVVUSF9TQ09QRSIsIkRFRkFVTFRfVE9LRU5fTElGRVNQQU4iLCJXT1JLRk9SQ0VfQVVESUVOQ0VfUEFUVEVSTiIsInBrZyIsImF1dGhjbGllbnRfMiIsImVudW1lcmFibGUiLCJnZXQiLCJBdXRoQ2xpZW50IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJvcHRzIiwib3JpZ2luYWxPckNhbWVsT3B0aW9ucyIsIkVycm9yIiwidHlwZSIsImNsaWVudElkIiwiY2xpZW50U2VjcmV0IiwidG9rZW5VcmwiLCJzdWJqZWN0VG9rZW5UeXBlIiwid29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0Iiwic2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsIiwic2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uIiwic2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uTGlmZXRpbWUiLCJjbG91ZFJlc291cmNlTWFuYWdlclVSTCIsIlVSTCIsInVuaXZlcnNlRG9tYWluIiwiY2xpZW50QXV0aCIsImNvbmZpZGVudGlhbENsaWVudFR5cGUiLCJzdHNDcmVkZW50aWFsIiwiU3RzQ3JlZGVudGlhbHMiLCJzY29wZXMiLCJjYWNoZWRBY2Nlc3NUb2tlbiIsImF1ZGllbmNlIiwid29ya2ZvcmNlQXVkaWVuY2VQYXR0ZXJuIiwiUmVnRXhwIiwibWF0Y2giLCJjb25maWdMaWZldGltZVJlcXVlc3RlZCIsInByb2plY3ROdW1iZXIiLCJnZXRQcm9qZWN0TnVtYmVyIiwiZ2V0U2VydmljZUFjY291bnRFbWFpbCIsIl9hIiwibGVuZ3RoIiwiUmFuZ2VFcnJvciIsInJlIiwicmVzdWx0IiwiZXhlYyIsImdyb3VwcyIsImVtYWlsIiwic2V0Q3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsImdldEFjY2Vzc1Rva2VuIiwiaXNFeHBpcmVkIiwicmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMiLCJ0b2tlbiIsImFjY2Vzc190b2tlbiIsInJlcyIsImdldFJlcXVlc3RIZWFkZXJzIiwiYWNjZXNzVG9rZW5SZXNwb25zZSIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwiYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzIiwicmVxdWVzdCIsImNhbGxiYWNrIiwicmVxdWVzdEFzeW5jIiwidGhlbiIsInIiLCJlIiwicmVzcG9uc2UiLCJnZXRQcm9qZWN0SWQiLCJwcm9qZWN0SWQiLCJ0cmFuc3BvcnRlciIsInVybCIsInRvU3RyaW5nIiwicmVzcG9uc2VUeXBlIiwiZGF0YSIsInJldHJ5IiwicmVxdWVzdEhlYWRlcnMiLCJzdGF0dXNDb2RlIiwic3RhdHVzIiwiaXNSZWFkYWJsZVN0cmVhbSIsImNvbmZpZyIsIlJlYWRhYmxlIiwiaXNBdXRoRXJyIiwiZm9yY2VSZWZyZXNoT25GYWlsdXJlIiwic3ViamVjdFRva2VuIiwicmV0cmlldmVTdWJqZWN0VG9rZW4iLCJzdHNDcmVkZW50aWFsc09wdGlvbnMiLCJncmFudFR5cGUiLCJyZXF1ZXN0ZWRUb2tlblR5cGUiLCJzY29wZSIsImdldFNjb3Blc0FycmF5IiwidXNlclByb2plY3QiLCJ1bmRlZmluZWQiLCJhZGRpdGlvbmFsSGVhZGVycyIsImdldE1ldHJpY3NIZWFkZXJWYWx1ZSIsInN0c1Jlc3BvbnNlIiwiZXhjaGFuZ2VUb2tlbiIsImdldEltcGVyc29uYXRlZEFjY2Vzc1Rva2VuIiwiZXhwaXJlc19pbiIsImV4cGlyeV9kYXRlIiwiRGF0ZSIsImdldFRpbWUiLCJhc3NpZ24iLCJlbWl0IiwicmVmcmVzaF90b2tlbiIsInRva2VuX3R5cGUiLCJpZF90b2tlbiIsIm1ldGhvZCIsImxpZmV0aW1lIiwic3VjY2Vzc1Jlc3BvbnNlIiwiYWNjZXNzVG9rZW4iLCJleHBpcmVUaW1lIiwibm93IiwiZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIiwibm9kZVZlcnNpb24iLCJwcm9jZXNzIiwidmVyc2lvbiIsInJlcGxhY2UiLCJzYUltcGVyc29uYXRpb24iLCJjcmVkZW50aWFsU291cmNlVHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/computeclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/computeclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Compute = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(action-browser)/./node_modules/gaxios/build/src/index.js\");\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(action-browser)/./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/index.js\");\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass Compute extends oauth2client_1.OAuth2Client {\n    /**\n     * Google Compute Engine service account credentials.\n     *\n     * Retrieve access token from the metadata server.\n     * See: https://cloud.google.com/compute/docs/access/authenticate-workloads#applications\n     */ constructor(options = {}){\n        super(options);\n        // Start with an expired refresh token, which will automatically be\n        // refreshed before the first API call is made.\n        this.credentials = {\n            expiry_date: 1,\n            refresh_token: \"compute-placeholder\"\n        };\n        this.serviceAccountEmail = options.serviceAccountEmail || \"default\";\n        this.scopes = Array.isArray(options.scopes) ? options.scopes : options.scopes ? [\n            options.scopes\n        ] : [];\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken Unused parameter\n     */ async refreshTokenNoCache(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;\n        let data;\n        try {\n            const instanceOptions = {\n                property: tokenPath\n            };\n            if (this.scopes.length > 0) {\n                instanceOptions.params = {\n                    scopes: this.scopes.join(\",\")\n                };\n            }\n            data = await gcpMetadata.instance(instanceOptions);\n        } catch (e) {\n            if (e instanceof gaxios_1.GaxiosError) {\n                e.message = `Could not refresh access token: ${e.message}`;\n                this.wrapError(e);\n            }\n            throw e;\n        }\n        const tokens = data;\n        if (data && data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit(\"tokens\", tokens);\n        return {\n            tokens,\n            res: null\n        };\n    }\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */ async fetchIdToken(targetAudience) {\n        const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity` + `?format=full&audience=${targetAudience}`;\n        let idToken;\n        try {\n            const instanceOptions = {\n                property: idTokenPath\n            };\n            idToken = await gcpMetadata.instance(instanceOptions);\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Could not fetch ID token: ${e.message}`;\n            }\n            throw e;\n        }\n        return idToken;\n    }\n    wrapError(e) {\n        const res = e.response;\n        if (res && res.status) {\n            e.status = res.status;\n            if (res.status === 403) {\n                e.message = \"A Forbidden error was returned while attempting to retrieve an access \" + \"token for the Compute Engine built-in service account. This may be because the Compute \" + \"Engine instance does not have the correct permission scopes specified: \" + e.message;\n            } else if (res.status === 404) {\n                e.message = \"A Not Found error was returned while attempting to retrieve an access\" + \"token for the Compute Engine built-in service account. This may be because the Compute \" + \"Engine instance does not have any permission scopes specified: \" + e.message;\n            }\n        }\n    }\n}\nexports.Compute = Compute;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2NvbXB1dGVjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUcsS0FBSztBQUN2QixNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyx5RUFBUTtBQUNqQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxzSEFBYztBQUMxQyxNQUFNRSxpQkFBaUJGLG1CQUFPQSxDQUFDLDBHQUFnQjtBQUMvQyxNQUFNRixnQkFBZ0JJLGVBQWVDLFlBQVk7SUFDN0M7Ozs7O0tBS0MsR0FDREMsWUFBWUMsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUN0QixLQUFLLENBQUNBO1FBQ04sbUVBQW1FO1FBQ25FLCtDQUErQztRQUMvQyxJQUFJLENBQUNDLFdBQVcsR0FBRztZQUFFQyxhQUFhO1lBQUdDLGVBQWU7UUFBc0I7UUFDMUUsSUFBSSxDQUFDQyxtQkFBbUIsR0FBR0osUUFBUUksbUJBQW1CLElBQUk7UUFDMUQsSUFBSSxDQUFDQyxNQUFNLEdBQUdDLE1BQU1DLE9BQU8sQ0FBQ1AsUUFBUUssTUFBTSxJQUNwQ0wsUUFBUUssTUFBTSxHQUNkTCxRQUFRSyxNQUFNLEdBQ1Y7WUFBQ0wsUUFBUUssTUFBTTtTQUFDLEdBQ2hCLEVBQUU7SUFDaEI7SUFDQTs7O0tBR0MsR0FDRCxNQUFNRyxvQkFDTiw2REFBNkQ7SUFDN0RDLFlBQVksRUFBRTtRQUNWLE1BQU1DLFlBQVksQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUNOLG1CQUFtQixDQUFDLE1BQU0sQ0FBQztRQUN0RSxJQUFJTztRQUNKLElBQUk7WUFDQSxNQUFNQyxrQkFBa0I7Z0JBQ3BCQyxVQUFVSDtZQUNkO1lBQ0EsSUFBSSxJQUFJLENBQUNMLE1BQU0sQ0FBQ1MsTUFBTSxHQUFHLEdBQUc7Z0JBQ3hCRixnQkFBZ0JHLE1BQU0sR0FBRztvQkFDckJWLFFBQVEsSUFBSSxDQUFDQSxNQUFNLENBQUNXLElBQUksQ0FBQztnQkFDN0I7WUFDSjtZQUNBTCxPQUFPLE1BQU1mLFlBQVlxQixRQUFRLENBQUNMO1FBQ3RDLEVBQ0EsT0FBT00sR0FBRztZQUNOLElBQUlBLGFBQWF4QixTQUFTeUIsV0FBVyxFQUFFO2dCQUNuQ0QsRUFBRUUsT0FBTyxHQUFHLENBQUMsZ0NBQWdDLEVBQUVGLEVBQUVFLE9BQU8sQ0FBQyxDQUFDO2dCQUMxRCxJQUFJLENBQUNDLFNBQVMsQ0FBQ0g7WUFDbkI7WUFDQSxNQUFNQTtRQUNWO1FBQ0EsTUFBTUksU0FBU1g7UUFDZixJQUFJQSxRQUFRQSxLQUFLWSxVQUFVLEVBQUU7WUFDekJELE9BQU9wQixXQUFXLEdBQUcsSUFBSXNCLE9BQU9DLE9BQU8sS0FBS2QsS0FBS1ksVUFBVSxHQUFHO1lBQzlELE9BQU9ELE9BQU9DLFVBQVU7UUFDNUI7UUFDQSxJQUFJLENBQUNHLElBQUksQ0FBQyxVQUFVSjtRQUNwQixPQUFPO1lBQUVBO1lBQVFLLEtBQUs7UUFBSztJQUMvQjtJQUNBOzs7S0FHQyxHQUNELE1BQU1DLGFBQWFDLGNBQWMsRUFBRTtRQUMvQixNQUFNQyxjQUFjLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDMUIsbUJBQW1CLENBQUMsU0FBUyxDQUFDLEdBQ3ZFLENBQUMsc0JBQXNCLEVBQUV5QixlQUFlLENBQUM7UUFDN0MsSUFBSUU7UUFDSixJQUFJO1lBQ0EsTUFBTW5CLGtCQUFrQjtnQkFDcEJDLFVBQVVpQjtZQUNkO1lBQ0FDLFVBQVUsTUFBTW5DLFlBQVlxQixRQUFRLENBQUNMO1FBQ3pDLEVBQ0EsT0FBT00sR0FBRztZQUNOLElBQUlBLGFBQWFjLE9BQU87Z0JBQ3BCZCxFQUFFRSxPQUFPLEdBQUcsQ0FBQywwQkFBMEIsRUFBRUYsRUFBRUUsT0FBTyxDQUFDLENBQUM7WUFDeEQ7WUFDQSxNQUFNRjtRQUNWO1FBQ0EsT0FBT2E7SUFDWDtJQUNBVixVQUFVSCxDQUFDLEVBQUU7UUFDVCxNQUFNUyxNQUFNVCxFQUFFZSxRQUFRO1FBQ3RCLElBQUlOLE9BQU9BLElBQUlPLE1BQU0sRUFBRTtZQUNuQmhCLEVBQUVnQixNQUFNLEdBQUdQLElBQUlPLE1BQU07WUFDckIsSUFBSVAsSUFBSU8sTUFBTSxLQUFLLEtBQUs7Z0JBQ3BCaEIsRUFBRUUsT0FBTyxHQUNMLDJFQUNJLDRGQUNBLDRFQUNBRixFQUFFRSxPQUFPO1lBQ3JCLE9BQ0ssSUFBSU8sSUFBSU8sTUFBTSxLQUFLLEtBQUs7Z0JBQ3pCaEIsRUFBRUUsT0FBTyxHQUNMLDBFQUNJLDRGQUNBLG9FQUNBRixFQUFFRSxPQUFPO1lBQ3JCO1FBQ0o7SUFDSjtBQUNKO0FBQ0E3QixlQUFlLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvdGlmeS10by15b3V0dWJlLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvY29tcHV0ZWNsaWVudC5qcz82M2YyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTMgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXB1dGUgPSB2b2lkIDA7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBnY3BNZXRhZGF0YSA9IHJlcXVpcmUoXCJnY3AtbWV0YWRhdGFcIik7XG5jb25zdCBvYXV0aDJjbGllbnRfMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNsaWVudFwiKTtcbmNsYXNzIENvbXB1dGUgZXh0ZW5kcyBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEdvb2dsZSBDb21wdXRlIEVuZ2luZSBzZXJ2aWNlIGFjY291bnQgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZSBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgbWV0YWRhdGEgc2VydmVyLlxuICAgICAqIFNlZTogaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2NvbXB1dGUvZG9jcy9hY2Nlc3MvYXV0aGVudGljYXRlLXdvcmtsb2FkcyNhcHBsaWNhdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYW4gZXhwaXJlZCByZWZyZXNoIHRva2VuLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICAgICAgLy8gcmVmcmVzaGVkIGJlZm9yZSB0aGUgZmlyc3QgQVBJIGNhbGwgaXMgbWFkZS5cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHsgZXhwaXJ5X2RhdGU6IDEsIHJlZnJlc2hfdG9rZW46ICdjb21wdXRlLXBsYWNlaG9sZGVyJyB9O1xuICAgICAgICB0aGlzLnNlcnZpY2VBY2NvdW50RW1haWwgPSBvcHRpb25zLnNlcnZpY2VBY2NvdW50RW1haWwgfHwgJ2RlZmF1bHQnO1xuICAgICAgICB0aGlzLnNjb3BlcyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5zY29wZXMpXG4gICAgICAgICAgICA/IG9wdGlvbnMuc2NvcGVzXG4gICAgICAgICAgICA6IG9wdGlvbnMuc2NvcGVzXG4gICAgICAgICAgICAgICAgPyBbb3B0aW9ucy5zY29wZXNdXG4gICAgICAgICAgICAgICAgOiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBVbnVzZWQgcGFyYW1ldGVyXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFRva2VuTm9DYWNoZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHRva2VuUGF0aCA9IGBzZXJ2aWNlLWFjY291bnRzLyR7dGhpcy5zZXJ2aWNlQWNjb3VudEVtYWlsfS90b2tlbmA7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB0b2tlblBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NvcGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZU9wdGlvbnMucGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBzY29wZXM6IHRoaXMuc2NvcGVzLmpvaW4oJywnKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IGF3YWl0IGdjcE1ldGFkYXRhLmluc3RhbmNlKGluc3RhbmNlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgZ2F4aW9zXzEuR2F4aW9zRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBgQ291bGQgbm90IHJlZnJlc2ggYWNjZXNzIHRva2VuOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcEVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbnMgPSBkYXRhO1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmV4cGlyZXNfaW4pIHtcbiAgICAgICAgICAgIHRva2Vucy5leHBpcnlfZGF0ZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgZGF0YS5leHBpcmVzX2luICogMTAwMDtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbnMuZXhwaXJlc19pbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB7IHRva2VucywgcmVzOiBudWxsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYW4gSUQgdG9rZW4uXG4gICAgICogQHBhcmFtIHRhcmdldEF1ZGllbmNlIHRoZSBhdWRpZW5jZSBmb3IgdGhlIGZldGNoZWQgSUQgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hJZFRva2VuKHRhcmdldEF1ZGllbmNlKSB7XG4gICAgICAgIGNvbnN0IGlkVG9rZW5QYXRoID0gYHNlcnZpY2UtYWNjb3VudHMvJHt0aGlzLnNlcnZpY2VBY2NvdW50RW1haWx9L2lkZW50aXR5YCArXG4gICAgICAgICAgICBgP2Zvcm1hdD1mdWxsJmF1ZGllbmNlPSR7dGFyZ2V0QXVkaWVuY2V9YDtcbiAgICAgICAgbGV0IGlkVG9rZW47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IGlkVG9rZW5QYXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlkVG9rZW4gPSBhd2FpdCBnY3BNZXRhZGF0YS5pbnN0YW5jZShpbnN0YW5jZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYENvdWxkIG5vdCBmZXRjaCBJRCB0b2tlbjogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkVG9rZW47XG4gICAgfVxuICAgIHdyYXBFcnJvcihlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGUucmVzcG9uc2U7XG4gICAgICAgIGlmIChyZXMgJiYgcmVzLnN0YXR1cykge1xuICAgICAgICAgICAgZS5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICdBIEZvcmJpZGRlbiBlcnJvciB3YXMgcmV0dXJuZWQgd2hpbGUgYXR0ZW1wdGluZyB0byByZXRyaWV2ZSBhbiBhY2Nlc3MgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAndG9rZW4gZm9yIHRoZSBDb21wdXRlIEVuZ2luZSBidWlsdC1pbiBzZXJ2aWNlIGFjY291bnQuIFRoaXMgbWF5IGJlIGJlY2F1c2UgdGhlIENvbXB1dGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnRW5naW5lIGluc3RhbmNlIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgcGVybWlzc2lvbiBzY29wZXMgc3BlY2lmaWVkOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICdBIE5vdCBGb3VuZCBlcnJvciB3YXMgcmV0dXJuZWQgd2hpbGUgYXR0ZW1wdGluZyB0byByZXRyaWV2ZSBhbiBhY2Nlc3MnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b2tlbiBmb3IgdGhlIENvbXB1dGUgRW5naW5lIGJ1aWx0LWluIHNlcnZpY2UgYWNjb3VudC4gVGhpcyBtYXkgYmUgYmVjYXVzZSB0aGUgQ29tcHV0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdFbmdpbmUgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBhbnkgcGVybWlzc2lvbiBzY29wZXMgc3BlY2lmaWVkOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29tcHV0ZSA9IENvbXB1dGU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb21wdXRlIiwiZ2F4aW9zXzEiLCJyZXF1aXJlIiwiZ2NwTWV0YWRhdGEiLCJvYXV0aDJjbGllbnRfMSIsIk9BdXRoMkNsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNyZWRlbnRpYWxzIiwiZXhwaXJ5X2RhdGUiLCJyZWZyZXNoX3Rva2VuIiwic2VydmljZUFjY291bnRFbWFpbCIsInNjb3BlcyIsIkFycmF5IiwiaXNBcnJheSIsInJlZnJlc2hUb2tlbk5vQ2FjaGUiLCJyZWZyZXNoVG9rZW4iLCJ0b2tlblBhdGgiLCJkYXRhIiwiaW5zdGFuY2VPcHRpb25zIiwicHJvcGVydHkiLCJsZW5ndGgiLCJwYXJhbXMiLCJqb2luIiwiaW5zdGFuY2UiLCJlIiwiR2F4aW9zRXJyb3IiLCJtZXNzYWdlIiwid3JhcEVycm9yIiwidG9rZW5zIiwiZXhwaXJlc19pbiIsIkRhdGUiLCJnZXRUaW1lIiwiZW1pdCIsInJlcyIsImZldGNoSWRUb2tlbiIsInRhcmdldEF1ZGllbmNlIiwiaWRUb2tlblBhdGgiLCJpZFRva2VuIiwiRXJyb3IiLCJyZXNwb25zZSIsInN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/computeclient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/downscopedclient.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst sts = __webpack_require__(/*! ./stscredentials */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */ const STS_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\";\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */ const STS_REQUEST_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\";\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */ const STS_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\";\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */ exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */ exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */ class DownscopedClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates a downscoped client object using the provided source\n     * AuthClient and credential access boundary rules.\n     * To downscope permissions of a source AuthClient, a Credential Access\n     * Boundary that specifies which resources the new credential can access, as\n     * well as an upper bound on the permissions that are available on each\n     * resource, has to be defined. A downscoped client can then be instantiated\n     * using the source AuthClient and the Credential Access Boundary.\n     * @param authClient The source AuthClient to be downscoped based on the\n     *   provided Credential Access Boundary rules.\n     * @param credentialAccessBoundary The Credential Access Boundary which\n     *   contains a list of access boundary rules. Each rule contains information\n     *   on the resource that the rule applies to, the upper bound of the\n     *   permissions that are available on that resource and an optional\n     *   condition to further restrict permissions.\n     * @param additionalOptions **DEPRECATED, set this in the provided `authClient`.**\n     *   Optional additional behavior customization options.\n     * @param quotaProjectId **DEPRECATED, set this in the provided `authClient`.**\n     *   Optional quota project id for setting up in the x-goog-user-project header.\n     */ constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId){\n        super({\n            ...additionalOptions,\n            quotaProjectId\n        });\n        this.authClient = authClient;\n        this.credentialAccessBoundary = credentialAccessBoundary;\n        // Check 1-10 Access Boundary Rules are defined within Credential Access\n        // Boundary.\n        if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n            throw new Error(\"At least one access boundary rule needs to be defined.\");\n        } else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n            throw new Error(\"The provided access boundary has more than \" + `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\n        }\n        // Check at least one permission should be defined in each Access Boundary\n        // Rule.\n        for (const rule of credentialAccessBoundary.accessBoundary.accessBoundaryRules){\n            if (rule.availablePermissions.length === 0) {\n                throw new Error(\"At least one permission should be defined in access boundary rules.\");\n            }\n        }\n        this.stsCredential = new sts.StsCredentials(`https://sts.${this.universeDomain}/v1/token`);\n        this.cachedDownscopedAccessToken = null;\n    }\n    /**\n     * Provides a mechanism to inject Downscoped access tokens directly.\n     * The expiry_date field is required to facilitate determination of the token\n     * expiration which would make it easier for the token consumer to handle.\n     * @param credentials The Credentials object to set on the current client.\n     */ setCredentials(credentials) {\n        if (!credentials.expiry_date) {\n            throw new Error(\"The access token expiry_date field is missing in the provided \" + \"credentials.\");\n        }\n        super.setCredentials(credentials);\n        this.cachedDownscopedAccessToken = credentials;\n    }\n    async getAccessToken() {\n        // If the cached access token is unavailable or expired, force refresh.\n        // The Downscoped access token will be returned in\n        // DownscopedAccessTokenResponse format.\n        if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return Downscoped access token in DownscopedAccessTokenResponse format.\n        return {\n            token: this.cachedDownscopedAccessToken.access_token,\n            expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n            res: this.cachedDownscopedAccessToken.res\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */ async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */ async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = requestHeaders[\"x-goog-user-project\"];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Then GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */ async refreshAccessTokenAsync() {\n        var _a;\n        // Retrieve GCP access token from source credential.\n        const subjectToken = (await this.authClient.getAccessToken()).token;\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken: subjectToken,\n            subjectTokenType: STS_SUBJECT_TOKEN_TYPE\n        };\n        // Exchange the source AuthClient access token for a Downscoped access\n        // token.\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n        /**\n         * The STS endpoint will only return the expiration time for the downscoped\n         * access token if the original access token represents a service account.\n         * The downscoped token's expiration time will always match the source\n         * credential expiration. When no expires_in is returned, we can copy the\n         * source credential's expiration time.\n         */ const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n        const expiryDate = stsResponse.expires_in ? new Date().getTime() + stsResponse.expires_in * 1000 : sourceCredExpireDate;\n        // Save response in cached access token.\n        this.cachedDownscopedAccessToken = {\n            access_token: stsResponse.access_token,\n            expiry_date: expiryDate,\n            res: stsResponse.res\n        };\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit(\"tokens\", {\n            refresh_token: null,\n            expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n            access_token: this.cachedDownscopedAccessToken.access_token,\n            token_type: \"Bearer\",\n            id_token: null\n        });\n        // Return the cached access token.\n        return this.cachedDownscopedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */ isExpired(downscopedAccessToken) {\n        const now = new Date().getTime();\n        return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n}\nexports.DownscopedClient = DownscopedClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2Rvd25zY29wZWRjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBR0EsOEJBQThCLEdBQUdBLHVDQUF1QyxHQUFHLEtBQUs7QUFDM0csTUFBTUssU0FBU0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDL0IsTUFBTUMsZUFBZUQsbUJBQU9BLENBQUMsc0dBQWM7QUFDM0MsTUFBTUUsTUFBTUYsbUJBQU9BLENBQUMsOEdBQWtCO0FBQ3RDOztDQUVDLEdBQ0QsTUFBTUcsaUJBQWlCO0FBQ3ZCOztDQUVDLEdBQ0QsTUFBTUMseUJBQXlCO0FBQy9COztDQUVDLEdBQ0QsTUFBTUMseUJBQXlCO0FBQy9COzs7Q0FHQyxHQUNEWCx1Q0FBdUMsR0FBRztBQUMxQzs7Q0FFQyxHQUNEQSw4QkFBOEIsR0FBRyxJQUFJLEtBQUs7QUFDMUM7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUUseUJBQXlCSyxhQUFhSyxVQUFVO0lBQ2xEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBbUJDLEdBQ0RDLFlBQVlDLFVBQVUsRUFBRUMsd0JBQXdCLEVBQUVDLGlCQUFpQixFQUFFQyxjQUFjLENBQUU7UUFDakYsS0FBSyxDQUFDO1lBQUUsR0FBR0QsaUJBQWlCO1lBQUVDO1FBQWU7UUFDN0MsSUFBSSxDQUFDSCxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0Msd0JBQXdCLEdBQUdBO1FBQ2hDLHdFQUF3RTtR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RCxVQUFVLENBQUNlLFdBQVcsTUFBTSxRQUFRaUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaEMsV0FBVyxLQUFLO1FBQ3pILE1BQU0wQyxhQUFhSixZQUFZSyxVQUFVLEdBQ25DLElBQUlDLE9BQU9DLE9BQU8sS0FBS1AsWUFBWUssVUFBVSxHQUFHLE9BQ2hERjtRQUNOLHdDQUF3QztRQUN4QyxJQUFJLENBQUM1QywyQkFBMkIsR0FBRztZQUMvQlEsY0FBY2lDLFlBQVlqQyxZQUFZO1lBQ3RDTCxhQUFhMEM7WUFDYm5DLEtBQUsrQixZQUFZL0IsR0FBRztRQUN4QjtRQUNBLG9CQUFvQjtRQUNwQixJQUFJLENBQUNSLFdBQVcsR0FBRyxDQUFDO1FBQ3BCL0IsT0FBTzhFLE1BQU0sQ0FBQyxJQUFJLENBQUMvQyxXQUFXLEVBQUUsSUFBSSxDQUFDRiwyQkFBMkI7UUFDaEUsT0FBTyxJQUFJLENBQUNFLFdBQVcsQ0FBQ1EsR0FBRztRQUMzQixxREFBcUQ7UUFDckQsSUFBSSxDQUFDd0MsSUFBSSxDQUFDLFVBQVU7WUFDaEJDLGVBQWU7WUFDZmhELGFBQWEsSUFBSSxDQUFDSCwyQkFBMkIsQ0FBQ0csV0FBVztZQUN6REssY0FBYyxJQUFJLENBQUNSLDJCQUEyQixDQUFDUSxZQUFZO1lBQzNENEMsWUFBWTtZQUNaQyxVQUFVO1FBQ2Q7UUFDQSxrQ0FBa0M7UUFDbEMsT0FBTyxJQUFJLENBQUNyRCwyQkFBMkI7SUFDM0M7SUFDQTs7Ozs7S0FLQyxHQUNESyxVQUFVaUQscUJBQXFCLEVBQUU7UUFDN0IsTUFBTUMsTUFBTSxJQUFJUixPQUFPQyxPQUFPO1FBQzlCLE9BQU9NLHNCQUFzQm5ELFdBQVcsR0FDbENvRCxPQUNFRCxzQkFBc0JuRCxXQUFXLEdBQUcsSUFBSSxDQUFDcUQsMkJBQTJCLEdBQ3RFO0lBQ1Y7QUFDSjtBQUNBbkYsd0JBQXdCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvdGlmeS10by15b3V0dWJlLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZG93bnNjb3BlZGNsaWVudC5qcz84Yjk4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRvd25zY29wZWRDbGllbnQgPSBleHBvcnRzLkVYUElSQVRJT05fVElNRV9PRkZTRVQgPSBleHBvcnRzLk1BWF9BQ0NFU1NfQk9VTkRBUllfUlVMRVNfQ09VTlQgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aGNsaWVudFwiKTtcbmNvbnN0IHN0cyA9IHJlcXVpcmUoXCIuL3N0c2NyZWRlbnRpYWxzXCIpO1xuLyoqXG4gKiBUaGUgcmVxdWlyZWQgdG9rZW4gZXhjaGFuZ2UgZ3JhbnRfdHlwZTogcmZjODY5MyNzZWN0aW9uLTIuMVxuICovXG5jb25zdCBTVFNfR1JBTlRfVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTp0b2tlbi1leGNoYW5nZSc7XG4vKipcbiAqIFRoZSByZXF1ZXN0ZWQgdG9rZW4gZXhjaGFuZ2UgcmVxdWVzdGVkX3Rva2VuX3R5cGU6IHJmYzg2OTMjc2VjdGlvbi0yLjFcbiAqL1xuY29uc3QgU1RTX1JFUVVFU1RfVE9LRU5fVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTphY2Nlc3NfdG9rZW4nO1xuLyoqXG4gKiBUaGUgcmVxdWVzdGVkIHRva2VuIGV4Y2hhbmdlIHN1YmplY3RfdG9rZW5fdHlwZTogcmZjODY5MyNzZWN0aW9uLTIuMVxuICovXG5jb25zdCBTVFNfU1VCSkVDVF9UT0tFTl9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOmFjY2Vzc190b2tlbic7XG4vKipcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhY2Nlc3MgYm91bmRhcnkgcnVsZXMgYSBDcmVkZW50aWFsIEFjY2VzcyBCb3VuZGFyeVxuICogY2FuIGNvbnRhaW4uXG4gKi9cbmV4cG9ydHMuTUFYX0FDQ0VTU19CT1VOREFSWV9SVUxFU19DT1VOVCA9IDEwO1xuLyoqXG4gKiBPZmZzZXQgdG8gdGFrZSBpbnRvIGFjY291bnQgbmV0d29yayBkZWxheXMgYW5kIHNlcnZlciBjbG9jayBza2V3cy5cbiAqL1xuZXhwb3J0cy5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUID0gNSAqIDYwICogMTAwMDtcbi8qKlxuICogRGVmaW5lcyBhIHNldCBvZiBHb29nbGUgY3JlZGVudGlhbHMgdGhhdCBhcmUgZG93bnNjb3BlZCBmcm9tIGFuIGV4aXN0aW5nIHNldFxuICogb2YgR29vZ2xlIE9BdXRoMiBjcmVkZW50aWFscy4gVGhpcyBpcyB1c2VmdWwgdG8gcmVzdHJpY3QgdGhlIElkZW50aXR5IGFuZFxuICogQWNjZXNzIE1hbmFnZW1lbnQgKElBTSkgcGVybWlzc2lvbnMgdGhhdCBhIHNob3J0LWxpdmVkIGNyZWRlbnRpYWwgY2FuIHVzZS5cbiAqIFRoZSBjb21tb24gcGF0dGVybiBvZiB1c2FnZSBpcyB0byBoYXZlIGEgdG9rZW4gYnJva2VyIHdpdGggZWxldmF0ZWQgYWNjZXNzXG4gKiBnZW5lcmF0ZSB0aGVzZSBkb3duc2NvcGVkIGNyZWRlbnRpYWxzIGZyb20gaGlnaGVyIGFjY2VzcyBzb3VyY2UgY3JlZGVudGlhbHNcbiAqIGFuZCBwYXNzIHRoZSBkb3duc2NvcGVkIHNob3J0LWxpdmVkIGFjY2VzcyB0b2tlbnMgdG8gYSB0b2tlbiBjb25zdW1lciB2aWFcbiAqIHNvbWUgc2VjdXJlIGF1dGhlbnRpY2F0ZWQgY2hhbm5lbCBmb3IgbGltaXRlZCBhY2Nlc3MgdG8gR29vZ2xlIENsb3VkIFN0b3JhZ2VcbiAqIHJlc291cmNlcy5cbiAqL1xuY2xhc3MgRG93bnNjb3BlZENsaWVudCBleHRlbmRzIGF1dGhjbGllbnRfMS5BdXRoQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYSBkb3duc2NvcGVkIGNsaWVudCBvYmplY3QgdXNpbmcgdGhlIHByb3ZpZGVkIHNvdXJjZVxuICAgICAqIEF1dGhDbGllbnQgYW5kIGNyZWRlbnRpYWwgYWNjZXNzIGJvdW5kYXJ5IHJ1bGVzLlxuICAgICAqIFRvIGRvd25zY29wZSBwZXJtaXNzaW9ucyBvZiBhIHNvdXJjZSBBdXRoQ2xpZW50LCBhIENyZWRlbnRpYWwgQWNjZXNzXG4gICAgICogQm91bmRhcnkgdGhhdCBzcGVjaWZpZXMgd2hpY2ggcmVzb3VyY2VzIHRoZSBuZXcgY3JlZGVudGlhbCBjYW4gYWNjZXNzLCBhc1xuICAgICAqIHdlbGwgYXMgYW4gdXBwZXIgYm91bmQgb24gdGhlIHBlcm1pc3Npb25zIHRoYXQgYXJlIGF2YWlsYWJsZSBvbiBlYWNoXG4gICAgICogcmVzb3VyY2UsIGhhcyB0byBiZSBkZWZpbmVkLiBBIGRvd25zY29wZWQgY2xpZW50IGNhbiB0aGVuIGJlIGluc3RhbnRpYXRlZFxuICAgICAqIHVzaW5nIHRoZSBzb3VyY2UgQXV0aENsaWVudCBhbmQgdGhlIENyZWRlbnRpYWwgQWNjZXNzIEJvdW5kYXJ5LlxuICAgICAqIEBwYXJhbSBhdXRoQ2xpZW50IFRoZSBzb3VyY2UgQXV0aENsaWVudCB0byBiZSBkb3duc2NvcGVkIGJhc2VkIG9uIHRoZVxuICAgICAqICAgcHJvdmlkZWQgQ3JlZGVudGlhbCBBY2Nlc3MgQm91bmRhcnkgcnVsZXMuXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeSBUaGUgQ3JlZGVudGlhbCBBY2Nlc3MgQm91bmRhcnkgd2hpY2hcbiAgICAgKiAgIGNvbnRhaW5zIGEgbGlzdCBvZiBhY2Nlc3MgYm91bmRhcnkgcnVsZXMuIEVhY2ggcnVsZSBjb250YWlucyBpbmZvcm1hdGlvblxuICAgICAqICAgb24gdGhlIHJlc291cmNlIHRoYXQgdGhlIHJ1bGUgYXBwbGllcyB0bywgdGhlIHVwcGVyIGJvdW5kIG9mIHRoZVxuICAgICAqICAgcGVybWlzc2lvbnMgdGhhdCBhcmUgYXZhaWxhYmxlIG9uIHRoYXQgcmVzb3VyY2UgYW5kIGFuIG9wdGlvbmFsXG4gICAgICogICBjb25kaXRpb24gdG8gZnVydGhlciByZXN0cmljdCBwZXJtaXNzaW9ucy5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnMgKipERVBSRUNBVEVELCBzZXQgdGhpcyBpbiB0aGUgcHJvdmlkZWQgYGF1dGhDbGllbnRgLioqXG4gICAgICogICBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gcXVvdGFQcm9qZWN0SWQgKipERVBSRUNBVEVELCBzZXQgdGhpcyBpbiB0aGUgcHJvdmlkZWQgYGF1dGhDbGllbnRgLioqXG4gICAgICogICBPcHRpb25hbCBxdW90YSBwcm9qZWN0IGlkIGZvciBzZXR0aW5nIHVwIGluIHRoZSB4LWdvb2ctdXNlci1wcm9qZWN0IGhlYWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhdXRoQ2xpZW50LCBjcmVkZW50aWFsQWNjZXNzQm91bmRhcnksIGFkZGl0aW9uYWxPcHRpb25zLCBxdW90YVByb2plY3RJZCkge1xuICAgICAgICBzdXBlcih7IC4uLmFkZGl0aW9uYWxPcHRpb25zLCBxdW90YVByb2plY3RJZCB9KTtcbiAgICAgICAgdGhpcy5hdXRoQ2xpZW50ID0gYXV0aENsaWVudDtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFsQWNjZXNzQm91bmRhcnkgPSBjcmVkZW50aWFsQWNjZXNzQm91bmRhcnk7XG4gICAgICAgIC8vIENoZWNrIDEtMTAgQWNjZXNzIEJvdW5kYXJ5IFJ1bGVzIGFyZSBkZWZpbmVkIHdpdGhpbiBDcmVkZW50aWFsIEFjY2Vzc1xuICAgICAgICAvLyBCb3VuZGFyeS5cbiAgICAgICAgaWYgKGNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeS5hY2Nlc3NCb3VuZGFyeS5hY2Nlc3NCb3VuZGFyeVJ1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgYWNjZXNzIGJvdW5kYXJ5IHJ1bGUgbmVlZHMgdG8gYmUgZGVmaW5lZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcmVkZW50aWFsQWNjZXNzQm91bmRhcnkuYWNjZXNzQm91bmRhcnkuYWNjZXNzQm91bmRhcnlSdWxlcy5sZW5ndGggPlxuICAgICAgICAgICAgZXhwb3J0cy5NQVhfQUNDRVNTX0JPVU5EQVJZX1JVTEVTX0NPVU5UKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBhY2Nlc3MgYm91bmRhcnkgaGFzIG1vcmUgdGhhbiAnICtcbiAgICAgICAgICAgICAgICBgJHtleHBvcnRzLk1BWF9BQ0NFU1NfQk9VTkRBUllfUlVMRVNfQ09VTlR9IGFjY2VzcyBib3VuZGFyeSBydWxlcy5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBhdCBsZWFzdCBvbmUgcGVybWlzc2lvbiBzaG91bGQgYmUgZGVmaW5lZCBpbiBlYWNoIEFjY2VzcyBCb3VuZGFyeVxuICAgICAgICAvLyBSdWxlLlxuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5LmFjY2Vzc0JvdW5kYXJ5XG4gICAgICAgICAgICAuYWNjZXNzQm91bmRhcnlSdWxlcykge1xuICAgICAgICAgICAgaWYgKHJ1bGUuYXZhaWxhYmxlUGVybWlzc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgcGVybWlzc2lvbiBzaG91bGQgYmUgZGVmaW5lZCBpbiBhY2Nlc3MgYm91bmRhcnkgcnVsZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHNDcmVkZW50aWFsID0gbmV3IHN0cy5TdHNDcmVkZW50aWFscyhgaHR0cHM6Ly9zdHMuJHt0aGlzLnVuaXZlcnNlRG9tYWlufS92MS90b2tlbmApO1xuICAgICAgICB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIGluamVjdCBEb3duc2NvcGVkIGFjY2VzcyB0b2tlbnMgZGlyZWN0bHkuXG4gICAgICogVGhlIGV4cGlyeV9kYXRlIGZpZWxkIGlzIHJlcXVpcmVkIHRvIGZhY2lsaXRhdGUgZGV0ZXJtaW5hdGlvbiBvZiB0aGUgdG9rZW5cbiAgICAgKiBleHBpcmF0aW9uIHdoaWNoIHdvdWxkIG1ha2UgaXQgZWFzaWVyIGZvciB0aGUgdG9rZW4gY29uc3VtZXIgdG8gaGFuZGxlLlxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgQ3JlZGVudGlhbHMgb2JqZWN0IHRvIHNldCBvbiB0aGUgY3VycmVudCBjbGllbnQuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgaWYgKCFjcmVkZW50aWFscy5leHBpcnlfZGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYWNjZXNzIHRva2VuIGV4cGlyeV9kYXRlIGZpZWxkIGlzIG1pc3NpbmcgaW4gdGhlIHByb3ZpZGVkICcgK1xuICAgICAgICAgICAgICAgICdjcmVkZW50aWFscy4nKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5zZXRDcmVkZW50aWFscyhjcmVkZW50aWFscyk7XG4gICAgICAgIHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuID0gY3JlZGVudGlhbHM7XG4gICAgfVxuICAgIGFzeW5jIGdldEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICAvLyBJZiB0aGUgY2FjaGVkIGFjY2VzcyB0b2tlbiBpcyB1bmF2YWlsYWJsZSBvciBleHBpcmVkLCBmb3JjZSByZWZyZXNoLlxuICAgICAgICAvLyBUaGUgRG93bnNjb3BlZCBhY2Nlc3MgdG9rZW4gd2lsbCBiZSByZXR1cm5lZCBpblxuICAgICAgICAvLyBEb3duc2NvcGVkQWNjZXNzVG9rZW5SZXNwb25zZSBmb3JtYXQuXG4gICAgICAgIGlmICghdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4gfHxcbiAgICAgICAgICAgIHRoaXMuaXNFeHBpcmVkKHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBEb3duc2NvcGVkIGFjY2VzcyB0b2tlbiBpbiBEb3duc2NvcGVkQWNjZXNzVG9rZW5SZXNwb25zZSBmb3JtYXQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbjogdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgZXhwaXJhdGlvblRpbWU6IHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlLFxuICAgICAgICAgICAgcmVzOiB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbi5yZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIGF1dGhlbnRpY2F0aW9uIGludGVyZmFjZS4gSXQgdGFrZXMgYW4gb3B0aW9uYWwgdXJsIHdoaWNoIHdoZW5cbiAgICAgKiBwcmVzZW50IGlzIHRoZSBlbmRwb2ludCBiZWluZyBhY2Nlc3NlZCwgYW5kIHJldHVybnMgYSBQcm9taXNlIHdoaWNoXG4gICAgICogcmVzb2x2ZXMgd2l0aCBhdXRob3JpemF0aW9uIGhlYWRlciBmaWVsZHMuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzdWx0IGhhcyB0aGUgZm9ybTpcbiAgICAgKiB7IEF1dGhvcml6YXRpb246ICdCZWFyZXIgPGFjY2Vzc190b2tlbl92YWx1ZT4nIH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlblJlc3BvbnNlLnRva2VufWAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG4gICAgcmVxdWVzdChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIGUucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXV0aGVudGljYXRlcyB0aGUgcHJvdmlkZWQgSFRUUCByZXF1ZXN0LCBwcm9jZXNzZXMgaXQgYW5kIHJlc29sdmVzIHdpdGggdGhlXG4gICAgICogcmV0dXJuZWQgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIEhUVFAgcmVxdWVzdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSByZXRyeSBXaGV0aGVyIHRoZSBjdXJyZW50IGF0dGVtcHQgaXMgYSByZXRyeSBhZnRlciBhIGZhaWxlZCBhdHRlbXB0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0QXN5bmMob3B0cywgcmV0cnkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SGVhZGVycyAmJiByZXF1ZXN0SGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10gPVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gZS5yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICAvLyBSZXRyeSB0aGUgcmVxdWVzdCBmb3IgbWV0YWRhdGEgaWYgdGhlIGZvbGxvd2luZyBjcml0ZXJpYSBhcmUgdHJ1ZTpcbiAgICAgICAgICAgICAgICAvLyAtIFdlIGhhdmVuJ3QgYWxyZWFkeSByZXRyaWVkLiAgSXQgb25seSBtYWtlcyBzZW5zZSB0byByZXRyeSBvbmNlLlxuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlc3BvbnNlIHdhcyBhIDQwMSBvciBhIDQwM1xuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlcXVlc3QgZGlkbid0IHNlbmQgYSByZWFkYWJsZVN0cmVhbVxuICAgICAgICAgICAgICAgIC8vIC0gZm9yY2VSZWZyZXNoT25GYWlsdXJlIGlzIHRydWVcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID0gcmVzLmNvbmZpZy5kYXRhIGluc3RhbmNlb2Ygc3RyZWFtLlJlYWRhYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXV0aEVyciA9IHN0YXR1c0NvZGUgPT09IDQwMSB8fCBzdGF0dXNDb2RlID09PSA0MDM7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0F1dGhFcnIgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzUmVhZGFibGVTdHJlYW0gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0b2tlbiByZWZyZXNoLCBldmVuIGlmIHVuZXhwaXJlZCB0b2tlbnMgYXJlIGN1cnJlbnRseSBjYWNoZWQuXG4gICAgICogR0NQIGFjY2VzcyB0b2tlbnMgYXJlIHJldHJpZXZlZCBmcm9tIGF1dGhjbGllbnQgb2JqZWN0L3NvdXJjZSBjcmVkZW50aWFsLlxuICAgICAqIFRoZW4gR0NQIGFjY2VzcyB0b2tlbnMgYXJlIGV4Y2hhbmdlZCBmb3IgZG93bnNjb3BlZCBhY2Nlc3MgdG9rZW5zIHZpYSB0aGVcbiAgICAgKiB0b2tlbiBleGNoYW5nZSBlbmRwb2ludC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGZyZXNoIGRvd25zY29wZWQgYWNjZXNzIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFJldHJpZXZlIEdDUCBhY2Nlc3MgdG9rZW4gZnJvbSBzb3VyY2UgY3JlZGVudGlhbC5cbiAgICAgICAgY29uc3Qgc3ViamVjdFRva2VuID0gKGF3YWl0IHRoaXMuYXV0aENsaWVudC5nZXRBY2Nlc3NUb2tlbigpKS50b2tlbjtcbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBTVFMgY3JlZGVudGlhbHMgb3B0aW9ucy5cbiAgICAgICAgY29uc3Qgc3RzQ3JlZGVudGlhbHNPcHRpb25zID0ge1xuICAgICAgICAgICAgZ3JhbnRUeXBlOiBTVFNfR1JBTlRfVFlQRSxcbiAgICAgICAgICAgIHJlcXVlc3RlZFRva2VuVHlwZTogU1RTX1JFUVVFU1RfVE9LRU5fVFlQRSxcbiAgICAgICAgICAgIHN1YmplY3RUb2tlbjogc3ViamVjdFRva2VuLFxuICAgICAgICAgICAgc3ViamVjdFRva2VuVHlwZTogU1RTX1NVQkpFQ1RfVE9LRU5fVFlQRSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXhjaGFuZ2UgdGhlIHNvdXJjZSBBdXRoQ2xpZW50IGFjY2VzcyB0b2tlbiBmb3IgYSBEb3duc2NvcGVkIGFjY2Vzc1xuICAgICAgICAvLyB0b2tlbi5cbiAgICAgICAgY29uc3Qgc3RzUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0c0NyZWRlbnRpYWwuZXhjaGFuZ2VUb2tlbihzdHNDcmVkZW50aWFsc09wdGlvbnMsIHVuZGVmaW5lZCwgdGhpcy5jcmVkZW50aWFsQWNjZXNzQm91bmRhcnkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFNUUyBlbmRwb2ludCB3aWxsIG9ubHkgcmV0dXJuIHRoZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSBkb3duc2NvcGVkXG4gICAgICAgICAqIGFjY2VzcyB0b2tlbiBpZiB0aGUgb3JpZ2luYWwgYWNjZXNzIHRva2VuIHJlcHJlc2VudHMgYSBzZXJ2aWNlIGFjY291bnQuXG4gICAgICAgICAqIFRoZSBkb3duc2NvcGVkIHRva2VuJ3MgZXhwaXJhdGlvbiB0aW1lIHdpbGwgYWx3YXlzIG1hdGNoIHRoZSBzb3VyY2VcbiAgICAgICAgICogY3JlZGVudGlhbCBleHBpcmF0aW9uLiBXaGVuIG5vIGV4cGlyZXNfaW4gaXMgcmV0dXJuZWQsIHdlIGNhbiBjb3B5IHRoZVxuICAgICAgICAgKiBzb3VyY2UgY3JlZGVudGlhbCdzIGV4cGlyYXRpb24gdGltZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHNvdXJjZUNyZWRFeHBpcmVEYXRlID0gKChfYSA9IHRoaXMuYXV0aENsaWVudC5jcmVkZW50aWFscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4cGlyeV9kYXRlKSB8fCBudWxsO1xuICAgICAgICBjb25zdCBleHBpcnlEYXRlID0gc3RzUmVzcG9uc2UuZXhwaXJlc19pblxuICAgICAgICAgICAgPyBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHN0c1Jlc3BvbnNlLmV4cGlyZXNfaW4gKiAxMDAwXG4gICAgICAgICAgICA6IHNvdXJjZUNyZWRFeHBpcmVEYXRlO1xuICAgICAgICAvLyBTYXZlIHJlc3BvbnNlIGluIGNhY2hlZCBhY2Nlc3MgdG9rZW4uXG4gICAgICAgIHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuID0ge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBzdHNSZXNwb25zZS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICBleHBpcnlfZGF0ZTogZXhwaXJ5RGF0ZSxcbiAgICAgICAgICAgIHJlczogc3RzUmVzcG9uc2UucmVzLFxuICAgICAgICB9O1xuICAgICAgICAvLyBTYXZlIGNyZWRlbnRpYWxzLlxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jcmVkZW50aWFscywgdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4pO1xuICAgICAgICBkZWxldGUgdGhpcy5jcmVkZW50aWFscy5yZXM7XG4gICAgICAgIC8vIFRyaWdnZXIgdG9rZW5zIGV2ZW50IHRvIG5vdGlmeSBleHRlcm5hbCBsaXN0ZW5lcnMuXG4gICAgICAgIHRoaXMuZW1pdCgndG9rZW5zJywge1xuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogbnVsbCxcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbi5leHBpcnlfZGF0ZSxcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgdG9rZW5fdHlwZTogJ0JlYXJlcicsXG4gICAgICAgICAgICBpZF90b2tlbjogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgY2FjaGVkIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGNyZWRlbnRpYWxzIGFyZSBleHBpcmVkIG9yIG5vdC5cbiAgICAgKiBJZiB0aGVyZSBpcyBubyBleHBpcnkgdGltZSwgYXNzdW1lcyB0aGUgdG9rZW4gaXMgbm90IGV4cGlyZWQgb3IgZXhwaXJpbmcuXG4gICAgICogQHBhcmFtIGRvd25zY29wZWRBY2Nlc3NUb2tlbiBUaGUgY3JlZGVudGlhbHMgdG8gY2hlY2sgZm9yIGV4cGlyYXRpb24uXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoZSBjcmVkZW50aWFscyBhcmUgZXhwaXJlZCBvciBub3QuXG4gICAgICovXG4gICAgaXNFeHBpcmVkKGRvd25zY29wZWRBY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIGRvd25zY29wZWRBY2Nlc3NUb2tlbi5leHBpcnlfZGF0ZVxuICAgICAgICAgICAgPyBub3cgPj1cbiAgICAgICAgICAgICAgICBkb3duc2NvcGVkQWNjZXNzVG9rZW4uZXhwaXJ5X2RhdGUgLSB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpc1xuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkRvd25zY29wZWRDbGllbnQgPSBEb3duc2NvcGVkQ2xpZW50O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRG93bnNjb3BlZENsaWVudCIsIkVYUElSQVRJT05fVElNRV9PRkZTRVQiLCJNQVhfQUNDRVNTX0JPVU5EQVJZX1JVTEVTX0NPVU5UIiwic3RyZWFtIiwicmVxdWlyZSIsImF1dGhjbGllbnRfMSIsInN0cyIsIlNUU19HUkFOVF9UWVBFIiwiU1RTX1JFUVVFU1RfVE9LRU5fVFlQRSIsIlNUU19TVUJKRUNUX1RPS0VOX1RZUEUiLCJBdXRoQ2xpZW50IiwiY29uc3RydWN0b3IiLCJhdXRoQ2xpZW50IiwiY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5IiwiYWRkaXRpb25hbE9wdGlvbnMiLCJxdW90YVByb2plY3RJZCIsImFjY2Vzc0JvdW5kYXJ5IiwiYWNjZXNzQm91bmRhcnlSdWxlcyIsImxlbmd0aCIsIkVycm9yIiwicnVsZSIsImF2YWlsYWJsZVBlcm1pc3Npb25zIiwic3RzQ3JlZGVudGlhbCIsIlN0c0NyZWRlbnRpYWxzIiwidW5pdmVyc2VEb21haW4iLCJjYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4iLCJzZXRDcmVkZW50aWFscyIsImNyZWRlbnRpYWxzIiwiZXhwaXJ5X2RhdGUiLCJnZXRBY2Nlc3NUb2tlbiIsImlzRXhwaXJlZCIsInJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jIiwidG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJleHBpcmF0aW9uVGltZSIsInJlcyIsImdldFJlcXVlc3RIZWFkZXJzIiwiYWNjZXNzVG9rZW5SZXNwb25zZSIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwiYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzIiwicmVxdWVzdCIsIm9wdHMiLCJjYWxsYmFjayIsInJlcXVlc3RBc3luYyIsInRoZW4iLCJyIiwiZSIsInJlc3BvbnNlIiwicmV0cnkiLCJyZXF1ZXN0SGVhZGVycyIsInRyYW5zcG9ydGVyIiwic3RhdHVzQ29kZSIsInN0YXR1cyIsImlzUmVhZGFibGVTdHJlYW0iLCJjb25maWciLCJkYXRhIiwiUmVhZGFibGUiLCJpc0F1dGhFcnIiLCJmb3JjZVJlZnJlc2hPbkZhaWx1cmUiLCJfYSIsInN1YmplY3RUb2tlbiIsInN0c0NyZWRlbnRpYWxzT3B0aW9ucyIsImdyYW50VHlwZSIsInJlcXVlc3RlZFRva2VuVHlwZSIsInN1YmplY3RUb2tlblR5cGUiLCJzdHNSZXNwb25zZSIsImV4Y2hhbmdlVG9rZW4iLCJ1bmRlZmluZWQiLCJzb3VyY2VDcmVkRXhwaXJlRGF0ZSIsImV4cGlyeURhdGUiLCJleHBpcmVzX2luIiwiRGF0ZSIsImdldFRpbWUiLCJhc3NpZ24iLCJlbWl0IiwicmVmcmVzaF90b2tlbiIsInRva2VuX3R5cGUiLCJpZF90b2tlbiIsImRvd25zY29wZWRBY2Nlc3NUb2tlbiIsIm5vdyIsImVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/envDetect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/envDetect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2018 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getEnv = exports.clear = exports.GCPEnv = void 0;\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(action-browser)/./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/index.js\");\nvar GCPEnv;\n(function(GCPEnv) {\n    GCPEnv[\"APP_ENGINE\"] = \"APP_ENGINE\";\n    GCPEnv[\"KUBERNETES_ENGINE\"] = \"KUBERNETES_ENGINE\";\n    GCPEnv[\"CLOUD_FUNCTIONS\"] = \"CLOUD_FUNCTIONS\";\n    GCPEnv[\"COMPUTE_ENGINE\"] = \"COMPUTE_ENGINE\";\n    GCPEnv[\"CLOUD_RUN\"] = \"CLOUD_RUN\";\n    GCPEnv[\"NONE\"] = \"NONE\";\n})(GCPEnv || (exports.GCPEnv = GCPEnv = {}));\nlet envPromise;\nfunction clear() {\n    envPromise = undefined;\n}\nexports.clear = clear;\nasync function getEnv() {\n    if (envPromise) {\n        return envPromise;\n    }\n    envPromise = getEnvMemoized();\n    return envPromise;\n}\nexports.getEnv = getEnv;\nasync function getEnvMemoized() {\n    let env = GCPEnv.NONE;\n    if (isAppEngine()) {\n        env = GCPEnv.APP_ENGINE;\n    } else if (isCloudFunction()) {\n        env = GCPEnv.CLOUD_FUNCTIONS;\n    } else if (await isComputeEngine()) {\n        if (await isKubernetesEngine()) {\n            env = GCPEnv.KUBERNETES_ENGINE;\n        } else if (isCloudRun()) {\n            env = GCPEnv.CLOUD_RUN;\n        } else {\n            env = GCPEnv.COMPUTE_ENGINE;\n        }\n    } else {\n        env = GCPEnv.NONE;\n    }\n    return env;\n}\nfunction isAppEngine() {\n    return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);\n}\nfunction isCloudFunction() {\n    return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);\n}\n/**\n * This check only verifies that the environment is running knative.\n * This must be run *after* checking for Kubernetes, otherwise it will\n * return a false positive.\n */ function isCloudRun() {\n    return !!process.env.K_CONFIGURATION;\n}\nasync function isKubernetesEngine() {\n    try {\n        await gcpMetadata.instance(\"attributes/cluster-name\");\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nasync function isComputeEngine() {\n    return gcpMetadata.isAvailable();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2VudkRldGVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0EsYUFBYSxHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUN2RCxNQUFNSyxjQUFjQyxtQkFBT0EsQ0FBQyxzSEFBYztBQUMxQyxJQUFJRjtBQUNILFVBQVVBLE1BQU07SUFDYkEsTUFBTSxDQUFDLGFBQWEsR0FBRztJQUN2QkEsTUFBTSxDQUFDLG9CQUFvQixHQUFHO0lBQzlCQSxNQUFNLENBQUMsa0JBQWtCLEdBQUc7SUFDNUJBLE1BQU0sQ0FBQyxpQkFBaUIsR0FBRztJQUMzQkEsTUFBTSxDQUFDLFlBQVksR0FBRztJQUN0QkEsTUFBTSxDQUFDLE9BQU8sR0FBRztBQUNyQixHQUFHQSxVQUFXSixDQUFBQSxjQUFjLEdBQUdJLFNBQVMsQ0FBQztBQUN6QyxJQUFJRztBQUNKLFNBQVNKO0lBQ0xJLGFBQWFDO0FBQ2pCO0FBQ0FSLGFBQWEsR0FBR0c7QUFDaEIsZUFBZUQ7SUFDWCxJQUFJSyxZQUFZO1FBQ1osT0FBT0E7SUFDWDtJQUNBQSxhQUFhRTtJQUNiLE9BQU9GO0FBQ1g7QUFDQVAsY0FBYyxHQUFHRTtBQUNqQixlQUFlTztJQUNYLElBQUlDLE1BQU1OLE9BQU9PLElBQUk7SUFDckIsSUFBSUMsZUFBZTtRQUNmRixNQUFNTixPQUFPUyxVQUFVO0lBQzNCLE9BQ0ssSUFBSUMsbUJBQW1CO1FBQ3hCSixNQUFNTixPQUFPVyxlQUFlO0lBQ2hDLE9BQ0ssSUFBSSxNQUFNQyxtQkFBbUI7UUFDOUIsSUFBSSxNQUFNQyxzQkFBc0I7WUFDNUJQLE1BQU1OLE9BQU9jLGlCQUFpQjtRQUNsQyxPQUNLLElBQUlDLGNBQWM7WUFDbkJULE1BQU1OLE9BQU9nQixTQUFTO1FBQzFCLE9BQ0s7WUFDRFYsTUFBTU4sT0FBT2lCLGNBQWM7UUFDL0I7SUFDSixPQUNLO1FBQ0RYLE1BQU1OLE9BQU9PLElBQUk7SUFDckI7SUFDQSxPQUFPRDtBQUNYO0FBQ0EsU0FBU0U7SUFDTCxPQUFPLENBQUMsQ0FBRVUsQ0FBQUEsUUFBUVosR0FBRyxDQUFDYSxXQUFXLElBQUlELFFBQVFaLEdBQUcsQ0FBQ2MsZUFBZTtBQUNwRTtBQUNBLFNBQVNWO0lBQ0wsT0FBTyxDQUFDLENBQUVRLENBQUFBLFFBQVFaLEdBQUcsQ0FBQ2UsYUFBYSxJQUFJSCxRQUFRWixHQUFHLENBQUNnQixlQUFlO0FBQ3RFO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNQO0lBQ0wsT0FBTyxDQUFDLENBQUNHLFFBQVFaLEdBQUcsQ0FBQ2lCLGVBQWU7QUFDeEM7QUFDQSxlQUFlVjtJQUNYLElBQUk7UUFDQSxNQUFNWixZQUFZdUIsUUFBUSxDQUFDO1FBQzNCLE9BQU87SUFDWCxFQUNBLE9BQU9DLEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSjtBQUNBLGVBQWViO0lBQ1gsT0FBT1gsWUFBWXlCLFdBQVc7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9lbnZEZXRlY3QuanM/Y2UzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFbnYgPSBleHBvcnRzLmNsZWFyID0gZXhwb3J0cy5HQ1BFbnYgPSB2b2lkIDA7XG5jb25zdCBnY3BNZXRhZGF0YSA9IHJlcXVpcmUoXCJnY3AtbWV0YWRhdGFcIik7XG52YXIgR0NQRW52O1xuKGZ1bmN0aW9uIChHQ1BFbnYpIHtcbiAgICBHQ1BFbnZbXCJBUFBfRU5HSU5FXCJdID0gXCJBUFBfRU5HSU5FXCI7XG4gICAgR0NQRW52W1wiS1VCRVJORVRFU19FTkdJTkVcIl0gPSBcIktVQkVSTkVURVNfRU5HSU5FXCI7XG4gICAgR0NQRW52W1wiQ0xPVURfRlVOQ1RJT05TXCJdID0gXCJDTE9VRF9GVU5DVElPTlNcIjtcbiAgICBHQ1BFbnZbXCJDT01QVVRFX0VOR0lORVwiXSA9IFwiQ09NUFVURV9FTkdJTkVcIjtcbiAgICBHQ1BFbnZbXCJDTE9VRF9SVU5cIl0gPSBcIkNMT1VEX1JVTlwiO1xuICAgIEdDUEVudltcIk5PTkVcIl0gPSBcIk5PTkVcIjtcbn0pKEdDUEVudiB8fCAoZXhwb3J0cy5HQ1BFbnYgPSBHQ1BFbnYgPSB7fSkpO1xubGV0IGVudlByb21pc2U7XG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgICBlbnZQcm9taXNlID0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5jbGVhciA9IGNsZWFyO1xuYXN5bmMgZnVuY3Rpb24gZ2V0RW52KCkge1xuICAgIGlmIChlbnZQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBlbnZQcm9taXNlO1xuICAgIH1cbiAgICBlbnZQcm9taXNlID0gZ2V0RW52TWVtb2l6ZWQoKTtcbiAgICByZXR1cm4gZW52UHJvbWlzZTtcbn1cbmV4cG9ydHMuZ2V0RW52ID0gZ2V0RW52O1xuYXN5bmMgZnVuY3Rpb24gZ2V0RW52TWVtb2l6ZWQoKSB7XG4gICAgbGV0IGVudiA9IEdDUEVudi5OT05FO1xuICAgIGlmIChpc0FwcEVuZ2luZSgpKSB7XG4gICAgICAgIGVudiA9IEdDUEVudi5BUFBfRU5HSU5FO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Nsb3VkRnVuY3Rpb24oKSkge1xuICAgICAgICBlbnYgPSBHQ1BFbnYuQ0xPVURfRlVOQ1RJT05TO1xuICAgIH1cbiAgICBlbHNlIGlmIChhd2FpdCBpc0NvbXB1dGVFbmdpbmUoKSkge1xuICAgICAgICBpZiAoYXdhaXQgaXNLdWJlcm5ldGVzRW5naW5lKCkpIHtcbiAgICAgICAgICAgIGVudiA9IEdDUEVudi5LVUJFUk5FVEVTX0VOR0lORTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Nsb3VkUnVuKCkpIHtcbiAgICAgICAgICAgIGVudiA9IEdDUEVudi5DTE9VRF9SVU47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbnYgPSBHQ1BFbnYuQ09NUFVURV9FTkdJTkU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVudiA9IEdDUEVudi5OT05FO1xuICAgIH1cbiAgICByZXR1cm4gZW52O1xufVxuZnVuY3Rpb24gaXNBcHBFbmdpbmUoKSB7XG4gICAgcmV0dXJuICEhKHByb2Nlc3MuZW52LkdBRV9TRVJWSUNFIHx8IHByb2Nlc3MuZW52LkdBRV9NT0RVTEVfTkFNRSk7XG59XG5mdW5jdGlvbiBpc0Nsb3VkRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhKHByb2Nlc3MuZW52LkZVTkNUSU9OX05BTUUgfHwgcHJvY2Vzcy5lbnYuRlVOQ1RJT05fVEFSR0VUKTtcbn1cbi8qKlxuICogVGhpcyBjaGVjayBvbmx5IHZlcmlmaWVzIHRoYXQgdGhlIGVudmlyb25tZW50IGlzIHJ1bm5pbmcga25hdGl2ZS5cbiAqIFRoaXMgbXVzdCBiZSBydW4gKmFmdGVyKiBjaGVja2luZyBmb3IgS3ViZXJuZXRlcywgb3RoZXJ3aXNlIGl0IHdpbGxcbiAqIHJldHVybiBhIGZhbHNlIHBvc2l0aXZlLlxuICovXG5mdW5jdGlvbiBpc0Nsb3VkUnVuKCkge1xuICAgIHJldHVybiAhIXByb2Nlc3MuZW52LktfQ09ORklHVVJBVElPTjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGlzS3ViZXJuZXRlc0VuZ2luZSgpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBnY3BNZXRhZGF0YS5pbnN0YW5jZSgnYXR0cmlidXRlcy9jbHVzdGVyLW5hbWUnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpc0NvbXB1dGVFbmdpbmUoKSB7XG4gICAgcmV0dXJuIGdjcE1ldGFkYXRhLmlzQXZhaWxhYmxlKCk7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRFbnYiLCJjbGVhciIsIkdDUEVudiIsImdjcE1ldGFkYXRhIiwicmVxdWlyZSIsImVudlByb21pc2UiLCJ1bmRlZmluZWQiLCJnZXRFbnZNZW1vaXplZCIsImVudiIsIk5PTkUiLCJpc0FwcEVuZ2luZSIsIkFQUF9FTkdJTkUiLCJpc0Nsb3VkRnVuY3Rpb24iLCJDTE9VRF9GVU5DVElPTlMiLCJpc0NvbXB1dGVFbmdpbmUiLCJpc0t1YmVybmV0ZXNFbmdpbmUiLCJLVUJFUk5FVEVTX0VOR0lORSIsImlzQ2xvdWRSdW4iLCJDTE9VRF9SVU4iLCJDT01QVVRFX0VOR0lORSIsInByb2Nlc3MiLCJHQUVfU0VSVklDRSIsIkdBRV9NT0RVTEVfTkFNRSIsIkZVTkNUSU9OX05BTUUiLCJGVU5DVElPTl9UQVJHRVQiLCJLX0NPTkZJR1VSQVRJT04iLCJpbnN0YW5jZSIsImUiLCJpc0F2YWlsYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/envDetect.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/executable-response.js":
/*!********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/executable-response.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidSubjectTokenError = exports.InvalidMessageFieldError = exports.InvalidCodeFieldError = exports.InvalidTokenTypeFieldError = exports.InvalidExpirationTimeFieldError = exports.InvalidSuccessFieldError = exports.InvalidVersionFieldError = exports.ExecutableResponseError = exports.ExecutableResponse = void 0;\nconst SAML_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:saml2\";\nconst OIDC_SUBJECT_TOKEN_TYPE1 = \"urn:ietf:params:oauth:token-type:id_token\";\nconst OIDC_SUBJECT_TOKEN_TYPE2 = \"urn:ietf:params:oauth:token-type:jwt\";\n/**\n * Defines the response of a 3rd party executable run by the pluggable auth client.\n */ class ExecutableResponse {\n    /**\n     * Instantiates an ExecutableResponse instance using the provided JSON object\n     * from the output of the executable.\n     * @param responseJson Response from a 3rd party executable, loaded from a\n     * run of the executable or a cached output file.\n     */ constructor(responseJson){\n        // Check that the required fields exist in the json response.\n        if (!responseJson.version) {\n            throw new InvalidVersionFieldError(\"Executable response must contain a 'version' field.\");\n        }\n        if (responseJson.success === undefined) {\n            throw new InvalidSuccessFieldError(\"Executable response must contain a 'success' field.\");\n        }\n        this.version = responseJson.version;\n        this.success = responseJson.success;\n        // Validate required fields for a successful response.\n        if (this.success) {\n            this.expirationTime = responseJson.expiration_time;\n            this.tokenType = responseJson.token_type;\n            // Validate token type field.\n            if (this.tokenType !== SAML_SUBJECT_TOKEN_TYPE && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE1 && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE2) {\n                throw new InvalidTokenTypeFieldError(\"Executable response must contain a 'token_type' field when successful \" + `and it must be one of ${OIDC_SUBJECT_TOKEN_TYPE1}, ${OIDC_SUBJECT_TOKEN_TYPE2}, or ${SAML_SUBJECT_TOKEN_TYPE}.`);\n            }\n            // Validate subject token.\n            if (this.tokenType === SAML_SUBJECT_TOKEN_TYPE) {\n                if (!responseJson.saml_response) {\n                    throw new InvalidSubjectTokenError(`Executable response must contain a 'saml_response' field when token_type=${SAML_SUBJECT_TOKEN_TYPE}.`);\n                }\n                this.subjectToken = responseJson.saml_response;\n            } else {\n                if (!responseJson.id_token) {\n                    throw new InvalidSubjectTokenError(\"Executable response must contain a 'id_token' field when \" + `token_type=${OIDC_SUBJECT_TOKEN_TYPE1} or ${OIDC_SUBJECT_TOKEN_TYPE2}.`);\n                }\n                this.subjectToken = responseJson.id_token;\n            }\n        } else {\n            // Both code and message must be provided for unsuccessful responses.\n            if (!responseJson.code) {\n                throw new InvalidCodeFieldError(\"Executable response must contain a 'code' field when unsuccessful.\");\n            }\n            if (!responseJson.message) {\n                throw new InvalidMessageFieldError(\"Executable response must contain a 'message' field when unsuccessful.\");\n            }\n            this.errorCode = responseJson.code;\n            this.errorMessage = responseJson.message;\n        }\n    }\n    /**\n     * @return A boolean representing if the response has a valid token. Returns\n     * true when the response was successful and the token is not expired.\n     */ isValid() {\n        return !this.isExpired() && this.success;\n    }\n    /**\n     * @return A boolean representing if the response is expired. Returns true if the\n     * provided timeout has passed.\n     */ isExpired() {\n        return this.expirationTime !== undefined && this.expirationTime < Math.round(Date.now() / 1000);\n    }\n}\nexports.ExecutableResponse = ExecutableResponse;\n/**\n * An error thrown by the ExecutableResponse class.\n */ class ExecutableResponseError extends Error {\n    constructor(message){\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.ExecutableResponseError = ExecutableResponseError;\n/**\n * An error thrown when the 'version' field in an executable response is missing or invalid.\n */ class InvalidVersionFieldError extends ExecutableResponseError {\n}\nexports.InvalidVersionFieldError = InvalidVersionFieldError;\n/**\n * An error thrown when the 'success' field in an executable response is missing or invalid.\n */ class InvalidSuccessFieldError extends ExecutableResponseError {\n}\nexports.InvalidSuccessFieldError = InvalidSuccessFieldError;\n/**\n * An error thrown when the 'expiration_time' field in an executable response is missing or invalid.\n */ class InvalidExpirationTimeFieldError extends ExecutableResponseError {\n}\nexports.InvalidExpirationTimeFieldError = InvalidExpirationTimeFieldError;\n/**\n * An error thrown when the 'token_type' field in an executable response is missing or invalid.\n */ class InvalidTokenTypeFieldError extends ExecutableResponseError {\n}\nexports.InvalidTokenTypeFieldError = InvalidTokenTypeFieldError;\n/**\n * An error thrown when the 'code' field in an executable response is missing or invalid.\n */ class InvalidCodeFieldError extends ExecutableResponseError {\n}\nexports.InvalidCodeFieldError = InvalidCodeFieldError;\n/**\n * An error thrown when the 'message' field in an executable response is missing or invalid.\n */ class InvalidMessageFieldError extends ExecutableResponseError {\n}\nexports.InvalidMessageFieldError = InvalidMessageFieldError;\n/**\n * An error thrown when the subject token in an executable response is missing or invalid.\n */ class InvalidSubjectTokenError extends ExecutableResponseError {\n}\nexports.InvalidSubjectTokenError = InvalidSubjectTokenError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2V4ZWN1dGFibGUtcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBR0EsZ0NBQWdDLEdBQUdBLDZCQUE2QixHQUFHQSxrQ0FBa0MsR0FBR0EsdUNBQXVDLEdBQUdBLGdDQUFnQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsK0JBQStCLEdBQUdBLDBCQUEwQixHQUFHLEtBQUs7QUFDL1QsTUFBTVcsMEJBQTBCO0FBQ2hDLE1BQU1DLDJCQUEyQjtBQUNqQyxNQUFNQywyQkFBMkI7QUFDakM7O0NBRUMsR0FDRCxNQUFNSDtJQUNGOzs7OztLQUtDLEdBQ0RJLFlBQVlDLFlBQVksQ0FBRTtRQUN0Qiw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDQSxhQUFhQyxPQUFPLEVBQUU7WUFDdkIsTUFBTSxJQUFJUix5QkFBeUI7UUFDdkM7UUFDQSxJQUFJTyxhQUFhRSxPQUFPLEtBQUtDLFdBQVc7WUFDcEMsTUFBTSxJQUFJWCx5QkFBeUI7UUFDdkM7UUFDQSxJQUFJLENBQUNTLE9BQU8sR0FBR0QsYUFBYUMsT0FBTztRQUNuQyxJQUFJLENBQUNDLE9BQU8sR0FBR0YsYUFBYUUsT0FBTztRQUNuQyxzREFBc0Q7UUFDdEQsSUFBSSxJQUFJLENBQUNBLE9BQU8sRUFBRTtZQUNkLElBQUksQ0FBQ0UsY0FBYyxHQUFHSixhQUFhSyxlQUFlO1lBQ2xELElBQUksQ0FBQ0MsU0FBUyxHQUFHTixhQUFhTyxVQUFVO1lBQ3hDLDZCQUE2QjtZQUM3QixJQUFJLElBQUksQ0FBQ0QsU0FBUyxLQUFLViwyQkFDbkIsSUFBSSxDQUFDVSxTQUFTLEtBQUtULDRCQUNuQixJQUFJLENBQUNTLFNBQVMsS0FBS1IsMEJBQTBCO2dCQUM3QyxNQUFNLElBQUlSLDJCQUEyQiwyRUFDakMsQ0FBQyxzQkFBc0IsRUFBRU8seUJBQXlCLEVBQUUsRUFBRUMseUJBQXlCLEtBQUssRUFBRUYsd0JBQXdCLENBQUMsQ0FBQztZQUN4SDtZQUNBLDBCQUEwQjtZQUMxQixJQUFJLElBQUksQ0FBQ1UsU0FBUyxLQUFLVix5QkFBeUI7Z0JBQzVDLElBQUksQ0FBQ0ksYUFBYVEsYUFBYSxFQUFFO29CQUM3QixNQUFNLElBQUlyQix5QkFBeUIsQ0FBQyx5RUFBeUUsRUFBRVMsd0JBQXdCLENBQUMsQ0FBQztnQkFDN0k7Z0JBQ0EsSUFBSSxDQUFDYSxZQUFZLEdBQUdULGFBQWFRLGFBQWE7WUFDbEQsT0FDSztnQkFDRCxJQUFJLENBQUNSLGFBQWFVLFFBQVEsRUFBRTtvQkFDeEIsTUFBTSxJQUFJdkIseUJBQXlCLDhEQUMvQixDQUFDLFdBQVcsRUFBRVUseUJBQXlCLElBQUksRUFBRUMseUJBQXlCLENBQUMsQ0FBQztnQkFDaEY7Z0JBQ0EsSUFBSSxDQUFDVyxZQUFZLEdBQUdULGFBQWFVLFFBQVE7WUFDN0M7UUFDSixPQUNLO1lBQ0QscUVBQXFFO1lBQ3JFLElBQUksQ0FBQ1YsYUFBYVcsSUFBSSxFQUFFO2dCQUNwQixNQUFNLElBQUl0QixzQkFBc0I7WUFDcEM7WUFDQSxJQUFJLENBQUNXLGFBQWFZLE9BQU8sRUFBRTtnQkFDdkIsTUFBTSxJQUFJeEIseUJBQXlCO1lBQ3ZDO1lBQ0EsSUFBSSxDQUFDeUIsU0FBUyxHQUFHYixhQUFhVyxJQUFJO1lBQ2xDLElBQUksQ0FBQ0csWUFBWSxHQUFHZCxhQUFhWSxPQUFPO1FBQzVDO0lBQ0o7SUFDQTs7O0tBR0MsR0FDREcsVUFBVTtRQUNOLE9BQU8sQ0FBQyxJQUFJLENBQUNDLFNBQVMsTUFBTSxJQUFJLENBQUNkLE9BQU87SUFDNUM7SUFDQTs7O0tBR0MsR0FDRGMsWUFBWTtRQUNSLE9BQVEsSUFBSSxDQUFDWixjQUFjLEtBQUtELGFBQzVCLElBQUksQ0FBQ0MsY0FBYyxHQUFHYSxLQUFLQyxLQUFLLENBQUNDLEtBQUtDLEdBQUcsS0FBSztJQUN0RDtBQUNKO0FBQ0FuQywwQkFBMEIsR0FBR1U7QUFDN0I7O0NBRUMsR0FDRCxNQUFNRCxnQ0FBZ0MyQjtJQUNsQ3RCLFlBQVlhLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ043QixPQUFPdUMsY0FBYyxDQUFDLElBQUksRUFBRSxXQUFXQyxTQUFTO0lBQ3BEO0FBQ0o7QUFDQXRDLCtCQUErQixHQUFHUztBQUNsQzs7Q0FFQyxHQUNELE1BQU1ELGlDQUFpQ0M7QUFDdkM7QUFDQVQsZ0NBQWdDLEdBQUdRO0FBQ25DOztDQUVDLEdBQ0QsTUFBTUQsaUNBQWlDRTtBQUN2QztBQUNBVCxnQ0FBZ0MsR0FBR087QUFDbkM7O0NBRUMsR0FDRCxNQUFNRCx3Q0FBd0NHO0FBQzlDO0FBQ0FULHVDQUF1QyxHQUFHTTtBQUMxQzs7Q0FFQyxHQUNELE1BQU1ELG1DQUFtQ0k7QUFDekM7QUFDQVQsa0NBQWtDLEdBQUdLO0FBQ3JDOztDQUVDLEdBQ0QsTUFBTUQsOEJBQThCSztBQUNwQztBQUNBVCw2QkFBNkIsR0FBR0k7QUFDaEM7O0NBRUMsR0FDRCxNQUFNRCxpQ0FBaUNNO0FBQ3ZDO0FBQ0FULGdDQUFnQyxHQUFHRztBQUNuQzs7Q0FFQyxHQUNELE1BQU1ELGlDQUFpQ087QUFDdkM7QUFDQVQsZ0NBQWdDLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvdGlmeS10by15b3V0dWJlLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXhlY3V0YWJsZS1yZXNwb25zZS5qcz9kNTg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludmFsaWRTdWJqZWN0VG9rZW5FcnJvciA9IGV4cG9ydHMuSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ29kZUZpZWxkRXJyb3IgPSBleHBvcnRzLkludmFsaWRUb2tlblR5cGVGaWVsZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkU3VjY2Vzc0ZpZWxkRXJyb3IgPSBleHBvcnRzLkludmFsaWRWZXJzaW9uRmllbGRFcnJvciA9IGV4cG9ydHMuRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IgPSBleHBvcnRzLkV4ZWN1dGFibGVSZXNwb25zZSA9IHZvaWQgMDtcbmNvbnN0IFNBTUxfU1VCSkVDVF9UT0tFTl9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOnNhbWwyJztcbmNvbnN0IE9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTppZF90b2tlbic7XG5jb25zdCBPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTIgPSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6and0Jztcbi8qKlxuICogRGVmaW5lcyB0aGUgcmVzcG9uc2Ugb2YgYSAzcmQgcGFydHkgZXhlY3V0YWJsZSBydW4gYnkgdGhlIHBsdWdnYWJsZSBhdXRoIGNsaWVudC5cbiAqL1xuY2xhc3MgRXhlY3V0YWJsZVJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gRXhlY3V0YWJsZVJlc3BvbnNlIGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OIG9iamVjdFxuICAgICAqIGZyb20gdGhlIG91dHB1dCBvZiB0aGUgZXhlY3V0YWJsZS5cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VKc29uIFJlc3BvbnNlIGZyb20gYSAzcmQgcGFydHkgZXhlY3V0YWJsZSwgbG9hZGVkIGZyb20gYVxuICAgICAqIHJ1biBvZiB0aGUgZXhlY3V0YWJsZSBvciBhIGNhY2hlZCBvdXRwdXQgZmlsZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZUpzb24pIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcmVxdWlyZWQgZmllbGRzIGV4aXN0IGluIHRoZSBqc29uIHJlc3BvbnNlLlxuICAgICAgICBpZiAoIXJlc3BvbnNlSnNvbi52ZXJzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZlcnNpb25GaWVsZEVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAndmVyc2lvbicgZmllbGQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZUpzb24uc3VjY2VzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN1Y2Nlc3NGaWVsZEVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAnc3VjY2VzcycgZmllbGQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHJlc3BvbnNlSnNvbi52ZXJzaW9uO1xuICAgICAgICB0aGlzLnN1Y2Nlc3MgPSByZXNwb25zZUpzb24uc3VjY2VzcztcbiAgICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzIGZvciBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAgICAgIGlmICh0aGlzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSByZXNwb25zZUpzb24uZXhwaXJhdGlvbl90aW1lO1xuICAgICAgICAgICAgdGhpcy50b2tlblR5cGUgPSByZXNwb25zZUpzb24udG9rZW5fdHlwZTtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRva2VuIHR5cGUgZmllbGQuXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlblR5cGUgIT09IFNBTUxfU1VCSkVDVF9UT0tFTl9UWVBFICYmXG4gICAgICAgICAgICAgICAgdGhpcy50b2tlblR5cGUgIT09IE9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMSAmJlxuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5UeXBlICE9PSBPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3IoXCJFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICd0b2tlbl90eXBlJyBmaWVsZCB3aGVuIHN1Y2Nlc3NmdWwgXCIgK1xuICAgICAgICAgICAgICAgICAgICBgYW5kIGl0IG11c3QgYmUgb25lIG9mICR7T0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUxfSwgJHtPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTJ9LCBvciAke1NBTUxfU1VCSkVDVF9UT0tFTl9UWVBFfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHN1YmplY3QgdG9rZW4uXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlblR5cGUgPT09IFNBTUxfU1VCSkVDVF9UT0tFTl9UWVBFKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZUpzb24uc2FtbF9yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN1YmplY3RUb2tlbkVycm9yKGBFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICdzYW1sX3Jlc3BvbnNlJyBmaWVsZCB3aGVuIHRva2VuX3R5cGU9JHtTQU1MX1NVQkpFQ1RfVE9LRU5fVFlQRX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3ViamVjdFRva2VuID0gcmVzcG9uc2VKc29uLnNhbWxfcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlSnNvbi5pZF90b2tlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN1YmplY3RUb2tlbkVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAnaWRfdG9rZW4nIGZpZWxkIHdoZW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHRva2VuX3R5cGU9JHtPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTF9IG9yICR7T0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUyfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJqZWN0VG9rZW4gPSByZXNwb25zZUpzb24uaWRfdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBCb3RoIGNvZGUgYW5kIG1lc3NhZ2UgbXVzdCBiZSBwcm92aWRlZCBmb3IgdW5zdWNjZXNzZnVsIHJlc3BvbnNlcy5cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VKc29uLmNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvZGVGaWVsZEVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAnY29kZScgZmllbGQgd2hlbiB1bnN1Y2Nlc3NmdWwuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUpzb24ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3IoXCJFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICdtZXNzYWdlJyBmaWVsZCB3aGVuIHVuc3VjY2Vzc2Z1bC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yQ29kZSA9IHJlc3BvbnNlSnNvbi5jb2RlO1xuICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSByZXNwb25zZUpzb24ubWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgaWYgdGhlIHJlc3BvbnNlIGhhcyBhIHZhbGlkIHRva2VuLiBSZXR1cm5zXG4gICAgICogdHJ1ZSB3aGVuIHRoZSByZXNwb25zZSB3YXMgc3VjY2Vzc2Z1bCBhbmQgdGhlIHRva2VuIGlzIG5vdCBleHBpcmVkLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0V4cGlyZWQoKSAmJiB0aGlzLnN1Y2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gQSBib29sZWFuIHJlcHJlc2VudGluZyBpZiB0aGUgcmVzcG9uc2UgaXMgZXhwaXJlZC4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgICAqIHByb3ZpZGVkIHRpbWVvdXQgaGFzIHBhc3NlZC5cbiAgICAgKi9cbiAgICBpc0V4cGlyZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5leHBpcmF0aW9uVGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmV4cGlyYXRpb25UaW1lIDwgTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhlY3V0YWJsZVJlc3BvbnNlID0gRXhlY3V0YWJsZVJlc3BvbnNlO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gYnkgdGhlIEV4ZWN1dGFibGVSZXNwb25zZSBjbGFzcy5cbiAqL1xuY2xhc3MgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yID0gRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3I7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIHRoZSAndmVyc2lvbicgZmllbGQgaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRWZXJzaW9uRmllbGRFcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFZlcnNpb25GaWVsZEVycm9yID0gSW52YWxpZFZlcnNpb25GaWVsZEVycm9yO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgJ3N1Y2Nlc3MnIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkU3VjY2Vzc0ZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRTdWNjZXNzRmllbGRFcnJvciA9IEludmFsaWRTdWNjZXNzRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlICdleHBpcmF0aW9uX3RpbWUnIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yIGV4dGVuZHMgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yID0gSW52YWxpZEV4cGlyYXRpb25UaW1lRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlICd0b2tlbl90eXBlJyBmaWVsZCBpbiBhbiBleGVjdXRhYmxlIHJlc3BvbnNlIGlzIG1pc3Npbmcgb3IgaW52YWxpZC5cbiAqL1xuY2xhc3MgSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRUb2tlblR5cGVGaWVsZEVycm9yID0gSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3I7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIHRoZSAnY29kZScgZmllbGQgaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRDb2RlRmllbGRFcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZENvZGVGaWVsZEVycm9yID0gSW52YWxpZENvZGVGaWVsZEVycm9yO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgJ21lc3NhZ2UnIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRNZXNzYWdlRmllbGRFcnJvciA9IEludmFsaWRNZXNzYWdlRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlIHN1YmplY3QgdG9rZW4gaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRTdWJqZWN0VG9rZW5FcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFN1YmplY3RUb2tlbkVycm9yID0gSW52YWxpZFN1YmplY3RUb2tlbkVycm9yO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW52YWxpZFN1YmplY3RUb2tlbkVycm9yIiwiSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yIiwiSW52YWxpZENvZGVGaWVsZEVycm9yIiwiSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3IiLCJJbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yIiwiSW52YWxpZFN1Y2Nlc3NGaWVsZEVycm9yIiwiSW52YWxpZFZlcnNpb25GaWVsZEVycm9yIiwiRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IiLCJFeGVjdXRhYmxlUmVzcG9uc2UiLCJTQU1MX1NVQkpFQ1RfVE9LRU5fVFlQRSIsIk9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMSIsIk9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMiIsImNvbnN0cnVjdG9yIiwicmVzcG9uc2VKc29uIiwidmVyc2lvbiIsInN1Y2Nlc3MiLCJ1bmRlZmluZWQiLCJleHBpcmF0aW9uVGltZSIsImV4cGlyYXRpb25fdGltZSIsInRva2VuVHlwZSIsInRva2VuX3R5cGUiLCJzYW1sX3Jlc3BvbnNlIiwic3ViamVjdFRva2VuIiwiaWRfdG9rZW4iLCJjb2RlIiwibWVzc2FnZSIsImVycm9yQ29kZSIsImVycm9yTWVzc2FnZSIsImlzVmFsaWQiLCJpc0V4cGlyZWQiLCJNYXRoIiwicm91bmQiLCJEYXRlIiwibm93IiwiRXJyb3IiLCJzZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/executable-response.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst oauth2common_1 = __webpack_require__(/*! ./oauth2common */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(action-browser)/./node_modules/gaxios/build/src/index.js\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n/**\n * The credentials JSON file type for external account authorized user clients.\n */ exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = \"external_account_authorized_user\";\n/**\n * Handler for token refresh requests sent to the token_url endpoint for external\n * authorized user credentials.\n */ class ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {\n    /**\n     * Initializes an ExternalAccountAuthorizedUserHandler instance.\n     * @param url The URL of the token refresh endpoint.\n     * @param transporter The transporter to use for the refresh request.\n     * @param clientAuthentication The client authentication credentials to use\n     *   for the refresh request.\n     */ constructor(url, transporter, clientAuthentication){\n        super(clientAuthentication);\n        this.url = url;\n        this.transporter = transporter;\n    }\n    /**\n     * Requests a new access token from the token_url endpoint using the provided\n     *   refresh token.\n     * @param refreshToken The refresh token to use to generate a new access token.\n     * @param additionalHeaders Optional additional headers to pass along the\n     *   request.\n     * @return A promise that resolves with the token refresh response containing\n     *   the requested access token and its expiration time.\n     */ async refreshToken(refreshToken, additionalHeaders) {\n        const values = new URLSearchParams({\n            grant_type: \"refresh_token\",\n            refresh_token: refreshToken\n        });\n        const headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            ...additionalHeaders\n        };\n        const opts = {\n            url: this.url,\n            method: \"POST\",\n            headers,\n            data: values.toString(),\n            responseType: \"json\"\n        };\n        // Apply OAuth client authentication.\n        this.applyClientAuthenticationOptions(opts);\n        try {\n            const response = await this.transporter.request(opts);\n            // Successful response.\n            const tokenRefreshResponse = response.data;\n            tokenRefreshResponse.res = response;\n            return tokenRefreshResponse;\n        } catch (error) {\n            // Translate error to OAuthError.\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, // Preserve other fields from the original error.\n                error);\n            }\n            // Request could fail before the server responds.\n            throw error;\n        }\n    }\n}\n/**\n * External Account Authorized User Client. This is used for OAuth2 credentials\n * sourced using external identities through Workforce Identity Federation.\n * Obtaining the initial access and refresh token can be done through the\n * Google Cloud CLI.\n */ class ExternalAccountAuthorizedUserClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates an ExternalAccountAuthorizedUserClient instances using the\n     * provided JSON object loaded from a credentials files.\n     * An error is throws if the credential is not valid.\n     * @param options The external account authorized user option object typically\n     *   from the external accoutn authorized user JSON credential file.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        super({\n            ...options,\n            ...additionalOptions\n        });\n        this.refreshToken = options.refresh_token;\n        const clientAuth = {\n            confidentialClientType: \"basic\",\n            clientId: options.client_id,\n            clientSecret: options.client_secret\n        };\n        this.externalAccountAuthorizedUserHandler = new ExternalAccountAuthorizedUserHandler(options.token_url, this.transporter, clientAuth);\n        this.cachedAccessToken = null;\n        this.quotaProjectId = options.quota_project_id;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== \"number\") {\n            this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;\n        } else {\n            this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n        if (options.universe_domain) {\n            this.universeDomain = options.universe_domain;\n        }\n    }\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res\n        };\n    }\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */ async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = requestHeaders[\"x-goog-user-project\"];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * @return A promise that resolves with the refreshed credential.\n     */ async refreshAccessTokenAsync() {\n        // Refresh the access token using the refresh token.\n        const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);\n        this.cachedAccessToken = {\n            access_token: refreshResponse.access_token,\n            expiry_date: new Date().getTime() + refreshResponse.expires_in * 1000,\n            res: refreshResponse.res\n        };\n        if (refreshResponse.refresh_token !== undefined) {\n            this.refreshToken = refreshResponse.refresh_token;\n        }\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param credentials The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */ isExpired(credentials) {\n        const now = new Date().getTime();\n        return credentials.expiry_date ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n}\nexports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2V4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkNBQTJDLEdBQUdBLDZDQUE2QyxHQUFHLEtBQUs7QUFDbkcsTUFBTUksZUFBZUMsbUJBQU9BLENBQUMsc0dBQWM7QUFDM0MsTUFBTUMsaUJBQWlCRCxtQkFBT0EsQ0FBQywwR0FBZ0I7QUFDL0MsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMseUVBQVE7QUFDakMsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsc0JBQVE7QUFDL0IsTUFBTUksdUJBQXVCSixtQkFBT0EsQ0FBQyxzSEFBc0I7QUFDM0Q7O0NBRUMsR0FDREwsNkNBQTZDLEdBQUc7QUFDaEQ7OztDQUdDLEdBQ0QsTUFBTVUsNkNBQTZDSixlQUFlSyxzQkFBc0I7SUFDcEY7Ozs7OztLQU1DLEdBQ0RDLFlBQVlDLEdBQUcsRUFBRUMsV0FBVyxFQUFFQyxvQkFBb0IsQ0FBRTtRQUNoRCxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDRixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO0lBQ3ZCO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNRSxhQUFhQSxZQUFZLEVBQUVDLGlCQUFpQixFQUFFO1FBQ2hELE1BQU1DLFNBQVMsSUFBSUMsZ0JBQWdCO1lBQy9CQyxZQUFZO1lBQ1pDLGVBQWVMO1FBQ25CO1FB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aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2V4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50LmpzPzg2ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQgPSBleHBvcnRzLkVYVEVSTkFMX0FDQ09VTlRfQVVUSE9SSVpFRF9VU0VSX1RZUEUgPSB2b2lkIDA7XG5jb25zdCBhdXRoY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoY2xpZW50XCIpO1xuY29uc3Qgb2F1dGgyY29tbW9uXzEgPSByZXF1aXJlKFwiLi9vYXV0aDJjb21tb25cIik7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgYmFzZWV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9iYXNlZXh0ZXJuYWxjbGllbnRcIik7XG4vKipcbiAqIFRoZSBjcmVkZW50aWFscyBKU09OIGZpbGUgdHlwZSBmb3IgZXh0ZXJuYWwgYWNjb3VudCBhdXRob3JpemVkIHVzZXIgY2xpZW50cy5cbiAqL1xuZXhwb3J0cy5FWFRFUk5BTF9BQ0NPVU5UX0FVVEhPUklaRURfVVNFUl9UWVBFID0gJ2V4dGVybmFsX2FjY291bnRfYXV0aG9yaXplZF91c2VyJztcbi8qKlxuICogSGFuZGxlciBmb3IgdG9rZW4gcmVmcmVzaCByZXF1ZXN0cyBzZW50IHRvIHRoZSB0b2tlbl91cmwgZW5kcG9pbnQgZm9yIGV4dGVybmFsXG4gKiBhdXRob3JpemVkIHVzZXIgY3JlZGVudGlhbHMuXG4gKi9cbmNsYXNzIEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciBleHRlbmRzIG9hdXRoMmNvbW1vbl8xLk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgb2YgdGhlIHRva2VuIHJlZnJlc2ggZW5kcG9pbnQuXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydGVyIFRoZSB0cmFuc3BvcnRlciB0byB1c2UgZm9yIHRoZSByZWZyZXNoIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGNsaWVudEF1dGhlbnRpY2F0aW9uIFRoZSBjbGllbnQgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgdG8gdXNlXG4gICAgICogICBmb3IgdGhlIHJlZnJlc2ggcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHRyYW5zcG9ydGVyLCBjbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICBzdXBlcihjbGllbnRBdXRoZW50aWNhdGlvbik7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydGVyID0gdHJhbnNwb3J0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGEgbmV3IGFjY2VzcyB0b2tlbiBmcm9tIHRoZSB0b2tlbl91cmwgZW5kcG9pbnQgdXNpbmcgdGhlIHByb3ZpZGVkXG4gICAgICogICByZWZyZXNoIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gVGhlIHJlZnJlc2ggdG9rZW4gdG8gdXNlIHRvIGdlbmVyYXRlIGEgbmV3IGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEhlYWRlcnMgT3B0aW9uYWwgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHBhc3MgYWxvbmcgdGhlXG4gICAgICogICByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdG9rZW4gcmVmcmVzaCByZXNwb25zZSBjb250YWluaW5nXG4gICAgICogICB0aGUgcmVxdWVzdGVkIGFjY2VzcyB0b2tlbiBhbmQgaXRzIGV4cGlyYXRpb24gdGltZS5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsSGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZXMudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICAvLyBBcHBseSBPQXV0aCBjbGllbnQgYXV0aGVudGljYXRpb24uXG4gICAgICAgIHRoaXMuYXBwbHlDbGllbnRBdXRoZW50aWNhdGlvbk9wdGlvbnMob3B0cyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAgICAgICAgICBjb25zdCB0b2tlblJlZnJlc2hSZXNwb25zZSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICB0b2tlblJlZnJlc2hSZXNwb25zZS5yZXMgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlblJlZnJlc2hSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBlcnJvciB0byBPQXV0aEVycm9yLlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZ2F4aW9zXzEuR2F4aW9zRXJyb3IgJiYgZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgb2F1dGgyY29tbW9uXzEuZ2V0RXJyb3JGcm9tT0F1dGhFcnJvclJlc3BvbnNlKShlcnJvci5yZXNwb25zZS5kYXRhLCBcbiAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBvdGhlciBmaWVsZHMgZnJvbSB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gICAgICAgICAgICAgICAgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVxdWVzdCBjb3VsZCBmYWlsIGJlZm9yZSB0aGUgc2VydmVyIHJlc3BvbmRzLlxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEV4dGVybmFsIEFjY291bnQgQXV0aG9yaXplZCBVc2VyIENsaWVudC4gVGhpcyBpcyB1c2VkIGZvciBPQXV0aDIgY3JlZGVudGlhbHNcbiAqIHNvdXJjZWQgdXNpbmcgZXh0ZXJuYWwgaWRlbnRpdGllcyB0aHJvdWdoIFdvcmtmb3JjZSBJZGVudGl0eSBGZWRlcmF0aW9uLlxuICogT2J0YWluaW5nIHRoZSBpbml0aWFsIGFjY2VzcyBhbmQgcmVmcmVzaCB0b2tlbiBjYW4gYmUgZG9uZSB0aHJvdWdoIHRoZVxuICogR29vZ2xlIENsb3VkIENMSS5cbiAqL1xuY2xhc3MgRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQgZXh0ZW5kcyBhdXRoY2xpZW50XzEuQXV0aENsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50IGluc3RhbmNlcyB1c2luZyB0aGVcbiAgICAgKiBwcm92aWRlZCBKU09OIG9iamVjdCBsb2FkZWQgZnJvbSBhIGNyZWRlbnRpYWxzIGZpbGVzLlxuICAgICAqIEFuIGVycm9yIGlzIHRocm93cyBpZiB0aGUgY3JlZGVudGlhbCBpcyBub3QgdmFsaWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGV4dGVybmFsIGFjY291bnQgYXV0aG9yaXplZCB1c2VyIG9wdGlvbiBvYmplY3QgdHlwaWNhbGx5XG4gICAgICogICBmcm9tIHRoZSBleHRlcm5hbCBhY2NvdXRuIGF1dGhvcml6ZWQgdXNlciBKU09OIGNyZWRlbnRpYWwgZmlsZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnMgKipERVBSRUNBVEVELCBhbGwgb3B0aW9ucyBhcmUgYXZhaWxhYmxlIGluIHRoZVxuICAgICAqICAgYG9wdGlvbnNgIHBhcmFtZXRlci4qKiBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb24gb3B0aW9ucy5cbiAgICAgKiAgIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmQgd2hldGhlciB0byByZXRyeVxuICAgICAqICAgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoeyAuLi5vcHRpb25zLCAuLi5hZGRpdGlvbmFsT3B0aW9ucyB9KTtcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBvcHRpb25zLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIGNvbnN0IGNsaWVudEF1dGggPSB7XG4gICAgICAgICAgICBjb25maWRlbnRpYWxDbGllbnRUeXBlOiAnYmFzaWMnLFxuICAgICAgICAgICAgY2xpZW50SWQ6IG9wdGlvbnMuY2xpZW50X2lkLFxuICAgICAgICAgICAgY2xpZW50U2VjcmV0OiBvcHRpb25zLmNsaWVudF9zZWNyZXQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJIYW5kbGVyID1cbiAgICAgICAgICAgIG5ldyBFeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckhhbmRsZXIob3B0aW9ucy50b2tlbl91cmwsIHRoaXMudHJhbnNwb3J0ZXIsIGNsaWVudEF1dGgpO1xuICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5xdW90YVByb2plY3RJZCA9IG9wdGlvbnMucXVvdGFfcHJvamVjdF9pZDtcbiAgICAgICAgLy8gQXMgdGhyZXNob2xkIGNvdWxkIGJlIHplcm8sXG4gICAgICAgIC8vIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyB8fCBFWFBJUkFUSU9OX1RJTUVfT0ZGU0VUIHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAgICAgIC8vIHplcm8gdmFsdWUuXG4gICAgICAgIGlmICh0eXBlb2YgKGFkZGl0aW9uYWxPcHRpb25zID09PSBudWxsIHx8IGFkZGl0aW9uYWxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZGRpdGlvbmFsT3B0aW9ucy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMpICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSBiYXNlZXh0ZXJuYWxjbGllbnRfMS5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSBhZGRpdGlvbmFsT3B0aW9uc1xuICAgICAgICAgICAgICAgIC5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUgPSAhIShhZGRpdGlvbmFsT3B0aW9ucyA9PT0gbnVsbCB8fCBhZGRpdGlvbmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRkaXRpb25hbE9wdGlvbnMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudW5pdmVyc2VfZG9tYWluKSB7XG4gICAgICAgICAgICB0aGlzLnVuaXZlcnNlRG9tYWluID0gb3B0aW9ucy51bml2ZXJzZV9kb21haW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIC8vIElmIGNhY2hlZCBhY2Nlc3MgdG9rZW4gaXMgdW5hdmFpbGFibGUgb3IgZXhwaXJlZCwgZm9yY2UgcmVmcmVzaC5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuIHx8IHRoaXMuaXNFeHBpcmVkKHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4pKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIEdDUCBhY2Nlc3MgdG9rZW4gaW4gR2V0QWNjZXNzVG9rZW5SZXNwb25zZSBmb3JtYXQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbjogdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICByZXM6IHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4ucmVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlblJlc3BvbnNlLnRva2VufWAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG4gICAgcmVxdWVzdChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIGUucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXV0aGVudGljYXRlcyB0aGUgcHJvdmlkZWQgSFRUUCByZXF1ZXN0LCBwcm9jZXNzZXMgaXQgYW5kIHJlc29sdmVzIHdpdGggdGhlXG4gICAgICogcmV0dXJuZWQgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIEhUVFAgcmVxdWVzdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSByZXRyeSBXaGV0aGVyIHRoZSBjdXJyZW50IGF0dGVtcHQgaXMgYSByZXRyeSBhZnRlciBhIGZhaWxlZCBhdHRlbXB0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0QXN5bmMob3B0cywgcmV0cnkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SGVhZGVycyAmJiByZXF1ZXN0SGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10gPVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gZS5yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICAvLyBSZXRyeSB0aGUgcmVxdWVzdCBmb3IgbWV0YWRhdGEgaWYgdGhlIGZvbGxvd2luZyBjcml0ZXJpYSBhcmUgdHJ1ZTpcbiAgICAgICAgICAgICAgICAvLyAtIFdlIGhhdmVuJ3QgYWxyZWFkeSByZXRyaWVkLiAgSXQgb25seSBtYWtlcyBzZW5zZSB0byByZXRyeSBvbmNlLlxuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlc3BvbnNlIHdhcyBhIDQwMSBvciBhIDQwM1xuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlcXVlc3QgZGlkbid0IHNlbmQgYSByZWFkYWJsZVN0cmVhbVxuICAgICAgICAgICAgICAgIC8vIC0gZm9yY2VSZWZyZXNoT25GYWlsdXJlIGlzIHRydWVcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID0gcmVzLmNvbmZpZy5kYXRhIGluc3RhbmNlb2Ygc3RyZWFtLlJlYWRhYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXV0aEVyciA9IHN0YXR1c0NvZGUgPT09IDQwMSB8fCBzdGF0dXNDb2RlID09PSA0MDM7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0F1dGhFcnIgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzUmVhZGFibGVTdHJlYW0gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0b2tlbiByZWZyZXNoLCBldmVuIGlmIHVuZXhwaXJlZCB0b2tlbnMgYXJlIGN1cnJlbnRseSBjYWNoZWQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZWZyZXNoZWQgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpIHtcbiAgICAgICAgLy8gUmVmcmVzaCB0aGUgYWNjZXNzIHRva2VuIHVzaW5nIHRoZSByZWZyZXNoIHRva2VuLlxuICAgICAgICBjb25zdCByZWZyZXNoUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlci5yZWZyZXNoVG9rZW4odGhpcy5yZWZyZXNoVG9rZW4pO1xuICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0ge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiByZWZyZXNoUmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgcmVmcmVzaFJlc3BvbnNlLmV4cGlyZXNfaW4gKiAxMDAwLFxuICAgICAgICAgICAgcmVzOiByZWZyZXNoUmVzcG9uc2UucmVzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVmcmVzaFJlc3BvbnNlLnJlZnJlc2hfdG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSByZWZyZXNoUmVzcG9uc2UucmVmcmVzaF90b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBjcmVkZW50aWFscyBhcmUgZXhwaXJlZCBvciBub3QuXG4gICAgICogSWYgdGhlcmUgaXMgbm8gZXhwaXJ5IHRpbWUsIGFzc3VtZXMgdGhlIHRva2VuIGlzIG5vdCBleHBpcmVkIG9yIGV4cGlyaW5nLlxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgY3JlZGVudGlhbHMgdG8gY2hlY2sgZm9yIGV4cGlyYXRpb24uXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoZSBjcmVkZW50aWFscyBhcmUgZXhwaXJlZCBvciBub3QuXG4gICAgICovXG4gICAgaXNFeHBpcmVkKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGVcbiAgICAgICAgICAgID8gbm93ID49IGNyZWRlbnRpYWxzLmV4cGlyeV9kYXRlIC0gdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXNcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudCA9IEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQiLCJFWFRFUk5BTF9BQ0NPVU5UX0FVVEhPUklaRURfVVNFUl9UWVBFIiwiYXV0aGNsaWVudF8xIiwicmVxdWlyZSIsIm9hdXRoMmNvbW1vbl8xIiwiZ2F4aW9zXzEiLCJzdHJlYW0iLCJiYXNlZXh0ZXJuYWxjbGllbnRfMSIsIkV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciIsIk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsInVybCIsInRyYW5zcG9ydGVyIiwiY2xpZW50QXV0aGVudGljYXRpb24iLCJyZWZyZXNoVG9rZW4iLCJhZGRpdGlvbmFsSGVhZGVycyIsInZhbHVlcyIsIlVSTFNlYXJjaFBhcmFtcyIsImdyYW50X3R5cGUiLCJyZWZyZXNoX3Rva2VuIiwiaGVhZGVycyIsIm9wdHMiLCJtZXRob2QiLCJkYXRhIiwidG9TdHJpbmciLCJyZXNwb25zZVR5cGUiLCJhcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uT3B0aW9ucyIsInJlc3BvbnNlIiwicmVxdWVzdCIsInRva2VuUmVmcmVzaFJlc3BvbnNlIiwicmVzIiwiZXJyb3IiLCJHYXhpb3NFcnJvciIsImdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSIsIkF1dGhDbGllbnQiLCJvcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJjbGllbnRBdXRoIiwiY29uZmlkZW50aWFsQ2xpZW50VHlwZSIsImNsaWVudElkIiwiY2xpZW50X2lkIiwiY2xpZW50U2VjcmV0IiwiY2xpZW50X3NlY3JldCIsImV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciIsInRva2VuX3VybCIsImNhY2hlZEFjY2Vzc1Rva2VuIiwicXVvdGFQcm9qZWN0SWQiLCJxdW90YV9wcm9qZWN0X2lkIiwiZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIiwiRVhQSVJBVElPTl9USU1FX09GRlNFVCIsImZvcmNlUmVmcmVzaE9uRmFpbHVyZSIsInVuaXZlcnNlX2RvbWFpbiIsInVuaXZlcnNlRG9tYWluIiwiZ2V0QWNjZXNzVG9rZW4iLCJpc0V4cGlyZWQiLCJyZWZyZXNoQWNjZXNzVG9rZW5Bc3luYyIsInRva2VuIiwiYWNjZXNzX3Rva2VuIiwiZ2V0UmVxdWVzdEhlYWRlcnMiLCJhY2Nlc3NUb2tlblJlc3BvbnNlIiwiQXV0aG9yaXphdGlvbiIsImFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyIsImNhbGxiYWNrIiwicmVxdWVzdEFzeW5jIiwidGhlbiIsInIiLCJlIiwicmV0cnkiLCJyZXF1ZXN0SGVhZGVycyIsInN0YXR1c0NvZGUiLCJzdGF0dXMiLCJpc1JlYWRhYmxlU3RyZWFtIiwiY29uZmlnIiwiUmVhZGFibGUiLCJpc0F1dGhFcnIiLCJyZWZyZXNoUmVzcG9uc2UiLCJleHBpcnlfZGF0ZSIsIkRhdGUiLCJnZXRUaW1lIiwiZXhwaXJlc19pbiIsInVuZGVmaW5lZCIsImNyZWRlbnRpYWxzIiwibm93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/externalclient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/externalclient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ExternalAccountClient = void 0;\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst identitypoolclient_1 = __webpack_require__(/*! ./identitypoolclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\");\nconst awsclient_1 = __webpack_require__(/*! ./awsclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/awsclient.js\");\nconst pluggable_auth_client_1 = __webpack_require__(/*! ./pluggable-auth-client */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\n/**\n * Dummy class with no constructor. Developers are expected to use fromJSON.\n */ class ExternalAccountClient {\n    constructor(){\n        throw new Error(\"ExternalAccountClients should be initialized via: \" + \"ExternalAccountClient.fromJSON(), \" + \"directly via explicit constructors, eg. \" + \"new AwsClient(options), new IdentityPoolClient(options), new\" + \"PluggableAuthClientOptions, or via \" + \"new GoogleAuth(options).getClient()\");\n    }\n    /**\n     * This static method will instantiate the\n     * corresponding type of external account credential depending on the\n     * underlying credential source.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     * @return A BaseExternalAccountClient instance or null if the options\n     *   provided do not correspond to an external account credential.\n     */ static fromJSON(options, additionalOptions) {\n        var _a, _b;\n        if (options && options.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            if ((_a = options.credential_source) === null || _a === void 0 ? void 0 : _a.environment_id) {\n                return new awsclient_1.AwsClient(options, additionalOptions);\n            } else if ((_b = options.credential_source) === null || _b === void 0 ? void 0 : _b.executable) {\n                return new pluggable_auth_client_1.PluggableAuthClient(options, additionalOptions);\n            } else {\n                return new identitypoolclient_1.IdentityPoolClient(options, additionalOptions);\n            }\n        } else {\n            return null;\n        }\n    }\n}\nexports.ExternalAccountClient = ExternalAccountClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2V4dGVybmFsY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxNQUFNRyx1QkFBdUJDLG1CQUFPQSxDQUFDLHNIQUFzQjtBQUMzRCxNQUFNQyx1QkFBdUJELG1CQUFPQSxDQUFDLHNIQUFzQjtBQUMzRCxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyxvR0FBYTtBQUN6QyxNQUFNRywwQkFBMEJILG1CQUFPQSxDQUFDLDRIQUF5QjtBQUNqRTs7Q0FFQyxHQUNELE1BQU1GO0lBQ0ZNLGFBQWM7UUFDVixNQUFNLElBQUlDLE1BQU0sdURBQ1osdUNBQ0EsNkNBQ0EsaUVBQ0Esd0NBQ0E7SUFDUjtJQUNBOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNELE9BQU9DLFNBQVNDLE9BQU8sRUFBRUMsaUJBQWlCLEVBQUU7UUFDeEMsSUFBSUMsSUFBSUM7UUFDUixJQUFJSCxXQUFXQSxRQUFRSSxJQUFJLEtBQUtaLHFCQUFxQmEscUJBQXFCLEVBQUU7WUFDeEUsSUFBSSxDQUFDSCxLQUFLRixRQUFRTSxpQkFBaUIsTUFBTSxRQUFRSixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdLLGNBQWMsRUFBRTtnQkFDekYsT0FBTyxJQUFJWixZQUFZYSxTQUFTLENBQUNSLFNBQVNDO1lBQzlDLE9BQ0ssSUFBSSxDQUFDRSxLQUFLSCxRQUFRTSxpQkFBaUIsTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdNLFVBQVUsRUFBRTtnQkFDMUYsT0FBTyxJQUFJYix3QkFBd0JjLG1CQUFtQixDQUFDVixTQUFTQztZQUNwRSxPQUNLO2dCQUNELE9BQU8sSUFBSVAscUJBQXFCaUIsa0JBQWtCLENBQUNYLFNBQVNDO1lBQ2hFO1FBQ0osT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQVosNkJBQTZCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvdGlmeS10by15b3V0dWJlLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXh0ZXJuYWxjbGllbnQuanM/OWM5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FeHRlcm5hbEFjY291bnRDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2Jhc2VleHRlcm5hbGNsaWVudFwiKTtcbmNvbnN0IGlkZW50aXR5cG9vbGNsaWVudF8xID0gcmVxdWlyZShcIi4vaWRlbnRpdHlwb29sY2xpZW50XCIpO1xuY29uc3QgYXdzY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hd3NjbGllbnRcIik7XG5jb25zdCBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3BsdWdnYWJsZS1hdXRoLWNsaWVudFwiKTtcbi8qKlxuICogRHVtbXkgY2xhc3Mgd2l0aCBubyBjb25zdHJ1Y3Rvci4gRGV2ZWxvcGVycyBhcmUgZXhwZWN0ZWQgdG8gdXNlIGZyb21KU09OLlxuICovXG5jbGFzcyBFeHRlcm5hbEFjY291bnRDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVybmFsQWNjb3VudENsaWVudHMgc2hvdWxkIGJlIGluaXRpYWxpemVkIHZpYTogJyArXG4gICAgICAgICAgICAnRXh0ZXJuYWxBY2NvdW50Q2xpZW50LmZyb21KU09OKCksICcgK1xuICAgICAgICAgICAgJ2RpcmVjdGx5IHZpYSBleHBsaWNpdCBjb25zdHJ1Y3RvcnMsIGVnLiAnICtcbiAgICAgICAgICAgICduZXcgQXdzQ2xpZW50KG9wdGlvbnMpLCBuZXcgSWRlbnRpdHlQb29sQ2xpZW50KG9wdGlvbnMpLCBuZXcnICtcbiAgICAgICAgICAgICdQbHVnZ2FibGVBdXRoQ2xpZW50T3B0aW9ucywgb3IgdmlhICcgK1xuICAgICAgICAgICAgJ25ldyBHb29nbGVBdXRoKG9wdGlvbnMpLmdldENsaWVudCgpJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgc3RhdGljIG1ldGhvZCB3aWxsIGluc3RhbnRpYXRlIHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgdHlwZSBvZiBleHRlcm5hbCBhY2NvdW50IGNyZWRlbnRpYWwgZGVwZW5kaW5nIG9uIHRoZVxuICAgICAqIHVuZGVybHlpbmcgY3JlZGVudGlhbCBzb3VyY2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGV4dGVybmFsIGFjY291bnQgb3B0aW9ucyBvYmplY3QgdHlwaWNhbGx5IGxvYWRlZFxuICAgICAqICAgZnJvbSB0aGUgZXh0ZXJuYWwgYWNjb3VudCBKU09OIGNyZWRlbnRpYWwgZmlsZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnMgKipERVBSRUNBVEVELCBhbGwgb3B0aW9ucyBhcmUgYXZhaWxhYmxlIGluIHRoZVxuICAgICAqICAgYG9wdGlvbnNgIHBhcmFtZXRlci4qKiBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb24gb3B0aW9ucy5cbiAgICAgKiAgIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmQgd2hldGhlciB0byByZXRyeVxuICAgICAqICAgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICogQHJldHVybiBBIEJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgaW5zdGFuY2Ugb3IgbnVsbCBpZiB0aGUgb3B0aW9uc1xuICAgICAqICAgcHJvdmlkZWQgZG8gbm90IGNvcnJlc3BvbmQgdG8gYW4gZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgPT09IGJhc2VleHRlcm5hbGNsaWVudF8xLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSkge1xuICAgICAgICAgICAgaWYgKChfYSA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbnZpcm9ubWVudF9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXdzY2xpZW50XzEuQXdzQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChfYiA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5leGVjdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMS5QbHVnZ2FibGVBdXRoQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaWRlbnRpdHlwb29sY2xpZW50XzEuSWRlbnRpdHlQb29sQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbEFjY291bnRDbGllbnQgPSBFeHRlcm5hbEFjY291bnRDbGllbnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJFeHRlcm5hbEFjY291bnRDbGllbnQiLCJiYXNlZXh0ZXJuYWxjbGllbnRfMSIsInJlcXVpcmUiLCJpZGVudGl0eXBvb2xjbGllbnRfMSIsImF3c2NsaWVudF8xIiwicGx1Z2dhYmxlX2F1dGhfY2xpZW50XzEiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiZnJvbUpTT04iLCJvcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJfYSIsIl9iIiwidHlwZSIsIkVYVEVSTkFMX0FDQ09VTlRfVFlQRSIsImNyZWRlbnRpYWxfc291cmNlIiwiZW52aXJvbm1lbnRfaWQiLCJBd3NDbGllbnQiLCJleGVjdXRhYmxlIiwiUGx1Z2dhYmxlQXV0aENsaWVudCIsIklkZW50aXR5UG9vbENsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/externalclient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/googleauth.js":
/*!***********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/googleauth.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(action-browser)/./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(action-browser)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(action-browser)/./node_modules/google-auth-library/build/src/transporters.js\");\nconst computeclient_1 = __webpack_require__(/*! ./computeclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/computeclient.js\");\nconst idtokenclient_1 = __webpack_require__(/*! ./idtokenclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\");\nconst envDetect_1 = __webpack_require__(/*! ./envDetect */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/envDetect.js\");\nconst jwtclient_1 = __webpack_require__(/*! ./jwtclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\");\nconst refreshclient_1 = __webpack_require__(/*! ./refreshclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\");\nconst impersonated_1 = __webpack_require__(/*! ./impersonated */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/impersonated.js\");\nconst externalclient_1 = __webpack_require__(/*! ./externalclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/externalclient.js\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst externalAccountAuthorizedUserClient_1 = __webpack_require__(/*! ./externalAccountAuthorizedUserClient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"(action-browser)/./node_modules/google-auth-library/build/src/util.js\");\nexports.CLOUD_SDK_CLIENT_ID = \"764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com\";\nconst GoogleAuthExceptionMessages = {\n    NO_PROJECT_ID_FOUND: \"Unable to detect a Project Id in the current environment. \\n\" + \"To learn more about authentication and Google APIs, visit: \\n\" + \"https://cloud.google.com/docs/authentication/getting-started\",\n    NO_CREDENTIALS_FOUND: \"Unable to find credentials in current environment. \\n\" + \"To learn more about authentication and Google APIs, visit: \\n\" + \"https://cloud.google.com/docs/authentication/getting-started\",\n    NO_UNIVERSE_DOMAIN_FOUND: \"Unable to detect a Universe Domain in the current environment.\\n\" + \"To learn more about Universe Domain retrieval, visit: \\n\" + \"https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys\"\n};\nclass GoogleAuth {\n    // Note:  this properly is only public to satisify unit tests.\n    // https://github.com/Microsoft/TypeScript/issues/5228\n    get isGCE() {\n        return this.checkIsGCE;\n    }\n    /**\n     * Configuration is resolved in the following order of precedence:\n     * - {@link GoogleAuthOptions.credentials `credentials`}\n     * - {@link GoogleAuthOptions.keyFilename `keyFilename`}\n     * - {@link GoogleAuthOptions.keyFile `keyFile`}\n     *\n     * {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the\n     * {@link AuthClient `AuthClient`s}.\n     *\n     * @param opts\n     */ constructor(opts){\n        /**\n         * Caches a value indicating whether the auth layer is running on Google\n         * Compute Engine.\n         * @private\n         */ this.checkIsGCE = undefined;\n        // To save the contents of the JSON credential file\n        this.jsonContent = null;\n        this.cachedCredential = null;\n        this.clientOptions = {};\n        opts = opts || {};\n        this._cachedProjectId = opts.projectId || null;\n        this.cachedCredential = opts.authClient || null;\n        this.keyFilename = opts.keyFilename || opts.keyFile;\n        this.scopes = opts.scopes;\n        this.jsonContent = opts.credentials || null;\n        this.clientOptions = opts.clientOptions || {};\n        if (opts.universeDomain) {\n            this.clientOptions.universeDomain = opts.universeDomain;\n        }\n    }\n    // GAPIC client libraries should always use self-signed JWTs. The following\n    // variables are set on the JWT client in order to indicate the type of library,\n    // and sign the JWT with the correct audience and scopes (if not supplied).\n    setGapicJWTValues(client) {\n        client.defaultServicePath = this.defaultServicePath;\n        client.useJWTAccessWithScope = this.useJWTAccessWithScope;\n        client.defaultScopes = this.defaultScopes;\n    }\n    getProjectId(callback) {\n        if (callback) {\n            this.getProjectIdAsync().then((r)=>callback(null, r), callback);\n        } else {\n            return this.getProjectIdAsync();\n        }\n    }\n    /**\n     * A temporary method for internal `getProjectId` usages where `null` is\n     * acceptable. In a future major release, `getProjectId` should return `null`\n     * (as the `Promise<string | null>` base signature describes) and this private\n     * method should be removed.\n     *\n     * @returns Promise that resolves with project id (or `null`)\n     */ async getProjectIdOptional() {\n        try {\n            return await this.getProjectId();\n        } catch (e) {\n            if (e instanceof Error && e.message === GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\n                return null;\n            } else {\n                throw e;\n            }\n        }\n    }\n    /*\n     * A private method for finding and caching a projectId.\n     *\n     * Supports environments in order of precedence:\n     * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n     * - GOOGLE_APPLICATION_CREDENTIALS JSON file\n     * - Cloud SDK: `gcloud config config-helper --format json`\n     * - GCE project ID from metadata server\n     *\n     * @returns projectId\n     */ async findAndCacheProjectId() {\n        let projectId = null;\n        projectId || (projectId = await this.getProductionProjectId());\n        projectId || (projectId = await this.getFileProjectId());\n        projectId || (projectId = await this.getDefaultServiceProjectId());\n        projectId || (projectId = await this.getGCEProjectId());\n        projectId || (projectId = await this.getExternalAccountClientProjectId());\n        if (projectId) {\n            this._cachedProjectId = projectId;\n            return projectId;\n        } else {\n            throw new Error(GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\n        }\n    }\n    async getProjectIdAsync() {\n        if (this._cachedProjectId) {\n            return this._cachedProjectId;\n        }\n        if (!this._findProjectIdPromise) {\n            this._findProjectIdPromise = this.findAndCacheProjectId();\n        }\n        return this._findProjectIdPromise;\n    }\n    /**\n     * Retrieves a universe domain from the metadata server via\n     * {@link gcpMetadata.universe}.\n     *\n     * @returns a universe domain\n     */ async getUniverseDomainFromMetadataServer() {\n        var _a;\n        let universeDomain;\n        try {\n            universeDomain = await gcpMetadata.universe(\"universe_domain\");\n            universeDomain || (universeDomain = authclient_1.DEFAULT_UNIVERSE);\n        } catch (e) {\n            if (e && ((_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {\n                universeDomain = authclient_1.DEFAULT_UNIVERSE;\n            } else {\n                throw e;\n            }\n        }\n        return universeDomain;\n    }\n    /**\n     * Retrieves, caches, and returns the universe domain in the following order\n     * of precedence:\n     * - The universe domain in {@link GoogleAuth.clientOptions}\n     * - An existing or ADC {@link AuthClient}'s universe domain\n     * - {@link gcpMetadata.universe}, if {@link Compute} client\n     *\n     * @returns The universe domain\n     */ async getUniverseDomain() {\n        let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get(\"universe_domain\");\n        try {\n            universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = (await this.getClient()).universeDomain;\n        } catch (_a) {\n            // client or ADC is not available\n            universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = authclient_1.DEFAULT_UNIVERSE;\n        }\n        return universeDomain;\n    }\n    /**\n     * @returns Any scopes (user-specified or default scopes specified by the\n     *   client library) that need to be set on the current Auth client.\n     */ getAnyScopes() {\n        return this.scopes || this.defaultScopes;\n    }\n    getApplicationDefault(optionsOrCallback = {}, callback) {\n        let options;\n        if (typeof optionsOrCallback === \"function\") {\n            callback = optionsOrCallback;\n        } else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.getApplicationDefaultAsync(options).then((r)=>callback(null, r.credential, r.projectId), callback);\n        } else {\n            return this.getApplicationDefaultAsync(options);\n        }\n    }\n    async getApplicationDefaultAsync(options = {}) {\n        // If we've already got a cached credential, return it.\n        // This will also preserve one's configured quota project, in case they\n        // set one directly on the credential previously.\n        if (this.cachedCredential) {\n            return await this.prepareAndCacheADC(this.cachedCredential);\n        }\n        // Since this is a 'new' ADC to cache we will use the environment variable\n        // if it's available. We prefer this value over the value from ADC.\n        const quotaProjectIdOverride = process.env[\"GOOGLE_CLOUD_QUOTA_PROJECT\"];\n        let credential;\n        // Check for the existence of a local environment variable pointing to the\n        // location of the credential file. This is typically used in local\n        // developer scenarios.\n        credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Look in the well-known credential file location.\n        credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Determine if we're running on GCE.\n        if (await this._checkIsGCE()) {\n            // set universe domain for Compute client\n            if (!(0, util_1.originalOrCamelOptions)(options).get(\"universe_domain\")) {\n                options.universeDomain = await this.getUniverseDomainFromMetadataServer();\n            }\n            options.scopes = this.getAnyScopes();\n            return await this.prepareAndCacheADC(new computeclient_1.Compute(options), quotaProjectIdOverride);\n        }\n        throw new Error(\"Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.\");\n    }\n    async prepareAndCacheADC(credential, quotaProjectIdOverride) {\n        const projectId = await this.getProjectIdOptional();\n        if (quotaProjectIdOverride) {\n            credential.quotaProjectId = quotaProjectIdOverride;\n        }\n        this.cachedCredential = credential;\n        return {\n            credential,\n            projectId\n        };\n    }\n    /**\n     * Determines whether the auth layer is running on Google Compute Engine.\n     * Checks for GCP Residency, then fallback to checking if metadata server\n     * is available.\n     *\n     * @returns A promise that resolves with the boolean.\n     * @api private\n     */ async _checkIsGCE() {\n        if (this.checkIsGCE === undefined) {\n            this.checkIsGCE = gcpMetadata.getGCPResidency() || await gcpMetadata.isAvailable();\n        }\n        return this.checkIsGCE;\n    }\n    /**\n     * Attempts to load default credentials from the environment variable path..\n     * @returns Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */ async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n        const credentialsPath = process.env[\"GOOGLE_APPLICATION_CREDENTIALS\"] || process.env[\"google_application_credentials\"];\n        if (!credentialsPath || credentialsPath.length === 0) {\n            return null;\n        }\n        try {\n            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Attempts to load default credentials from a well-known file location\n     * @return Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */ async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n        // First, figure out the location of the file, depending upon the OS type.\n        let location = null;\n        if (this._isWindows()) {\n            // Windows\n            location = process.env[\"APPDATA\"];\n        } else {\n            // Linux or Mac\n            const home = process.env[\"HOME\"];\n            if (home) {\n                location = path.join(home, \".config\");\n            }\n        }\n        // If we found the root path, expand it.\n        if (location) {\n            location = path.join(location, \"gcloud\", \"application_default_credentials.json\");\n            if (!fs.existsSync(location)) {\n                location = null;\n            }\n        }\n        // The file does not exist.\n        if (!location) {\n            return null;\n        }\n        // The file seems to exist. Try to use it.\n        const client = await this._getApplicationCredentialsFromFilePath(location, options);\n        return client;\n    }\n    /**\n     * Attempts to load default credentials from a file at the given path..\n     * @param filePath The path to the file to read.\n     * @returns Promise that resolves with the OAuth2Client\n     * @api private\n     */ async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n        // Make sure the path looks like a string.\n        if (!filePath || filePath.length === 0) {\n            throw new Error(\"The file path is invalid.\");\n        }\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = fs.realpathSync(filePath);\n            if (!fs.lstatSync(filePath).isFile()) {\n                throw new Error();\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        // Now open a read stream on the file, and parse it.\n        const readStream = fs.createReadStream(filePath);\n        return this.fromStream(readStream, options);\n    }\n    /**\n     * Create a credentials instance using a given impersonated input options.\n     * @param json The impersonated input object.\n     * @returns JWT or UserRefresh Client with data\n     */ fromImpersonatedJSON(json) {\n        var _a, _b, _c, _d, _e;\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing an  impersonated refresh token\");\n        }\n        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            throw new Error(`The incoming JSON object does not have the \"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\" type`);\n        }\n        if (!json.source_credentials) {\n            throw new Error(\"The incoming JSON object does not contain a source_credentials field\");\n        }\n        if (!json.service_account_impersonation_url) {\n            throw new Error(\"The incoming JSON object does not contain a service_account_impersonation_url field\");\n        }\n        // Create source client for impersonation\n        const sourceClient = new refreshclient_1.UserRefreshClient();\n        sourceClient.fromJSON(json.source_credentials);\n        if (((_a = json.service_account_impersonation_url) === null || _a === void 0 ? void 0 : _a.length) > 256) {\n            /**\n             * Prevents DOS attacks.\n             * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/85}\n             **/ throw new RangeError(`Target principal is too long: ${json.service_account_impersonation_url}`);\n        }\n        // Extreact service account from service_account_impersonation_url\n        const targetPrincipal = (_c = (_b = /(?<target>[^/]+):generateAccessToken$/.exec(json.service_account_impersonation_url)) === null || _b === void 0 ? void 0 : _b.groups) === null || _c === void 0 ? void 0 : _c.target;\n        if (!targetPrincipal) {\n            throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\n        }\n        const targetScopes = (_d = this.getAnyScopes()) !== null && _d !== void 0 ? _d : [];\n        const client = new impersonated_1.Impersonated({\n            ...json,\n            delegates: (_e = json.delegates) !== null && _e !== void 0 ? _e : [],\n            sourceClient: sourceClient,\n            targetPrincipal: targetPrincipal,\n            targetScopes: Array.isArray(targetScopes) ? targetScopes : [\n                targetScopes\n            ]\n        });\n        return client;\n    }\n    /**\n     * Create a credentials instance using the given input options.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */ fromJSON(json, options = {}) {\n        let client;\n        // user's preferred universe domain\n        const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get(\"universe_domain\");\n        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\n            client = new refreshclient_1.UserRefreshClient(options);\n            client.fromJSON(json);\n        } else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            client = this.fromImpersonatedJSON(json);\n        } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n            client.scopes = this.getAnyScopes();\n        } else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\n            client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\n        } else {\n            options.scopes = this.scopes;\n            client = new jwtclient_1.JWT(options);\n            this.setGapicJWTValues(client);\n            client.fromJSON(json);\n        }\n        if (preferredUniverseDomain) {\n            client.universeDomain = preferredUniverseDomain;\n        }\n        return client;\n    }\n    /**\n     * Return a JWT or UserRefreshClient from JavaScript object, caching both the\n     * object used to instantiate and the client.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */ _cacheClientFromJSON(json, options) {\n        const client = this.fromJSON(json, options);\n        // cache both raw data used to instantiate client and client itself.\n        this.jsonContent = json;\n        this.cachedCredential = client;\n        return client;\n    }\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\n        let options = {};\n        if (typeof optionsOrCallback === \"function\") {\n            callback = optionsOrCallback;\n        } else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.fromStreamAsync(inputStream, options).then((r)=>callback(null, r), callback);\n        } else {\n            return this.fromStreamAsync(inputStream, options);\n        }\n    }\n    fromStreamAsync(inputStream, options) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                throw new Error(\"Must pass in a stream containing the Google auth settings.\");\n            }\n            let s = \"\";\n            inputStream.setEncoding(\"utf8\").on(\"error\", reject).on(\"data\", (chunk)=>s += chunk).on(\"end\", ()=>{\n                try {\n                    try {\n                        const data = JSON.parse(s);\n                        const r = this._cacheClientFromJSON(data, options);\n                        return resolve(r);\n                    } catch (err) {\n                        // If we failed parsing this.keyFileName, assume that it\n                        // is a PEM or p12 certificate:\n                        if (!this.keyFilename) throw err;\n                        const client = new jwtclient_1.JWT({\n                            ...this.clientOptions,\n                            keyFile: this.keyFilename\n                        });\n                        this.cachedCredential = client;\n                        this.setGapicJWTValues(client);\n                        return resolve(client);\n                    }\n                } catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Create a credentials instance using the given API key string.\n     * @param apiKey The API key string\n     * @param options An optional options object.\n     * @returns A JWT loaded from the key\n     */ fromAPIKey(apiKey, options) {\n        options = options || {};\n        const client = new jwtclient_1.JWT(options);\n        client.fromAPIKey(apiKey);\n        return client;\n    }\n    /**\n     * Determines whether the current operating system is Windows.\n     * @api private\n     */ _isWindows() {\n        const sys = os.platform();\n        if (sys && sys.length >= 3) {\n            if (sys.substring(0, 3).toLowerCase() === \"win\") {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Run the Google Cloud SDK command that prints the default project ID\n     */ async getDefaultServiceProjectId() {\n        return new Promise((resolve)=>{\n            (0, child_process_1.exec)(\"gcloud config config-helper --format json\", (err, stdout)=>{\n                if (!err && stdout) {\n                    try {\n                        const projectId = JSON.parse(stdout).configuration.properties.core.project;\n                        resolve(projectId);\n                        return;\n                    } catch (e) {\n                    // ignore errors\n                    }\n                }\n                resolve(null);\n            });\n        });\n    }\n    /**\n     * Loads the project id from environment variables.\n     * @api private\n     */ getProductionProjectId() {\n        return process.env[\"GCLOUD_PROJECT\"] || process.env[\"GOOGLE_CLOUD_PROJECT\"] || process.env[\"gcloud_project\"] || process.env[\"google_cloud_project\"];\n    }\n    /**\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n     * @api private\n     */ async getFileProjectId() {\n        if (this.cachedCredential) {\n            // Try to read the project ID from the cached credentials file\n            return this.cachedCredential.projectId;\n        }\n        // Ensure the projectId is loaded from the keyFile if available.\n        if (this.keyFilename) {\n            const creds = await this.getClient();\n            if (creds && creds.projectId) {\n                return creds.projectId;\n            }\n        }\n        // Try to load a credentials file and read its project ID\n        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n        if (r) {\n            return r.projectId;\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Gets the project ID from external account client if available.\n     */ async getExternalAccountClientProjectId() {\n        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            return null;\n        }\n        const creds = await this.getClient();\n        // Do not suppress the underlying error, as the error could contain helpful\n        // information for debugging and fixing. This is especially true for\n        // external account creds as in order to get the project ID, the following\n        // operations have to succeed:\n        // 1. Valid credentials file should be supplied.\n        // 2. Ability to retrieve access tokens from STS token exchange API.\n        // 3. Ability to exchange for service account impersonated credentials (if\n        //    enabled).\n        // 4. Ability to get project info using the access token from step 2 or 3.\n        // Without surfacing the error, it is harder for developers to determine\n        // which step went wrong.\n        return await creds.getProjectId();\n    }\n    /**\n     * Gets the Compute Engine project ID if it can be inferred.\n     */ async getGCEProjectId() {\n        try {\n            const r = await gcpMetadata.project(\"project-id\");\n            return r;\n        } catch (e) {\n            // Ignore any errors\n            return null;\n        }\n    }\n    getCredentials(callback) {\n        if (callback) {\n            this.getCredentialsAsync().then((r)=>callback(null, r), callback);\n        } else {\n            return this.getCredentialsAsync();\n        }\n    }\n    async getCredentialsAsync() {\n        const client = await this.getClient();\n        if (client instanceof impersonated_1.Impersonated) {\n            return {\n                client_email: client.getTargetPrincipal()\n            };\n        }\n        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\n            const serviceAccountEmail = client.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                return {\n                    client_email: serviceAccountEmail,\n                    universe_domain: client.universeDomain\n                };\n            }\n        }\n        if (this.jsonContent) {\n            return {\n                client_email: this.jsonContent.client_email,\n                private_key: this.jsonContent.private_key,\n                universe_domain: this.jsonContent.universe_domain\n            };\n        }\n        if (await this._checkIsGCE()) {\n            const [client_email, universe_domain] = await Promise.all([\n                gcpMetadata.instance(\"service-accounts/default/email\"),\n                this.getUniverseDomain()\n            ]);\n            return {\n                client_email,\n                universe_domain\n            };\n        }\n        throw new Error(GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);\n    }\n    /**\n     * Automatically obtain an {@link AuthClient `AuthClient`} based on the\n     * provided configuration. If no options were passed, use Application\n     * Default Credentials.\n     */ async getClient() {\n        if (!this.cachedCredential) {\n            if (this.jsonContent) {\n                this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n            } else if (this.keyFilename) {\n                const filePath = path.resolve(this.keyFilename);\n                const stream = fs.createReadStream(filePath);\n                await this.fromStreamAsync(stream, this.clientOptions);\n            } else {\n                await this.getApplicationDefaultAsync(this.clientOptions);\n            }\n        }\n        return this.cachedCredential;\n    }\n    /**\n     * Creates a client which will fetch an ID token for authorization.\n     * @param targetAudience the audience for the fetched ID token.\n     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\n     */ async getIdTokenClient(targetAudience) {\n        const client = await this.getClient();\n        if (!(\"fetchIdToken\" in client)) {\n            throw new Error(\"Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.\");\n        }\n        return new idtokenclient_1.IdTokenClient({\n            targetAudience,\n            idTokenProvider: client\n        });\n    }\n    /**\n     * Automatically obtain application default credentials, and return\n     * an access token for making requests.\n     */ async getAccessToken() {\n        const client = await this.getClient();\n        return (await client.getAccessToken()).token;\n    }\n    /**\n     * Obtain the HTTP headers that will provide authorization for a given\n     * request.\n     */ async getRequestHeaders(url) {\n        const client = await this.getClient();\n        return client.getRequestHeaders(url);\n    }\n    /**\n     * Obtain credentials for a request, then attach the appropriate headers to\n     * the request options.\n     * @param opts Axios or Request options on which to attach the headers\n     */ async authorizeRequest(opts) {\n        opts = opts || {};\n        const url = opts.url || opts.uri;\n        const client = await this.getClient();\n        const headers = await client.getRequestHeaders(url);\n        opts.headers = Object.assign(opts.headers || {}, headers);\n        return opts;\n    }\n    /**\n     * Automatically obtain application default credentials, and make an\n     * HTTP request using the given options.\n     * @param opts Axios request options for the HTTP request.\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async request(opts) {\n        const client = await this.getClient();\n        return client.request(opts);\n    }\n    /**\n     * Determine the compute environment in which the code is running.\n     */ getEnv() {\n        return (0, envDetect_1.getEnv)();\n    }\n    /**\n     * Sign the given data with the current private key, or go out\n     * to the IAM API to sign it.\n     * @param data The data to be signed.\n     * @param endpoint A custom endpoint to use.\n     *\n     * @example\n     * ```\n     * sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');\n     * ```\n     */ async sign(data, endpoint) {\n        const client = await this.getClient();\n        const universe = await this.getUniverseDomain();\n        endpoint = endpoint || `https://iamcredentials.${universe}/v1/projects/-/serviceAccounts/`;\n        if (client instanceof impersonated_1.Impersonated) {\n            const signed = await client.sign(data);\n            return signed.signedBlob;\n        }\n        const crypto = (0, crypto_1.createCrypto)();\n        if (client instanceof jwtclient_1.JWT && client.key) {\n            const sign = await crypto.sign(client.key, data);\n            return sign;\n        }\n        const creds = await this.getCredentials();\n        if (!creds.client_email) {\n            throw new Error(\"Cannot sign data without `client_email`.\");\n        }\n        return this.signBlob(crypto, creds.client_email, data, endpoint);\n    }\n    async signBlob(crypto, emailOrUniqueId, data, endpoint) {\n        const url = new URL(endpoint + `${emailOrUniqueId}:signBlob`);\n        const res = await this.request({\n            method: \"POST\",\n            url: url.href,\n            data: {\n                payload: crypto.encodeBase64StringUtf8(data)\n            }\n        });\n        return res.data.signedBlob;\n    }\n}\nexports.GoogleAuth = GoogleAuth;\n/**\n * Export DefaultTransporter as a static property of the class.\n */ GoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2dvb2dsZWF1dGguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBR0EsMkJBQTJCLEdBQUcsS0FBSztBQUN4RCxNQUFNSSxrQkFBa0JDLG1CQUFPQSxDQUFDLG9DQUFlO0FBQy9DLE1BQU1DLEtBQUtELG1CQUFPQSxDQUFDLGNBQUk7QUFDdkIsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsc0hBQWM7QUFDMUMsTUFBTUcsS0FBS0gsbUJBQU9BLENBQUMsY0FBSTtBQUN2QixNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNSyxXQUFXTCxtQkFBT0EsQ0FBQyx3R0FBa0I7QUFDM0MsTUFBTU0saUJBQWlCTixtQkFBT0EsQ0FBQyxzR0FBaUI7QUFDaEQsTUFBTU8sa0JBQWtCUCxtQkFBT0EsQ0FBQyw0R0FBaUI7QUFDakQsTUFBTVEsa0JBQWtCUixtQkFBT0EsQ0FBQyw0R0FBaUI7QUFDakQsTUFBTVMsY0FBY1QsbUJBQU9BLENBQUMsb0dBQWE7QUFDekMsTUFBTVUsY0FBY1YsbUJBQU9BLENBQUMsb0dBQWE7QUFDekMsTUFBTVcsa0JBQWtCWCxtQkFBT0EsQ0FBQyw0R0FBaUI7QUFDakQsTUFBTVksaUJBQWlCWixtQkFBT0EsQ0FBQywwR0FBZ0I7QUFDL0MsTUFBTWEsbUJBQW1CYixtQkFBT0EsQ0FBQyw4R0FBa0I7QUFDbkQsTUFBTWMsdUJBQXVCZCxt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QUFNTSxTQUFTSCxNQUFNLEVBQUVJLGVBQWUsRUFBRWhELElBQUksRUFBRXlDLFFBQVEsRUFBRTtRQUNwRCxNQUFNUixNQUFNLElBQUlnQixJQUFJUixXQUFXLENBQUMsRUFBRU8sZ0JBQWdCLFNBQVMsQ0FBQztRQUM1RCxNQUFNRSxNQUFNLE1BQU0sSUFBSSxDQUFDWixPQUFPLENBQUM7WUFDM0JhLFFBQVE7WUFDUmxCLEtBQUtBLElBQUltQixJQUFJO1lBQ2JwRCxNQUFNO2dCQUNGcUQsU0FBU1QsT0FBT1Usc0JBQXNCLENBQUN0RDtZQUMzQztRQUNKO1FBQ0EsT0FBT2tELElBQUlsRCxJQUFJLENBQUMyQyxVQUFVO0lBQzlCO0FBQ0o7QUFDQS9MLGtCQUFrQixHQUFHRTtBQUNyQjs7Q0FFQyxHQUNEQSxXQUFXeU0sa0JBQWtCLEdBQUdoTSxlQUFlZ00sa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvdGlmeS10by15b3V0dWJlLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZ29vZ2xlYXV0aC5qcz8xZjM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdvb2dsZUF1dGggPSBleHBvcnRzLkNMT1VEX1NES19DTElFTlRfSUQgPSB2b2lkIDA7XG5jb25zdCBjaGlsZF9wcm9jZXNzXzEgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgZ2NwTWV0YWRhdGEgPSByZXF1aXJlKFwiZ2NwLW1ldGFkYXRhXCIpO1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vY3J5cHRvXCIpO1xuY29uc3QgdHJhbnNwb3J0ZXJzXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0ZXJzXCIpO1xuY29uc3QgY29tcHV0ZWNsaWVudF8xID0gcmVxdWlyZShcIi4vY29tcHV0ZWNsaWVudFwiKTtcbmNvbnN0IGlkdG9rZW5jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2lkdG9rZW5jbGllbnRcIik7XG5jb25zdCBlbnZEZXRlY3RfMSA9IHJlcXVpcmUoXCIuL2VudkRldGVjdFwiKTtcbmNvbnN0IGp3dGNsaWVudF8xID0gcmVxdWlyZShcIi4vand0Y2xpZW50XCIpO1xuY29uc3QgcmVmcmVzaGNsaWVudF8xID0gcmVxdWlyZShcIi4vcmVmcmVzaGNsaWVudFwiKTtcbmNvbnN0IGltcGVyc29uYXRlZF8xID0gcmVxdWlyZShcIi4vaW1wZXJzb25hdGVkXCIpO1xuY29uc3QgZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsY2xpZW50XCIpO1xuY29uc3QgYmFzZWV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9iYXNlZXh0ZXJuYWxjbGllbnRcIik7XG5jb25zdCBhdXRoY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoY2xpZW50XCIpO1xuY29uc3QgZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50XCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5leHBvcnRzLkNMT1VEX1NES19DTElFTlRfSUQgPSAnNzY0MDg2MDUxODUwLTZxcjRwNmdwaTZobjUwNnB0OGVqdXE4M2RpMzQxaHVyLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tJztcbmNvbnN0IEdvb2dsZUF1dGhFeGNlcHRpb25NZXNzYWdlcyA9IHtcbiAgICBOT19QUk9KRUNUX0lEX0ZPVU5EOiAnVW5hYmxlIHRvIGRldGVjdCBhIFByb2plY3QgSWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIFxcbicgK1xuICAgICAgICAnVG8gbGVhcm4gbW9yZSBhYm91dCBhdXRoZW50aWNhdGlvbiBhbmQgR29vZ2xlIEFQSXMsIHZpc2l0OiBcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9kb2NzL2F1dGhlbnRpY2F0aW9uL2dldHRpbmctc3RhcnRlZCcsXG4gICAgTk9fQ1JFREVOVElBTFNfRk9VTkQ6ICdVbmFibGUgdG8gZmluZCBjcmVkZW50aWFscyBpbiBjdXJyZW50IGVudmlyb25tZW50LiBcXG4nICtcbiAgICAgICAgJ1RvIGxlYXJuIG1vcmUgYWJvdXQgYXV0aGVudGljYXRpb24gYW5kIEdvb2dsZSBBUElzLCB2aXNpdDogXFxuJyArXG4gICAgICAgICdodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZG9jcy9hdXRoZW50aWNhdGlvbi9nZXR0aW5nLXN0YXJ0ZWQnLFxuICAgIE5PX1VOSVZFUlNFX0RPTUFJTl9GT1VORDogJ1VuYWJsZSB0byBkZXRlY3QgYSBVbml2ZXJzZSBEb21haW4gaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXFxuJyArXG4gICAgICAgICdUbyBsZWFybiBtb3JlIGFib3V0IFVuaXZlcnNlIERvbWFpbiByZXRyaWV2YWwsIHZpc2l0OiBcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9jb21wdXRlL2RvY3MvbWV0YWRhdGEvcHJlZGVmaW5lZC1tZXRhZGF0YS1rZXlzJyxcbn07XG5jbGFzcyBHb29nbGVBdXRoIHtcbiAgICAvLyBOb3RlOiAgdGhpcyBwcm9wZXJseSBpcyBvbmx5IHB1YmxpYyB0byBzYXRpc2lmeSB1bml0IHRlc3RzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNTIyOFxuICAgIGdldCBpc0dDRSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tJc0dDRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBpcyByZXNvbHZlZCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIG9mIHByZWNlZGVuY2U6XG4gICAgICogLSB7QGxpbmsgR29vZ2xlQXV0aE9wdGlvbnMuY3JlZGVudGlhbHMgYGNyZWRlbnRpYWxzYH1cbiAgICAgKiAtIHtAbGluayBHb29nbGVBdXRoT3B0aW9ucy5rZXlGaWxlbmFtZSBga2V5RmlsZW5hbWVgfVxuICAgICAqIC0ge0BsaW5rIEdvb2dsZUF1dGhPcHRpb25zLmtleUZpbGUgYGtleUZpbGVgfVxuICAgICAqXG4gICAgICoge0BsaW5rIEdvb2dsZUF1dGhPcHRpb25zLmNsaWVudE9wdGlvbnMgYGNsaWVudE9wdGlvbnNgfSBhcmUgcGFzc2VkIHRvIHRoZVxuICAgICAqIHtAbGluayBBdXRoQ2xpZW50IGBBdXRoQ2xpZW50YHN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZXMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGF1dGggbGF5ZXIgaXMgcnVubmluZyBvbiBHb29nbGVcbiAgICAgICAgICogQ29tcHV0ZSBFbmdpbmUuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrSXNHQ0UgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRvIHNhdmUgdGhlIGNvbnRlbnRzIG9mIHRoZSBKU09OIGNyZWRlbnRpYWwgZmlsZVxuICAgICAgICB0aGlzLmpzb25Db250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWNoZWRDcmVkZW50aWFsID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zID0ge307XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICB0aGlzLl9jYWNoZWRQcm9qZWN0SWQgPSBvcHRzLnByb2plY3RJZCB8fCBudWxsO1xuICAgICAgICB0aGlzLmNhY2hlZENyZWRlbnRpYWwgPSBvcHRzLmF1dGhDbGllbnQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5rZXlGaWxlbmFtZSA9IG9wdHMua2V5RmlsZW5hbWUgfHwgb3B0cy5rZXlGaWxlO1xuICAgICAgICB0aGlzLnNjb3BlcyA9IG9wdHMuc2NvcGVzO1xuICAgICAgICB0aGlzLmpzb25Db250ZW50ID0gb3B0cy5jcmVkZW50aWFscyB8fCBudWxsO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMgPSBvcHRzLmNsaWVudE9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChvcHRzLnVuaXZlcnNlRG9tYWluKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMudW5pdmVyc2VEb21haW4gPSBvcHRzLnVuaXZlcnNlRG9tYWluO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdBUElDIGNsaWVudCBsaWJyYXJpZXMgc2hvdWxkIGFsd2F5cyB1c2Ugc2VsZi1zaWduZWQgSldUcy4gVGhlIGZvbGxvd2luZ1xuICAgIC8vIHZhcmlhYmxlcyBhcmUgc2V0IG9uIHRoZSBKV1QgY2xpZW50IGluIG9yZGVyIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxpYnJhcnksXG4gICAgLy8gYW5kIHNpZ24gdGhlIEpXVCB3aXRoIHRoZSBjb3JyZWN0IGF1ZGllbmNlIGFuZCBzY29wZXMgKGlmIG5vdCBzdXBwbGllZCkuXG4gICAgc2V0R2FwaWNKV1RWYWx1ZXMoY2xpZW50KSB7XG4gICAgICAgIGNsaWVudC5kZWZhdWx0U2VydmljZVBhdGggPSB0aGlzLmRlZmF1bHRTZXJ2aWNlUGF0aDtcbiAgICAgICAgY2xpZW50LnVzZUpXVEFjY2Vzc1dpdGhTY29wZSA9IHRoaXMudXNlSldUQWNjZXNzV2l0aFNjb3BlO1xuICAgICAgICBjbGllbnQuZGVmYXVsdFNjb3BlcyA9IHRoaXMuZGVmYXVsdFNjb3BlcztcbiAgICB9XG4gICAgZ2V0UHJvamVjdElkKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRQcm9qZWN0SWRBc3luYygpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvamVjdElkQXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHRlbXBvcmFyeSBtZXRob2QgZm9yIGludGVybmFsIGBnZXRQcm9qZWN0SWRgIHVzYWdlcyB3aGVyZSBgbnVsbGAgaXNcbiAgICAgKiBhY2NlcHRhYmxlLiBJbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLCBgZ2V0UHJvamVjdElkYCBzaG91bGQgcmV0dXJuIGBudWxsYFxuICAgICAqIChhcyB0aGUgYFByb21pc2U8c3RyaW5nIHwgbnVsbD5gIGJhc2Ugc2lnbmF0dXJlIGRlc2NyaWJlcykgYW5kIHRoaXMgcHJpdmF0ZVxuICAgICAqIG1ldGhvZCBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHByb2plY3QgaWQgKG9yIGBudWxsYClcbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcm9qZWN0SWRPcHRpb25hbCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFByb2plY3RJZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID09PSBHb29nbGVBdXRoRXhjZXB0aW9uTWVzc2FnZXMuTk9fUFJPSkVDVF9JRF9GT1VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgICAqIEEgcHJpdmF0ZSBtZXRob2QgZm9yIGZpbmRpbmcgYW5kIGNhY2hpbmcgYSBwcm9qZWN0SWQuXG4gICAgICpcbiAgICAgKiBTdXBwb3J0cyBlbnZpcm9ubWVudHMgaW4gb3JkZXIgb2YgcHJlY2VkZW5jZTpcbiAgICAgKiAtIEdDTE9VRF9QUk9KRUNUIG9yIEdPT0dMRV9DTE9VRF9QUk9KRUNUIGVudmlyb25tZW50IHZhcmlhYmxlXG4gICAgICogLSBHT09HTEVfQVBQTElDQVRJT05fQ1JFREVOVElBTFMgSlNPTiBmaWxlXG4gICAgICogLSBDbG91ZCBTREs6IGBnY2xvdWQgY29uZmlnIGNvbmZpZy1oZWxwZXIgLS1mb3JtYXQganNvbmBcbiAgICAgKiAtIEdDRSBwcm9qZWN0IElEIGZyb20gbWV0YWRhdGEgc2VydmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBwcm9qZWN0SWRcbiAgICAgKi9cbiAgICBhc3luYyBmaW5kQW5kQ2FjaGVQcm9qZWN0SWQoKSB7XG4gICAgICAgIGxldCBwcm9qZWN0SWQgPSBudWxsO1xuICAgICAgICBwcm9qZWN0SWQgfHwgKHByb2plY3RJZCA9IGF3YWl0IHRoaXMuZ2V0UHJvZHVjdGlvblByb2plY3RJZCgpKTtcbiAgICAgICAgcHJvamVjdElkIHx8IChwcm9qZWN0SWQgPSBhd2FpdCB0aGlzLmdldEZpbGVQcm9qZWN0SWQoKSk7XG4gICAgICAgIHByb2plY3RJZCB8fCAocHJvamVjdElkID0gYXdhaXQgdGhpcy5nZXREZWZhdWx0U2VydmljZVByb2plY3RJZCgpKTtcbiAgICAgICAgcHJvamVjdElkIHx8IChwcm9qZWN0SWQgPSBhd2FpdCB0aGlzLmdldEdDRVByb2plY3RJZCgpKTtcbiAgICAgICAgcHJvamVjdElkIHx8IChwcm9qZWN0SWQgPSBhd2FpdCB0aGlzLmdldEV4dGVybmFsQWNjb3VudENsaWVudFByb2plY3RJZCgpKTtcbiAgICAgICAgaWYgKHByb2plY3RJZCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkUHJvamVjdElkID0gcHJvamVjdElkO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihHb29nbGVBdXRoRXhjZXB0aW9uTWVzc2FnZXMuTk9fUFJPSkVDVF9JRF9GT1VORCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvamVjdElkQXN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWRQcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9maW5kUHJvamVjdElkUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fZmluZFByb2plY3RJZFByb21pc2UgPSB0aGlzLmZpbmRBbmRDYWNoZVByb2plY3RJZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kUHJvamVjdElkUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgdW5pdmVyc2UgZG9tYWluIGZyb20gdGhlIG1ldGFkYXRhIHNlcnZlciB2aWFcbiAgICAgKiB7QGxpbmsgZ2NwTWV0YWRhdGEudW5pdmVyc2V9LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSB1bml2ZXJzZSBkb21haW5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVbml2ZXJzZURvbWFpbkZyb21NZXRhZGF0YVNlcnZlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgdW5pdmVyc2VEb21haW47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1bml2ZXJzZURvbWFpbiA9IGF3YWl0IGdjcE1ldGFkYXRhLnVuaXZlcnNlKCd1bml2ZXJzZV9kb21haW4nKTtcbiAgICAgICAgICAgIHVuaXZlcnNlRG9tYWluIHx8ICh1bml2ZXJzZURvbWFpbiA9IGF1dGhjbGllbnRfMS5ERUZBVUxUX1VOSVZFUlNFKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgJiYgKChfYSA9IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5yZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1cykgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIHVuaXZlcnNlRG9tYWluID0gYXV0aGNsaWVudF8xLkRFRkFVTFRfVU5JVkVSU0U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bml2ZXJzZURvbWFpbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzLCBjYWNoZXMsIGFuZCByZXR1cm5zIHRoZSB1bml2ZXJzZSBkb21haW4gaW4gdGhlIGZvbGxvd2luZyBvcmRlclxuICAgICAqIG9mIHByZWNlZGVuY2U6XG4gICAgICogLSBUaGUgdW5pdmVyc2UgZG9tYWluIGluIHtAbGluayBHb29nbGVBdXRoLmNsaWVudE9wdGlvbnN9XG4gICAgICogLSBBbiBleGlzdGluZyBvciBBREMge0BsaW5rIEF1dGhDbGllbnR9J3MgdW5pdmVyc2UgZG9tYWluXG4gICAgICogLSB7QGxpbmsgZ2NwTWV0YWRhdGEudW5pdmVyc2V9LCBpZiB7QGxpbmsgQ29tcHV0ZX0gY2xpZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdW5pdmVyc2UgZG9tYWluXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VW5pdmVyc2VEb21haW4oKSB7XG4gICAgICAgIGxldCB1bml2ZXJzZURvbWFpbiA9ICgwLCB1dGlsXzEub3JpZ2luYWxPckNhbWVsT3B0aW9ucykodGhpcy5jbGllbnRPcHRpb25zKS5nZXQoJ3VuaXZlcnNlX2RvbWFpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdW5pdmVyc2VEb21haW4gIT09IG51bGwgJiYgdW5pdmVyc2VEb21haW4gIT09IHZvaWQgMCA/IHVuaXZlcnNlRG9tYWluIDogKHVuaXZlcnNlRG9tYWluID0gKGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCkpLnVuaXZlcnNlRG9tYWluKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIGNsaWVudCBvciBBREMgaXMgbm90IGF2YWlsYWJsZVxuICAgICAgICAgICAgdW5pdmVyc2VEb21haW4gIT09IG51bGwgJiYgdW5pdmVyc2VEb21haW4gIT09IHZvaWQgMCA/IHVuaXZlcnNlRG9tYWluIDogKHVuaXZlcnNlRG9tYWluID0gYXV0aGNsaWVudF8xLkRFRkFVTFRfVU5JVkVSU0UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bml2ZXJzZURvbWFpbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgQW55IHNjb3BlcyAodXNlci1zcGVjaWZpZWQgb3IgZGVmYXVsdCBzY29wZXMgc3BlY2lmaWVkIGJ5IHRoZVxuICAgICAqICAgY2xpZW50IGxpYnJhcnkpIHRoYXQgbmVlZCB0byBiZSBzZXQgb24gdGhlIGN1cnJlbnQgQXV0aCBjbGllbnQuXG4gICAgICovXG4gICAgZ2V0QW55U2NvcGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZXMgfHwgdGhpcy5kZWZhdWx0U2NvcGVzO1xuICAgIH1cbiAgICBnZXRBcHBsaWNhdGlvbkRlZmF1bHQob3B0aW9uc09yQ2FsbGJhY2sgPSB7fSwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldEFwcGxpY2F0aW9uRGVmYXVsdEFzeW5jKG9wdGlvbnMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByLmNyZWRlbnRpYWwsIHIucHJvamVjdElkKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwbGljYXRpb25EZWZhdWx0QXN5bmMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0QXBwbGljYXRpb25EZWZhdWx0QXN5bmMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGEgY2FjaGVkIGNyZWRlbnRpYWwsIHJldHVybiBpdC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGFsc28gcHJlc2VydmUgb25lJ3MgY29uZmlndXJlZCBxdW90YSBwcm9qZWN0LCBpbiBjYXNlIHRoZXlcbiAgICAgICAgLy8gc2V0IG9uZSBkaXJlY3RseSBvbiB0aGUgY3JlZGVudGlhbCBwcmV2aW91c2x5LlxuICAgICAgICBpZiAodGhpcy5jYWNoZWRDcmVkZW50aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcmVwYXJlQW5kQ2FjaGVBREModGhpcy5jYWNoZWRDcmVkZW50aWFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgJ25ldycgQURDIHRvIGNhY2hlIHdlIHdpbGwgdXNlIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgICAgICAvLyBpZiBpdCdzIGF2YWlsYWJsZS4gV2UgcHJlZmVyIHRoaXMgdmFsdWUgb3ZlciB0aGUgdmFsdWUgZnJvbSBBREMuXG4gICAgICAgIGNvbnN0IHF1b3RhUHJvamVjdElkT3ZlcnJpZGUgPSBwcm9jZXNzLmVudlsnR09PR0xFX0NMT1VEX1FVT1RBX1BST0pFQ1QnXTtcbiAgICAgICAgbGV0IGNyZWRlbnRpYWw7XG4gICAgICAgIC8vIENoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGEgbG9jYWwgZW52aXJvbm1lbnQgdmFyaWFibGUgcG9pbnRpbmcgdG8gdGhlXG4gICAgICAgIC8vIGxvY2F0aW9uIG9mIHRoZSBjcmVkZW50aWFsIGZpbGUuIFRoaXMgaXMgdHlwaWNhbGx5IHVzZWQgaW4gbG9jYWxcbiAgICAgICAgLy8gZGV2ZWxvcGVyIHNjZW5hcmlvcy5cbiAgICAgICAgY3JlZGVudGlhbCA9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbUVudmlyb25tZW50VmFyaWFibGUob3B0aW9ucyk7XG4gICAgICAgIGlmIChjcmVkZW50aWFsKSB7XG4gICAgICAgICAgICBpZiAoY3JlZGVudGlhbCBpbnN0YW5jZW9mIGp3dGNsaWVudF8xLkpXVCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjcmVkZW50aWFsIGluc3RhbmNlb2YgYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5nZXRBbnlTY29wZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByZXBhcmVBbmRDYWNoZUFEQyhjcmVkZW50aWFsLCBxdW90YVByb2plY3RJZE92ZXJyaWRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIGluIHRoZSB3ZWxsLWtub3duIGNyZWRlbnRpYWwgZmlsZSBsb2NhdGlvbi5cbiAgICAgICAgY3JlZGVudGlhbCA9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbVdlbGxLbm93bkZpbGUob3B0aW9ucyk7XG4gICAgICAgIGlmIChjcmVkZW50aWFsKSB7XG4gICAgICAgICAgICBpZiAoY3JlZGVudGlhbCBpbnN0YW5jZW9mIGp3dGNsaWVudF8xLkpXVCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjcmVkZW50aWFsIGluc3RhbmNlb2YgYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5nZXRBbnlTY29wZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByZXBhcmVBbmRDYWNoZUFEQyhjcmVkZW50aWFsLCBxdW90YVByb2plY3RJZE92ZXJyaWRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBvbiBHQ0UuXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLl9jaGVja0lzR0NFKCkpIHtcbiAgICAgICAgICAgIC8vIHNldCB1bml2ZXJzZSBkb21haW4gZm9yIENvbXB1dGUgY2xpZW50XG4gICAgICAgICAgICBpZiAoISgwLCB1dGlsXzEub3JpZ2luYWxPckNhbWVsT3B0aW9ucykob3B0aW9ucykuZ2V0KCd1bml2ZXJzZV9kb21haW4nKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudW5pdmVyc2VEb21haW4gPVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldFVuaXZlcnNlRG9tYWluRnJvbU1ldGFkYXRhU2VydmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLnNjb3BlcyA9IHRoaXMuZ2V0QW55U2NvcGVzKCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcmVwYXJlQW5kQ2FjaGVBREMobmV3IGNvbXB1dGVjbGllbnRfMS5Db21wdXRlKG9wdGlvbnMpLCBxdW90YVByb2plY3RJZE92ZXJyaWRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzLiBCcm93c2UgdG8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RvY3MvYXV0aGVudGljYXRpb24vZ2V0dGluZy1zdGFydGVkIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlQW5kQ2FjaGVBREMoY3JlZGVudGlhbCwgcXVvdGFQcm9qZWN0SWRPdmVycmlkZSkge1xuICAgICAgICBjb25zdCBwcm9qZWN0SWQgPSBhd2FpdCB0aGlzLmdldFByb2plY3RJZE9wdGlvbmFsKCk7XG4gICAgICAgIGlmIChxdW90YVByb2plY3RJZE92ZXJyaWRlKSB7XG4gICAgICAgICAgICBjcmVkZW50aWFsLnF1b3RhUHJvamVjdElkID0gcXVvdGFQcm9qZWN0SWRPdmVycmlkZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlZENyZWRlbnRpYWwgPSBjcmVkZW50aWFsO1xuICAgICAgICByZXR1cm4geyBjcmVkZW50aWFsLCBwcm9qZWN0SWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhdXRoIGxheWVyIGlzIHJ1bm5pbmcgb24gR29vZ2xlIENvbXB1dGUgRW5naW5lLlxuICAgICAqIENoZWNrcyBmb3IgR0NQIFJlc2lkZW5jeSwgdGhlbiBmYWxsYmFjayB0byBjaGVja2luZyBpZiBtZXRhZGF0YSBzZXJ2ZXJcbiAgICAgKiBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBib29sZWFuLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF9jaGVja0lzR0NFKCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja0lzR0NFID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJc0dDRSA9XG4gICAgICAgICAgICAgICAgZ2NwTWV0YWRhdGEuZ2V0R0NQUmVzaWRlbmN5KCkgfHwgKGF3YWl0IGdjcE1ldGFkYXRhLmlzQXZhaWxhYmxlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrSXNHQ0U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGxvYWQgZGVmYXVsdCBjcmVkZW50aWFscyBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBwYXRoLi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgT0F1dGgyQ2xpZW50IG9yIG51bGwuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX3RyeUdldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRW52aXJvbm1lbnRWYXJpYWJsZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzUGF0aCA9IHByb2Nlc3MuZW52WydHT09HTEVfQVBQTElDQVRJT05fQ1JFREVOVElBTFMnXSB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnZbJ2dvb2dsZV9hcHBsaWNhdGlvbl9jcmVkZW50aWFscyddO1xuICAgICAgICBpZiAoIWNyZWRlbnRpYWxzUGF0aCB8fCBjcmVkZW50aWFsc1BhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRmlsZVBhdGgoY3JlZGVudGlhbHNQYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBVbmFibGUgdG8gcmVhZCB0aGUgY3JlZGVudGlhbCBmaWxlIHNwZWNpZmllZCBieSB0aGUgR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTIGVudmlyb25tZW50IHZhcmlhYmxlOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBsb2FkIGRlZmF1bHQgY3JlZGVudGlhbHMgZnJvbSBhIHdlbGwta25vd24gZmlsZSBsb2NhdGlvblxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIE9BdXRoMkNsaWVudCBvciBudWxsLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbVdlbGxLbm93bkZpbGUob3B0aW9ucykge1xuICAgICAgICAvLyBGaXJzdCwgZmlndXJlIG91dCB0aGUgbG9jYXRpb24gb2YgdGhlIGZpbGUsIGRlcGVuZGluZyB1cG9uIHRoZSBPUyB0eXBlLlxuICAgICAgICBsZXQgbG9jYXRpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5faXNXaW5kb3dzKCkpIHtcbiAgICAgICAgICAgIC8vIFdpbmRvd3NcbiAgICAgICAgICAgIGxvY2F0aW9uID0gcHJvY2Vzcy5lbnZbJ0FQUERBVEEnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIExpbnV4IG9yIE1hY1xuICAgICAgICAgICAgY29uc3QgaG9tZSA9IHByb2Nlc3MuZW52WydIT01FJ107XG4gICAgICAgICAgICBpZiAoaG9tZSkge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gcGF0aC5qb2luKGhvbWUsICcuY29uZmlnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZm91bmQgdGhlIHJvb3QgcGF0aCwgZXhwYW5kIGl0LlxuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gcGF0aC5qb2luKGxvY2F0aW9uLCAnZ2Nsb3VkJywgJ2FwcGxpY2F0aW9uX2RlZmF1bHRfY3JlZGVudGlhbHMuanNvbicpO1xuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZmlsZSBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgaWYgKCFsb2NhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGZpbGUgc2VlbXMgdG8gZXhpc3QuIFRyeSB0byB1c2UgaXQuXG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuX2dldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRmlsZVBhdGgobG9jYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBsb2FkIGRlZmF1bHQgY3JlZGVudGlhbHMgZnJvbSBhIGZpbGUgYXQgdGhlIGdpdmVuIHBhdGguLlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCBUaGUgcGF0aCB0byB0aGUgZmlsZSB0byByZWFkLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBPQXV0aDJDbGllbnRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21GaWxlUGF0aChmaWxlUGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGF0aCBsb29rcyBsaWtlIGEgc3RyaW5nLlxuICAgICAgICBpZiAoIWZpbGVQYXRoIHx8IGZpbGVQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZmlsZSBwYXRoIGlzIGludmFsaWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIGEgZmlsZSBhdCB0aGUgcGF0aC4gbHN0YXRTeW5jIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXNcbiAgICAgICAgLy8gbm90aGluZyB0aGVyZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgcGF0aCB0byBhY3R1YWwgZmlsZSBpbiBjYXNlIG9mIHN5bWxpbmsuIEV4cGVjdCBhIHRocm93biBlcnJvclxuICAgICAgICAgICAgLy8gaWYgbm90IHJlc29sdmFibGUuXG4gICAgICAgICAgICBmaWxlUGF0aCA9IGZzLnJlYWxwYXRoU3luYyhmaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAoIWZzLmxzdGF0U3luYyhmaWxlUGF0aCkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBUaGUgZmlsZSBhdCAke2ZpbGVQYXRofSBkb2VzIG5vdCBleGlzdCwgb3IgaXQgaXMgbm90IGEgZmlsZS4gJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBvcGVuIGEgcmVhZCBzdHJlYW0gb24gdGhlIGZpbGUsIGFuZCBwYXJzZSBpdC5cbiAgICAgICAgY29uc3QgcmVhZFN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZVBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tU3RyZWFtKHJlYWRTdHJlYW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyBhIGdpdmVuIGltcGVyc29uYXRlZCBpbnB1dCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBqc29uIFRoZSBpbXBlcnNvbmF0ZWQgaW5wdXQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIEpXVCBvciBVc2VyUmVmcmVzaCBDbGllbnQgd2l0aCBkYXRhXG4gICAgICovXG4gICAgZnJvbUltcGVyc29uYXRlZEpTT04oanNvbikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICBpZiAoIWpzb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgSlNPTiBvYmplY3QgY29udGFpbmluZyBhbiAgaW1wZXJzb25hdGVkIHJlZnJlc2ggdG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi50eXBlICE9PSBpbXBlcnNvbmF0ZWRfMS5JTVBFUlNPTkFURURfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBoYXZlIHRoZSBcIiR7aW1wZXJzb25hdGVkXzEuSU1QRVJTT05BVEVEX0FDQ09VTlRfVFlQRX1cIiB0eXBlYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnNvdXJjZV9jcmVkZW50aWFscykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIHNvdXJjZV9jcmVkZW50aWFscyBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanNvbi5zZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSBzZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmwgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgc291cmNlIGNsaWVudCBmb3IgaW1wZXJzb25hdGlvblxuICAgICAgICBjb25zdCBzb3VyY2VDbGllbnQgPSBuZXcgcmVmcmVzaGNsaWVudF8xLlVzZXJSZWZyZXNoQ2xpZW50KCk7XG4gICAgICAgIHNvdXJjZUNsaWVudC5mcm9tSlNPTihqc29uLnNvdXJjZV9jcmVkZW50aWFscyk7XG4gICAgICAgIGlmICgoKF9hID0ganNvbi5zZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID4gMjU2KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByZXZlbnRzIERPUyBhdHRhY2tzLlxuICAgICAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvZ29vZ2xlLWF1dGgtbGlicmFyeS1ub2RlanMvc2VjdXJpdHkvY29kZS1zY2FubmluZy84NX1cbiAgICAgICAgICAgICAqKi9cbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUYXJnZXQgcHJpbmNpcGFsIGlzIHRvbyBsb25nOiAke2pzb24uc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJlYWN0IHNlcnZpY2UgYWNjb3VudCBmcm9tIHNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybFxuICAgICAgICBjb25zdCB0YXJnZXRQcmluY2lwYWwgPSAoX2MgPSAoX2IgPSAvKD88dGFyZ2V0PlteL10rKTpnZW5lcmF0ZUFjY2Vzc1Rva2VuJC8uZXhlYyhqc29uLnNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ncm91cHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50YXJnZXQ7XG4gICAgICAgIGlmICghdGFyZ2V0UHJpbmNpcGFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IGV4dHJhY3QgdGFyZ2V0IHByaW5jaXBhbCBmcm9tICR7anNvbi5zZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0U2NvcGVzID0gKF9kID0gdGhpcy5nZXRBbnlTY29wZXMoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW107XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBpbXBlcnNvbmF0ZWRfMS5JbXBlcnNvbmF0ZWQoe1xuICAgICAgICAgICAgLi4uanNvbixcbiAgICAgICAgICAgIGRlbGVnYXRlczogKF9lID0ganNvbi5kZWxlZ2F0ZXMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFtdLFxuICAgICAgICAgICAgc291cmNlQ2xpZW50OiBzb3VyY2VDbGllbnQsXG4gICAgICAgICAgICB0YXJnZXRQcmluY2lwYWw6IHRhcmdldFByaW5jaXBhbCxcbiAgICAgICAgICAgIHRhcmdldFNjb3BlczogQXJyYXkuaXNBcnJheSh0YXJnZXRTY29wZXMpID8gdGFyZ2V0U2NvcGVzIDogW3RhcmdldFNjb3Blc10sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyB0aGUgZ2l2ZW4gaW5wdXQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ganNvbiBUaGUgaW5wdXQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBKV1Qgb3IgVXNlclJlZnJlc2ggb3B0aW9ucyBmb3IgdGhlIGNsaWVudFxuICAgICAqIEByZXR1cm5zIEpXVCBvciBVc2VyUmVmcmVzaCBDbGllbnQgd2l0aCBkYXRhXG4gICAgICovXG4gICAgZnJvbUpTT04oanNvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjbGllbnQ7XG4gICAgICAgIC8vIHVzZXIncyBwcmVmZXJyZWQgdW5pdmVyc2UgZG9tYWluXG4gICAgICAgIGNvbnN0IHByZWZlcnJlZFVuaXZlcnNlRG9tYWluID0gKDAsIHV0aWxfMS5vcmlnaW5hbE9yQ2FtZWxPcHRpb25zKShvcHRpb25zKS5nZXQoJ3VuaXZlcnNlX2RvbWFpbicpO1xuICAgICAgICBpZiAoanNvbi50eXBlID09PSByZWZyZXNoY2xpZW50XzEuVVNFUl9SRUZSRVNIX0FDQ09VTlRfVFlQRSkge1xuICAgICAgICAgICAgY2xpZW50ID0gbmV3IHJlZnJlc2hjbGllbnRfMS5Vc2VyUmVmcmVzaENsaWVudChvcHRpb25zKTtcbiAgICAgICAgICAgIGNsaWVudC5mcm9tSlNPTihqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc29uLnR5cGUgPT09IGltcGVyc29uYXRlZF8xLklNUEVSU09OQVRFRF9BQ0NPVU5UX1RZUEUpIHtcbiAgICAgICAgICAgIGNsaWVudCA9IHRoaXMuZnJvbUltcGVyc29uYXRlZEpTT04oanNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanNvbi50eXBlID09PSBiYXNlZXh0ZXJuYWxjbGllbnRfMS5FWFRFUk5BTF9BQ0NPVU5UX1RZUEUpIHtcbiAgICAgICAgICAgIGNsaWVudCA9IGV4dGVybmFsY2xpZW50XzEuRXh0ZXJuYWxBY2NvdW50Q2xpZW50LmZyb21KU09OKGpzb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2xpZW50LnNjb3BlcyA9IHRoaXMuZ2V0QW55U2NvcGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanNvbi50eXBlID09PSBleHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudF8xLkVYVEVSTkFMX0FDQ09VTlRfQVVUSE9SSVpFRF9VU0VSX1RZUEUpIHtcbiAgICAgICAgICAgIGNsaWVudCA9IG5ldyBleHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudF8xLkV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50KGpzb24sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5zY29wZXMgPSB0aGlzLnNjb3BlcztcbiAgICAgICAgICAgIGNsaWVudCA9IG5ldyBqd3RjbGllbnRfMS5KV1Qob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNldEdhcGljSldUVmFsdWVzKGNsaWVudCk7XG4gICAgICAgICAgICBjbGllbnQuZnJvbUpTT04oanNvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZlcnJlZFVuaXZlcnNlRG9tYWluKSB7XG4gICAgICAgICAgICBjbGllbnQudW5pdmVyc2VEb21haW4gPSBwcmVmZXJyZWRVbml2ZXJzZURvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBKV1Qgb3IgVXNlclJlZnJlc2hDbGllbnQgZnJvbSBKYXZhU2NyaXB0IG9iamVjdCwgY2FjaGluZyBib3RoIHRoZVxuICAgICAqIG9iamVjdCB1c2VkIHRvIGluc3RhbnRpYXRlIGFuZCB0aGUgY2xpZW50LlxuICAgICAqIEBwYXJhbSBqc29uIFRoZSBpbnB1dCBvYmplY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIEpXVCBvciBVc2VyUmVmcmVzaCBvcHRpb25zIGZvciB0aGUgY2xpZW50XG4gICAgICogQHJldHVybnMgSldUIG9yIFVzZXJSZWZyZXNoIENsaWVudCB3aXRoIGRhdGFcbiAgICAgKi9cbiAgICBfY2FjaGVDbGllbnRGcm9tSlNPTihqc29uLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZnJvbUpTT04oanNvbiwgb3B0aW9ucyk7XG4gICAgICAgIC8vIGNhY2hlIGJvdGggcmF3IGRhdGEgdXNlZCB0byBpbnN0YW50aWF0ZSBjbGllbnQgYW5kIGNsaWVudCBpdHNlbGYuXG4gICAgICAgIHRoaXMuanNvbkNvbnRlbnQgPSBqc29uO1xuICAgICAgICB0aGlzLmNhY2hlZENyZWRlbnRpYWwgPSBjbGllbnQ7XG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfVxuICAgIGZyb21TdHJlYW0oaW5wdXRTdHJlYW0sIG9wdGlvbnNPckNhbGxiYWNrID0ge30sIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSwgb3B0aW9ucykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIEdvb2dsZSBhdXRoIHNldHRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgICAgIGlucHV0U3RyZWFtXG4gICAgICAgICAgICAgICAgLnNldEVuY29kaW5nKCd1dGY4JylcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgICAgICAgICAgIC5vbignZGF0YScsIGNodW5rID0+IChzICs9IGNodW5rKSlcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5fY2FjaGVDbGllbnRGcm9tSlNPTihkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGZhaWxlZCBwYXJzaW5nIHRoaXMua2V5RmlsZU5hbWUsIGFzc3VtZSB0aGF0IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBhIFBFTSBvciBwMTIgY2VydGlmaWNhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMua2V5RmlsZW5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IGp3dGNsaWVudF8xLkpXVCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5jbGllbnRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUZpbGU6IHRoaXMua2V5RmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkQ3JlZGVudGlhbCA9IGNsaWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0R2FwaWNKV1RWYWx1ZXMoY2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGNsaWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyB0aGUgZ2l2ZW4gQVBJIGtleSBzdHJpbmcuXG4gICAgICogQHBhcmFtIGFwaUtleSBUaGUgQVBJIGtleSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyBBIEpXVCBsb2FkZWQgZnJvbSB0aGUga2V5XG4gICAgICovXG4gICAgZnJvbUFQSUtleShhcGlLZXksIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBqd3RjbGllbnRfMS5KV1Qob3B0aW9ucyk7XG4gICAgICAgIGNsaWVudC5mcm9tQVBJS2V5KGFwaUtleSk7XG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgY3VycmVudCBvcGVyYXRpbmcgc3lzdGVtIGlzIFdpbmRvd3MuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgX2lzV2luZG93cygpIHtcbiAgICAgICAgY29uc3Qgc3lzID0gb3MucGxhdGZvcm0oKTtcbiAgICAgICAgaWYgKHN5cyAmJiBzeXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgIGlmIChzeXMuc3Vic3RyaW5nKDAsIDMpLnRvTG93ZXJDYXNlKCkgPT09ICd3aW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIEdvb2dsZSBDbG91ZCBTREsgY29tbWFuZCB0aGF0IHByaW50cyB0aGUgZGVmYXVsdCBwcm9qZWN0IElEXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVmYXVsdFNlcnZpY2VQcm9qZWN0SWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICgwLCBjaGlsZF9wcm9jZXNzXzEuZXhlYykoJ2djbG91ZCBjb25maWcgY29uZmlnLWhlbHBlciAtLWZvcm1hdCBqc29uJywgKGVyciwgc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIgJiYgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9qZWN0SWQgPSBKU09OLnBhcnNlKHN0ZG91dCkuY29uZmlndXJhdGlvbi5wcm9wZXJ0aWVzLmNvcmUucHJvamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvamVjdElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBwcm9qZWN0IGlkIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFByb2R1Y3Rpb25Qcm9qZWN0SWQoKSB7XG4gICAgICAgIHJldHVybiAocHJvY2Vzcy5lbnZbJ0dDTE9VRF9QUk9KRUNUJ10gfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52WydHT09HTEVfQ0xPVURfUFJPSkVDVCddIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudlsnZ2Nsb3VkX3Byb2plY3QnXSB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnZbJ2dvb2dsZV9jbG91ZF9wcm9qZWN0J10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgcHJvamVjdCBpZCBmcm9tIHRoZSBHT09HTEVfQVBQTElDQVRJT05fQ1JFREVOVElBTFMganNvbiBmaWxlLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZpbGVQcm9qZWN0SWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZENyZWRlbnRpYWwpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byByZWFkIHRoZSBwcm9qZWN0IElEIGZyb20gdGhlIGNhY2hlZCBjcmVkZW50aWFscyBmaWxlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRDcmVkZW50aWFsLnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHByb2plY3RJZCBpcyBsb2FkZWQgZnJvbSB0aGUga2V5RmlsZSBpZiBhdmFpbGFibGUuXG4gICAgICAgIGlmICh0aGlzLmtleUZpbGVuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVkcyA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgICAgICBpZiAoY3JlZHMgJiYgY3JlZHMucHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWRzLnByb2plY3RJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gbG9hZCBhIGNyZWRlbnRpYWxzIGZpbGUgYW5kIHJlYWQgaXRzIHByb2plY3QgSURcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuX3RyeUdldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRW52aXJvbm1lbnRWYXJpYWJsZSgpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHIucHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvamVjdCBJRCBmcm9tIGV4dGVybmFsIGFjY291bnQgY2xpZW50IGlmIGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRFeHRlcm5hbEFjY291bnRDbGllbnRQcm9qZWN0SWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5qc29uQ29udGVudCB8fCB0aGlzLmpzb25Db250ZW50LnR5cGUgIT09IGJhc2VleHRlcm5hbGNsaWVudF8xLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHVuZGVybHlpbmcgZXJyb3IsIGFzIHRoZSBlcnJvciBjb3VsZCBjb250YWluIGhlbHBmdWxcbiAgICAgICAgLy8gaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2luZyBhbmQgZml4aW5nLiBUaGlzIGlzIGVzcGVjaWFsbHkgdHJ1ZSBmb3JcbiAgICAgICAgLy8gZXh0ZXJuYWwgYWNjb3VudCBjcmVkcyBhcyBpbiBvcmRlciB0byBnZXQgdGhlIHByb2plY3QgSUQsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgLy8gb3BlcmF0aW9ucyBoYXZlIHRvIHN1Y2NlZWQ6XG4gICAgICAgIC8vIDEuIFZhbGlkIGNyZWRlbnRpYWxzIGZpbGUgc2hvdWxkIGJlIHN1cHBsaWVkLlxuICAgICAgICAvLyAyLiBBYmlsaXR5IHRvIHJldHJpZXZlIGFjY2VzcyB0b2tlbnMgZnJvbSBTVFMgdG9rZW4gZXhjaGFuZ2UgQVBJLlxuICAgICAgICAvLyAzLiBBYmlsaXR5IHRvIGV4Y2hhbmdlIGZvciBzZXJ2aWNlIGFjY291bnQgaW1wZXJzb25hdGVkIGNyZWRlbnRpYWxzIChpZlxuICAgICAgICAvLyAgICBlbmFibGVkKS5cbiAgICAgICAgLy8gNC4gQWJpbGl0eSB0byBnZXQgcHJvamVjdCBpbmZvIHVzaW5nIHRoZSBhY2Nlc3MgdG9rZW4gZnJvbSBzdGVwIDIgb3IgMy5cbiAgICAgICAgLy8gV2l0aG91dCBzdXJmYWNpbmcgdGhlIGVycm9yLCBpdCBpcyBoYXJkZXIgZm9yIGRldmVsb3BlcnMgdG8gZGV0ZXJtaW5lXG4gICAgICAgIC8vIHdoaWNoIHN0ZXAgd2VudCB3cm9uZy5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGNyZWRzLmdldFByb2plY3RJZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBDb21wdXRlIEVuZ2luZSBwcm9qZWN0IElEIGlmIGl0IGNhbiBiZSBpbmZlcnJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRHQ0VQcm9qZWN0SWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByID0gYXdhaXQgZ2NwTWV0YWRhdGEucHJvamVjdCgncHJvamVjdC1pZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgZXJyb3JzXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDcmVkZW50aWFscyhjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3JlZGVudGlhbHNBc3luYygpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3JlZGVudGlhbHNBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldENyZWRlbnRpYWxzQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIGlmIChjbGllbnQgaW5zdGFuY2VvZiBpbXBlcnNvbmF0ZWRfMS5JbXBlcnNvbmF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNsaWVudF9lbWFpbDogY2xpZW50LmdldFRhcmdldFByaW5jaXBhbCgpIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudCBpbnN0YW5jZW9mIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VBY2NvdW50RW1haWwgPSBjbGllbnQuZ2V0U2VydmljZUFjY291bnRFbWFpbCgpO1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VBY2NvdW50RW1haWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRfZW1haWw6IHNlcnZpY2VBY2NvdW50RW1haWwsXG4gICAgICAgICAgICAgICAgICAgIHVuaXZlcnNlX2RvbWFpbjogY2xpZW50LnVuaXZlcnNlRG9tYWluLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuanNvbkNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2xpZW50X2VtYWlsOiB0aGlzLmpzb25Db250ZW50LmNsaWVudF9lbWFpbCxcbiAgICAgICAgICAgICAgICBwcml2YXRlX2tleTogdGhpcy5qc29uQ29udGVudC5wcml2YXRlX2tleSxcbiAgICAgICAgICAgICAgICB1bml2ZXJzZV9kb21haW46IHRoaXMuanNvbkNvbnRlbnQudW5pdmVyc2VfZG9tYWluLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXdhaXQgdGhpcy5fY2hlY2tJc0dDRSgpKSB7XG4gICAgICAgICAgICBjb25zdCBbY2xpZW50X2VtYWlsLCB1bml2ZXJzZV9kb21haW5dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGdjcE1ldGFkYXRhLmluc3RhbmNlKCdzZXJ2aWNlLWFjY291bnRzL2RlZmF1bHQvZW1haWwnKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFVuaXZlcnNlRG9tYWluKCksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNsaWVudF9lbWFpbCwgdW5pdmVyc2VfZG9tYWluIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEdvb2dsZUF1dGhFeGNlcHRpb25NZXNzYWdlcy5OT19DUkVERU5USUFMU19GT1VORCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgb2J0YWluIGFuIHtAbGluayBBdXRoQ2xpZW50IGBBdXRoQ2xpZW50YH0gYmFzZWQgb24gdGhlXG4gICAgICogcHJvdmlkZWQgY29uZmlndXJhdGlvbi4gSWYgbm8gb3B0aW9ucyB3ZXJlIHBhc3NlZCwgdXNlIEFwcGxpY2F0aW9uXG4gICAgICogRGVmYXVsdCBDcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDbGllbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZWRDcmVkZW50aWFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5qc29uQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlQ2xpZW50RnJvbUpTT04odGhpcy5qc29uQ29udGVudCwgdGhpcy5jbGllbnRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMua2V5RmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLmtleUZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZyb21TdHJlYW1Bc3luYyhzdHJlYW0sIHRoaXMuY2xpZW50T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldEFwcGxpY2F0aW9uRGVmYXVsdEFzeW5jKHRoaXMuY2xpZW50T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkQ3JlZGVudGlhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsaWVudCB3aGljaCB3aWxsIGZldGNoIGFuIElEIHRva2VuIGZvciBhdXRob3JpemF0aW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXRBdWRpZW5jZSB0aGUgYXVkaWVuY2UgZm9yIHRoZSBmZXRjaGVkIElEIHRva2VuLlxuICAgICAqIEByZXR1cm5zIElkVG9rZW5DbGllbnQgZm9yIG1ha2luZyBIVFRQIGNhbGxzIGF1dGhlbnRpY2F0ZWQgd2l0aCBJRCB0b2tlbnMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SWRUb2tlbkNsaWVudCh0YXJnZXRBdWRpZW5jZSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBpZiAoISgnZmV0Y2hJZFRva2VuJyBpbiBjbGllbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmZXRjaCBJRCB0b2tlbiBpbiB0aGlzIGVudmlyb25tZW50LCB1c2UgR0NFIG9yIHNldCB0aGUgR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTIGVudmlyb25tZW50IHZhcmlhYmxlIHRvIGEgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzIEpTT04gZmlsZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGlkdG9rZW5jbGllbnRfMS5JZFRva2VuQ2xpZW50KHsgdGFyZ2V0QXVkaWVuY2UsIGlkVG9rZW5Qcm92aWRlcjogY2xpZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWNhbGx5IG9idGFpbiBhcHBsaWNhdGlvbiBkZWZhdWx0IGNyZWRlbnRpYWxzLCBhbmQgcmV0dXJuXG4gICAgICogYW4gYWNjZXNzIHRva2VuIGZvciBtYWtpbmcgcmVxdWVzdHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIHJldHVybiAoYXdhaXQgY2xpZW50LmdldEFjY2Vzc1Rva2VuKCkpLnRva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW4gdGhlIEhUVFAgaGVhZGVycyB0aGF0IHdpbGwgcHJvdmlkZSBhdXRob3JpemF0aW9uIGZvciBhIGdpdmVuXG4gICAgICogcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycyh1cmwpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5nZXRSZXF1ZXN0SGVhZGVycyh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW4gY3JlZGVudGlhbHMgZm9yIGEgcmVxdWVzdCwgdGhlbiBhdHRhY2ggdGhlIGFwcHJvcHJpYXRlIGhlYWRlcnMgdG9cbiAgICAgKiB0aGUgcmVxdWVzdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRzIEF4aW9zIG9yIFJlcXVlc3Qgb3B0aW9ucyBvbiB3aGljaCB0byBhdHRhY2ggdGhlIGhlYWRlcnNcbiAgICAgKi9cbiAgICBhc3luYyBhdXRob3JpemVSZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIGNvbnN0IHVybCA9IG9wdHMudXJsIHx8IG9wdHMudXJpO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgY2xpZW50LmdldFJlcXVlc3RIZWFkZXJzKHVybCk7XG4gICAgICAgIG9wdHMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24ob3B0cy5oZWFkZXJzIHx8IHt9LCBoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgb2J0YWluIGFwcGxpY2F0aW9uIGRlZmF1bHQgY3JlZGVudGlhbHMsIGFuZCBtYWtlIGFuXG4gICAgICogSFRUUCByZXF1ZXN0IHVzaW5nIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRzIEF4aW9zIHJlcXVlc3Qgb3B0aW9ucyBmb3IgdGhlIEhUVFAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIHJlcXVlc3Qob3B0cykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICByZXR1cm4gY2xpZW50LnJlcXVlc3Qob3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgY29tcHV0ZSBlbnZpcm9ubWVudCBpbiB3aGljaCB0aGUgY29kZSBpcyBydW5uaW5nLlxuICAgICAqL1xuICAgIGdldEVudigpIHtcbiAgICAgICAgcmV0dXJuICgwLCBlbnZEZXRlY3RfMS5nZXRFbnYpKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gdGhlIGdpdmVuIGRhdGEgd2l0aCB0aGUgY3VycmVudCBwcml2YXRlIGtleSwgb3IgZ28gb3V0XG4gICAgICogdG8gdGhlIElBTSBBUEkgdG8gc2lnbiBpdC5cbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBiZSBzaWduZWQuXG4gICAgICogQHBhcmFtIGVuZHBvaW50IEEgY3VzdG9tIGVuZHBvaW50IHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogc2lnbignZGF0YScsICdodHRwczovL2lhbWNyZWRlbnRpYWxzLmdvb2dsZWFwaXMuY29tL3YxL3Byb2plY3RzLy0vc2VydmljZUFjY291bnRzLycpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNpZ24oZGF0YSwgZW5kcG9pbnQpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgY29uc3QgdW5pdmVyc2UgPSBhd2FpdCB0aGlzLmdldFVuaXZlcnNlRG9tYWluKCk7XG4gICAgICAgIGVuZHBvaW50ID1cbiAgICAgICAgICAgIGVuZHBvaW50IHx8XG4gICAgICAgICAgICAgICAgYGh0dHBzOi8vaWFtY3JlZGVudGlhbHMuJHt1bml2ZXJzZX0vdjEvcHJvamVjdHMvLS9zZXJ2aWNlQWNjb3VudHMvYDtcbiAgICAgICAgaWYgKGNsaWVudCBpbnN0YW5jZW9mIGltcGVyc29uYXRlZF8xLkltcGVyc29uYXRlZCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkID0gYXdhaXQgY2xpZW50LnNpZ24oZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmVkLnNpZ25lZEJsb2I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3J5cHRvID0gKDAsIGNyeXB0b18xLmNyZWF0ZUNyeXB0bykoKTtcbiAgICAgICAgaWYgKGNsaWVudCBpbnN0YW5jZW9mIGp3dGNsaWVudF8xLkpXVCAmJiBjbGllbnQua2V5KSB7XG4gICAgICAgICAgICBjb25zdCBzaWduID0gYXdhaXQgY3J5cHRvLnNpZ24oY2xpZW50LmtleSwgZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVkcyA9IGF3YWl0IHRoaXMuZ2V0Q3JlZGVudGlhbHMoKTtcbiAgICAgICAgaWYgKCFjcmVkcy5jbGllbnRfZW1haWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNpZ24gZGF0YSB3aXRob3V0IGBjbGllbnRfZW1haWxgLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25CbG9iKGNyeXB0bywgY3JlZHMuY2xpZW50X2VtYWlsLCBkYXRhLCBlbmRwb2ludCk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25CbG9iKGNyeXB0bywgZW1haWxPclVuaXF1ZUlkLCBkYXRhLCBlbmRwb2ludCkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGVuZHBvaW50ICsgYCR7ZW1haWxPclVuaXF1ZUlkfTpzaWduQmxvYmApO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB1cmw6IHVybC5ocmVmLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNyeXB0by5lbmNvZGVCYXNlNjRTdHJpbmdVdGY4KGRhdGEpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXMuZGF0YS5zaWduZWRCbG9iO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQXV0aCA9IEdvb2dsZUF1dGg7XG4vKipcbiAqIEV4cG9ydCBEZWZhdWx0VHJhbnNwb3J0ZXIgYXMgYSBzdGF0aWMgcHJvcGVydHkgb2YgdGhlIGNsYXNzLlxuICovXG5Hb29nbGVBdXRoLkRlZmF1bHRUcmFuc3BvcnRlciA9IHRyYW5zcG9ydGVyc18xLkRlZmF1bHRUcmFuc3BvcnRlcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkdvb2dsZUF1dGgiLCJDTE9VRF9TREtfQ0xJRU5UX0lEIiwiY2hpbGRfcHJvY2Vzc18xIiwicmVxdWlyZSIsImZzIiwiZ2NwTWV0YWRhdGEiLCJvcyIsInBhdGgiLCJjcnlwdG9fMSIsInRyYW5zcG9ydGVyc18xIiwiY29tcHV0ZWNsaWVudF8xIiwiaWR0b2tlbmNsaWVudF8xIiwiZW52RGV0ZWN0XzEiLCJqd3RjbGllbnRfMSIsInJlZnJlc2hjbGllbnRfMSIsImltcGVyc29uYXRlZF8xIiwiZXh0ZXJuYWxjbGllbnRfMSIsImJhc2VleHRlcm5hbGNsaWVudF8xIiwiYXV0aGNsaWVudF8xIiwiZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRfMSIsInV0aWxfMSIsIkdvb2dsZUF1dGhFeGNlcHRpb25NZXNzYWdlcyIsIk5PX1BST0pFQ1RfSURfRk9VTkQiLCJOT19DUkVERU5USUFMU19GT1VORCIsIk5PX1VOSVZFUlNFX0RPTUFJTl9GT1VORCIsImlzR0NFIiwiY2hlY2tJc0dDRSIsImNvbnN0cnVjdG9yIiwib3B0cyIsInVuZGVmaW5lZCIsImpzb25Db250ZW50IiwiY2FjaGVkQ3JlZGVudGlhbCIsImNsaWVudE9wdGlvbnMiLCJfY2FjaGVkUHJvamVjdElkIiwicHJvamVjdElkIiwiYXV0aENsaWVudCIsImtleUZpbGVuYW1lIiwia2V5RmlsZSIsInNjb3BlcyIsImNyZWRlbnRpYWxzIiwidW5pdmVyc2VEb21haW4iLCJzZXRHYXBpY0pXVFZhbHVlcyIsImNsaWVudCIsImRlZmF1bHRTZXJ2aWNlUGF0aCIsInVzZUpXVEFjY2Vzc1dpdGhTY29wZSIsImRlZmF1bHRTY29wZXMiLCJnZXRQcm9qZWN0SWQiLCJjYWxsYmFjayIsImdldFByb2plY3RJZEFzeW5jIiwidGhlbiIsInIiLCJnZXRQcm9qZWN0SWRPcHRpb25hbCIsImUiLCJFcnJvciIsIm1lc3NhZ2UiLCJmaW5kQW5kQ2FjaGVQcm9qZWN0SWQiLCJnZXRQcm9kdWN0aW9uUHJvamVjdElkIiwiZ2V0RmlsZVByb2plY3RJZCIsImdldERlZmF1bHRTZXJ2aWNlUHJvamVjdElkIiwiZ2V0R0NFUHJvamVjdElkIiwiZ2V0RXh0ZXJuYWxBY2NvdW50Q2xpZW50UHJvamVjdElkIiwiX2ZpbmRQcm9qZWN0SWRQcm9taXNlIiwiZ2V0VW5pdmVyc2VEb21haW5Gcm9tTWV0YWRhdGFTZXJ2ZXIiLCJfYSIsInVuaXZlcnNlIiwiREVGQVVMVF9VTklWRVJTRSIsInJlc3BvbnNlIiwic3RhdHVzIiwiZ2V0VW5pdmVyc2VEb21haW4iLCJvcmlnaW5hbE9yQ2FtZWxPcHRpb25zIiwiZ2V0IiwiZ2V0Q2xpZW50IiwiZ2V0QW55U2NvcGVzIiwiZ2V0QXBwbGljYXRpb25EZWZhdWx0Iiwib3B0aW9uc09yQ2FsbGJhY2siLCJvcHRpb25zIiwiZ2V0QXBwbGljYXRpb25EZWZhdWx0QXN5bmMiLCJjcmVkZW50aWFsIiwicHJlcGFyZUFuZENhY2hlQURDIiwicXVvdGFQcm9qZWN0SWRPdmVycmlkZSIsInByb2Nlc3MiLCJlbnYiLCJfdHJ5R2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21FbnZpcm9ubWVudFZhcmlhYmxlIiwiSldUIiwiQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCIsIl90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbVdlbGxLbm93bkZpbGUiLCJfY2hlY2tJc0dDRSIsIkNvbXB1dGUiLCJxdW90YVByb2plY3RJZCIsImdldEdDUFJlc2lkZW5jeSIsImlzQXZhaWxhYmxlIiwiY3JlZGVudGlhbHNQYXRoIiwibGVuZ3RoIiwiX2dldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRmlsZVBhdGgiLCJsb2NhdGlvbiIsIl9pc1dpbmRvd3MiLCJob21lIiwiam9pbiIsImV4aXN0c1N5bmMiLCJmaWxlUGF0aCIsInJlYWxwYXRoU3luYyIsImxzdGF0U3luYyIsImlzRmlsZSIsImVyciIsInJlYWRTdHJlYW0iLCJjcmVhdGVSZWFkU3RyZWFtIiwiZnJvbVN0cmVhbSIsImZyb21JbXBlcnNvbmF0ZWRKU09OIiwianNvbiIsIl9iIiwiX2MiLCJfZCIsIl9lIiwidHlwZSIsIklNUEVSU09OQVRFRF9BQ0NPVU5UX1RZUEUiLCJzb3VyY2VfY3JlZGVudGlhbHMiLCJzZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmwiLCJzb3VyY2VDbGllbnQiLCJVc2VyUmVmcmVzaENsaWVudCIsImZyb21KU09OIiwiUmFuZ2VFcnJvciIsInRhcmdldFByaW5jaXBhbCIsImV4ZWMiLCJncm91cHMiLCJ0YXJnZXQiLCJ0YXJnZXRTY29wZXMiLCJJbXBlcnNvbmF0ZWQiLCJkZWxlZ2F0ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJwcmVmZXJyZWRVbml2ZXJzZURvbWFpbiIsIlVTRVJfUkVGUkVTSF9BQ0NPVU5UX1RZUEUiLCJFWFRFUk5BTF9BQ0NPVU5UX1RZUEUiLCJFeHRlcm5hbEFjY291bnRDbGllbnQiLCJFWFRFUk5BTF9BQ0NPVU5UX0FVVEhPUklaRURfVVNFUl9UWVBFIiwiRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQiLCJfY2FjaGVDbGllbnRGcm9tSlNPTiIsImlucHV0U3RyZWFtIiwiZnJvbVN0cmVhbUFzeW5jIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzIiwic2V0RW5jb2RpbmciLCJvbiIsImNodW5rIiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsImZyb21BUElLZXkiLCJhcGlLZXkiLCJzeXMiLCJwbGF0Zm9ybSIsInN1YnN0cmluZyIsInRvTG93ZXJDYXNlIiwic3Rkb3V0IiwiY29uZmlndXJhdGlvbiIsInByb3BlcnRpZXMiLCJjb3JlIiwicHJvamVjdCIsImNyZWRzIiwiZ2V0Q3JlZGVudGlhbHMiLCJnZXRDcmVkZW50aWFsc0FzeW5jIiwiY2xpZW50X2VtYWlsIiwiZ2V0VGFyZ2V0UHJpbmNpcGFsIiwic2VydmljZUFjY291bnRFbWFpbCIsImdldFNlcnZpY2VBY2NvdW50RW1haWwiLCJ1bml2ZXJzZV9kb21haW4iLCJwcml2YXRlX2tleSIsImFsbCIsImluc3RhbmNlIiwic3RyZWFtIiwiZ2V0SWRUb2tlbkNsaWVudCIsInRhcmdldEF1ZGllbmNlIiwiSWRUb2tlbkNsaWVudCIsImlkVG9rZW5Qcm92aWRlciIsImdldEFjY2Vzc1Rva2VuIiwidG9rZW4iLCJnZXRSZXF1ZXN0SGVhZGVycyIsInVybCIsImF1dGhvcml6ZVJlcXVlc3QiLCJ1cmkiLCJoZWFkZXJzIiwiYXNzaWduIiwicmVxdWVzdCIsImdldEVudiIsInNpZ24iLCJlbmRwb2ludCIsInNpZ25lZCIsInNpZ25lZEJsb2IiLCJjcnlwdG8iLCJjcmVhdGVDcnlwdG8iLCJrZXkiLCJzaWduQmxvYiIsImVtYWlsT3JVbmlxdWVJZCIsIlVSTCIsInJlcyIsIm1ldGhvZCIsImhyZWYiLCJwYXlsb2FkIiwiZW5jb2RlQmFzZTY0U3RyaW5nVXRmOCIsIkRlZmF1bHRUcmFuc3BvcnRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/googleauth.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/iam.js":
/*!****************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/iam.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.IAMAuth = void 0;\nclass IAMAuth {\n    /**\n     * IAM credentials.\n     *\n     * @param selector the iam authority selector\n     * @param token the token\n     * @constructor\n     */ constructor(selector, token){\n        this.selector = selector;\n        this.token = token;\n        this.selector = selector;\n        this.token = token;\n    }\n    /**\n     * Acquire the HTTP headers required to make an authenticated request.\n     */ getRequestHeaders() {\n        return {\n            \"x-goog-iam-authority-selector\": this.selector,\n            \"x-goog-iam-authorization-token\": this.token\n        };\n    }\n}\nexports.IAMAuth = IAMAuth;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2lhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLE1BQU1FO0lBQ0Y7Ozs7OztLQU1DLEdBQ0RDLFlBQVlDLFFBQVEsRUFBRUMsS0FBSyxDQUFFO1FBQ3pCLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0E7O0tBRUMsR0FDREMsb0JBQW9CO1FBQ2hCLE9BQU87WUFDSCxpQ0FBaUMsSUFBSSxDQUFDRixRQUFRO1lBQzlDLGtDQUFrQyxJQUFJLENBQUNDLEtBQUs7UUFDaEQ7SUFDSjtBQUNKO0FBQ0FMLGVBQWUsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pYW0uanM/YmNmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE0IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JQU1BdXRoID0gdm9pZCAwO1xuY2xhc3MgSUFNQXV0aCB7XG4gICAgLyoqXG4gICAgICogSUFNIGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIHRoZSBpYW0gYXV0aG9yaXR5IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHRva2VuIHRoZSB0b2tlblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCB0b2tlbikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjcXVpcmUgdGhlIEhUVFAgaGVhZGVycyByZXF1aXJlZCB0byBtYWtlIGFuIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXRSZXF1ZXN0SGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd4LWdvb2ctaWFtLWF1dGhvcml0eS1zZWxlY3Rvcic6IHRoaXMuc2VsZWN0b3IsXG4gICAgICAgICAgICAneC1nb29nLWlhbS1hdXRob3JpemF0aW9uLXRva2VuJzogdGhpcy50b2tlbixcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLklBTUF1dGggPSBJQU1BdXRoO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSUFNQXV0aCIsImNvbnN0cnVjdG9yIiwic2VsZWN0b3IiLCJ0b2tlbiIsImdldFJlcXVlc3RIZWFkZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/iam.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/identitypoolclient.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.IdentityPoolClient = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst util_2 = __webpack_require__(/*! ../util */ \"(action-browser)/./node_modules/google-auth-library/build/src/util.js\");\n// fs.readfile is undefined in browser karma tests causing\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\n// src/index.ts.\n// Fallback to void function to avoid promisify throwing a TypeError.\nconst readFile = (0, util_1.promisify)((_a = fs.readFile) !== null && _a !== void 0 ? _a : ()=>{});\nconst realpath = (0, util_1.promisify)((_b = fs.realpath) !== null && _b !== void 0 ? _b : ()=>{});\nconst lstat = (0, util_1.promisify)((_c = fs.lstat) !== null && _c !== void 0 ? _c : ()=>{});\n/**\n * Defines the Url-sourced and file-sourced external account clients mainly\n * used for K8s and Azure workloads.\n */ class IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiate an IdentityPoolClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid file-sourced or\n     * url-sourced credential or a workforce pool user project is provided\n     * with a non workforce audience.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file. The camelCased options\n     *   are aliases for the snake_cased options.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        super(options, additionalOptions);\n        const opts = (0, util_2.originalOrCamelOptions)(options);\n        const credentialSource = opts.get(\"credential_source\");\n        const credentialSourceOpts = (0, util_2.originalOrCamelOptions)(credentialSource);\n        this.file = credentialSourceOpts.get(\"file\");\n        this.url = credentialSourceOpts.get(\"url\");\n        this.headers = credentialSourceOpts.get(\"headers\");\n        if (this.file && this.url) {\n            throw new Error('No valid Identity Pool \"credential_source\" provided, must be either file or url.');\n        } else if (this.file && !this.url) {\n            this.credentialSourceType = \"file\";\n        } else if (!this.file && this.url) {\n            this.credentialSourceType = \"url\";\n        } else {\n            throw new Error('No valid Identity Pool \"credential_source\" provided, must be either file or url.');\n        }\n        const formatOpts = (0, util_2.originalOrCamelOptions)(credentialSourceOpts.get(\"format\"));\n        // Text is the default format type.\n        this.formatType = formatOpts.get(\"type\") || \"text\";\n        this.formatSubjectTokenFieldName = formatOpts.get(\"subject_token_field_name\");\n        if (this.formatType !== \"json\" && this.formatType !== \"text\") {\n            throw new Error(`Invalid credential_source format \"${this.formatType}\"`);\n        }\n        if (this.formatType === \"json\" && !this.formatSubjectTokenFieldName) {\n            throw new Error(\"Missing subject_token_field_name for JSON credential_source format\");\n        }\n    }\n    /**\n     * Triggered when a external subject token is needed to be exchanged for a GCP\n     * access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this either retrieves the local credential from a file location (k8s\n     * workload) or by sending a GET request to a local metadata server (Azure\n     * workloads).\n     * @return A promise that resolves with the external subject token.\n     */ async retrieveSubjectToken() {\n        if (this.file) {\n            return await this.getTokenFromFile(this.file, this.formatType, this.formatSubjectTokenFieldName);\n        }\n        return await this.getTokenFromUrl(this.url, this.formatType, this.formatSubjectTokenFieldName, this.headers);\n    }\n    /**\n     * Looks up the external subject token in the file path provided and\n     * resolves with that token.\n     * @param file The file path where the external credential is located.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @return A promise that resolves with the external subject token.\n     */ async getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = await realpath(filePath);\n            if (!(await lstat(filePath)).isFile()) {\n                throw new Error();\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        let subjectToken;\n        const rawText = await readFile(filePath, {\n            encoding: \"utf8\"\n        });\n        if (formatType === \"text\") {\n            subjectToken = rawText;\n        } else if (formatType === \"json\" && formatSubjectTokenFieldName) {\n            const json = JSON.parse(rawText);\n            subjectToken = json[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error(\"Unable to parse the subject_token from the credential_source file\");\n        }\n        return subjectToken;\n    }\n    /**\n     * Sends a GET request to the URL provided and resolves with the returned\n     * external subject token.\n     * @param url The URL to call to retrieve the subject token. This is typically\n     *   a local metadata server.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @param headers The optional additional headers to send with the request to\n     *   the metadata server url.\n     * @return A promise that resolves with the external subject token.\n     */ async getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {\n        const opts = {\n            url,\n            method: \"GET\",\n            headers,\n            responseType: formatType\n        };\n        let subjectToken;\n        if (formatType === \"text\") {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data;\n        } else if (formatType === \"json\" && formatSubjectTokenFieldName) {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error(\"Unable to parse the subject_token from the credential_source URL\");\n        }\n        return subjectToken;\n    }\n}\nexports.IdentityPoolClient = IdentityPoolClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2lkZW50aXR5cG9vbGNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQyxJQUFJQSxJQUFJQyxJQUFJQztBQUNaQyw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMEJBQTBCLEdBQUcsS0FBSztBQUNsQyxNQUFNRyxLQUFLQyxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLGtCQUFNO0FBQzdCLE1BQU1FLHVCQUF1QkYsbUJBQU9BLENBQUMsc0hBQXNCO0FBQzNELE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDLHNGQUFTO0FBQ2hDLDBEQUEwRDtBQUMxRCx5RUFBeUU7QUFDekUsZ0JBQWdCO0FBQ2hCLHFFQUFxRTtBQUNyRSxNQUFNSSxXQUFXLENBQUMsR0FBR0gsT0FBT0ksU0FBUyxFQUFFLENBQUNkLEtBQUtRLEdBQUdLLFFBQVEsTUFBTSxRQUFRYixPQUFPLEtBQUssSUFBSUEsS0FBTSxLQUFRO0FBQ3BHLE1BQU1lLFdBQVcsQ0FBQyxHQUFHTCxPQUFPSSxTQUFTLEVBQUUsQ0FBQ2IsS0FBS08sR0FBR08sUUFBUSxNQUFNLFFBQVFkLE9BQU8sS0FBSyxJQUFJQSxLQUFNLEtBQVE7QUFDcEcsTUFBTWUsUUFBUSxDQUFDLEdBQUdOLE9BQU9JLFNBQVMsRUFBRSxDQUFDWixLQUFLTSxHQUFHUSxLQUFLLE1BQU0sUUFBUWQsT0FBTyxLQUFLLElBQUlBLEtBQU0sS0FBUTtBQUM5Rjs7O0NBR0MsR0FDRCxNQUFNSywyQkFBMkJJLHFCQUFxQk0seUJBQXlCO0lBQzNFOzs7Ozs7Ozs7Ozs7O0tBYUMsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxpQkFBaUIsQ0FBRTtRQUNwQyxLQUFLLENBQUNELFNBQVNDO1FBQ2YsTUFBTUMsT0FBTyxDQUFDLEdBQUdULE9BQU9VLHNCQUFzQixFQUFFSDtRQUNoRCxNQUFNSSxtQkFBbUJGLEtBQUtHLEdBQUcsQ0FBQztRQUNsQyxNQUFNQyx1QkFBdUIsQ0FBQyxHQUFHYixPQUFPVSxzQkFBc0IsRUFBRUM7UUFDaEUsSUFBSSxDQUFDRyxJQUFJLEdBQUdELHFCQUFxQkQsR0FBRyxDQUFDO1FBQ3JDLElBQUksQ0FBQ0csR0FBRyxHQUFHRixxQkFBcUJELEdBQUcsQ0FBQztRQUNwQyxJQUFJLENBQUNJLE9BQU8sR0FBR0gscUJBQXFCRCxHQUFHLENBQUM7UUFDeEMsSUFBSSxJQUFJLENBQUNFLElBQUksSUFBSSxJQUFJLENBQUNDLEdBQUcsRUFBRTtZQUN2QixNQUFNLElBQUlFLE1BQU07UUFDcEIsT0FDSyxJQUFJLElBQUksQ0FBQ0gsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDQyxHQUFHLEVBQUU7WUFDN0IsSUFBSSxDQUFDRyxvQkFBb0IsR0FBRztRQUNoQyxPQUNLLElBQUksQ0FBQyxJQUFJLENBQUNKLElBQUksSUFBSSxJQUFJLENBQUNDLEdBQUcsRUFBRTtZQUM3QixJQUFJLENBQUNHLG9CQUFvQixHQUFHO1FBQ2hDLE9BQ0s7WUFDRCxNQUFNLElBQUlELE1BQU07UUFDcEI7UUFDQSxNQUFNRSxhQUFhLENBQUMsR0FBR25CLE9BQU9VLHNCQUFzQixFQUFFRyxxQkFBcUJELEdBQUcsQ0FBQztRQUMvRSxtQ0FBbUM7UUFDbkMsSUFBSSxDQUFDUSxVQUFVLEdBQUdELFdBQVdQLEdBQUcsQ0FBQyxXQUFXO1FBQzVDLElBQUksQ0FBQ1MsMkJBQTJCLEdBQUdGLFdBQVdQLEdBQUcsQ0FBQztRQUNsRCxJQUFJLElBQUksQ0FBQ1EsVUFBVSxLQUFLLFVBQVUsSUFBSSxDQUFDQSxVQUFVLEtBQUssUUFBUTtZQUMxRCxNQUFNLElBQUlILE1BQU0sQ0FBQyxrQ0FBa0MsRUFBRSxJQUFJLENBQUNHLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDM0U7UUFDQSxJQUFJLElBQUksQ0FBQ0EsVUFBVSxLQUFLLFVBQVUsQ0FBQyxJQUFJLENBQUNDLDJCQUEyQixFQUFFO1lBQ2pFLE1BQU0sSUFBSUosTUFBTTtRQUNwQjtJQUNKO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0QsTUFBTUssdUJBQXVCO1FBQ3pCLElBQUksSUFBSSxDQUFDUixJQUFJLEVBQUU7WUFDWCxPQUFPLE1BQU0sSUFBSSxDQUFDUyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNULElBQUksRUFBRSxJQUFJLENBQUNNLFVBQVUsRUFBRSxJQUFJLENBQUNDLDJCQUEyQjtRQUNuRztRQUNBLE9BQU8sTUFBTSxJQUFJLENBQUNHLGVBQWUsQ0FBQyxJQUFJLENBQUNULEdBQUcsRUFBRSxJQUFJLENBQUNLLFVBQVUsRUFBRSxJQUFJLENBQUNDLDJCQUEyQixFQUFFLElBQUksQ0FBQ0wsT0FBTztJQUMvRztJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNELE1BQU1PLGlCQUFpQkUsUUFBUSxFQUFFTCxVQUFVLEVBQUVDLDJCQUEyQixFQUFFO1FBQ3RFLDBFQUEwRTtRQUMxRSxpQkFBaUI7UUFDakIsSUFBSTtZQUNBLHdFQUF3RTtZQUN4RSxxQkFBcUI7WUFDckJJLFdBQVcsTUFBTXRCLFNBQVNzQjtZQUMxQixJQUFJLENBQUMsQ0FBQyxNQUFNckIsTUFBTXFCLFNBQVEsRUFBR0MsTUFBTSxJQUFJO2dCQUNuQyxNQUFNLElBQUlUO1lBQ2Q7UUFDSixFQUNBLE9BQU9VLEtBQUs7WUFDUixJQUFJQSxlQUFlVixPQUFPO2dCQUN0QlUsSUFBSUMsT0FBTyxHQUFHLENBQUMsWUFBWSxFQUFFSCxTQUFTLHNDQUFzQyxFQUFFRSxJQUFJQyxPQUFPLENBQUMsQ0FBQztZQUMvRjtZQUNBLE1BQU1EO1FBQ1Y7UUFDQSxJQUFJRTtRQUNKLE1BQU1DLFVBQVUsTUFBTTdCLFNBQVN3QixVQUFVO1lBQUVNLFVBQVU7UUFBTztRQUM1RCxJQUFJWCxlQUFlLFFBQVE7WUFDdkJTLGVBQWVDO1FBQ25CLE9BQ0ssSUFBSVYsZUFBZSxVQUFVQyw2QkFBNkI7WUFDM0QsTUFBTVcsT0FBT0MsS0FBS0MsS0FBSyxDQUFDSjtZQUN4QkQsZUFBZUcsSUFBSSxDQUFDWCw0QkFBNEI7UUFDcEQ7UUFDQSxJQUFJLENBQUNRLGNBQWM7WUFDZixNQUFNLElBQUlaLE1BQU07UUFDcEI7UUFDQSxPQUFPWTtJQUNYO0lBQ0E7Ozs7Ozs7Ozs7OztLQVlDLEdBQ0QsTUFBTUwsZ0JBQWdCVCxHQUFHLEVBQUVLLFVBQVUsRUFBRUMsMkJBQTJCLEVBQUVMLE9BQU8sRUFBRTtRQUN6RSxNQUFNUCxPQUFPO1lBQ1RNO1lBQ0FvQixRQUFRO1lBQ1JuQjtZQUNBb0IsY0FBY2hCO1FBQ2xCO1FBQ0EsSUFBSVM7UUFDSixJQUFJVCxlQUFlLFFBQVE7WUFDdkIsTUFBTWlCLFdBQVcsTUFBTSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsT0FBTyxDQUFDOUI7WUFDaERvQixlQUFlUSxTQUFTRyxJQUFJO1FBQ2hDLE9BQ0ssSUFBSXBCLGVBQWUsVUFBVUMsNkJBQTZCO1lBQzNELE1BQU1nQixXQUFXLE1BQU0sSUFBSSxDQUFDQyxXQUFXLENBQUNDLE9BQU8sQ0FBQzlCO1lBQ2hEb0IsZUFBZVEsU0FBU0csSUFBSSxDQUFDbkIsNEJBQTRCO1FBQzdEO1FBQ0EsSUFBSSxDQUFDUSxjQUFjO1lBQ2YsTUFBTSxJQUFJWixNQUFNO1FBQ3BCO1FBQ0EsT0FBT1k7SUFDWDtBQUNKO0FBQ0FwQywwQkFBMEIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pZGVudGl0eXBvb2xjbGllbnQuanM/YzNhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9hLCBfYiwgX2M7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklkZW50aXR5UG9vbENsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2Jhc2VleHRlcm5hbGNsaWVudFwiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLy8gZnMucmVhZGZpbGUgaXMgdW5kZWZpbmVkIGluIGJyb3dzZXIga2FybWEgdGVzdHMgY2F1c2luZ1xuLy8gYG5wbSBydW4gYnJvd3Nlci10ZXN0YCB0byBmYWlsIGFzIHRlc3Qub2F1dGgyLnRzIGltcG9ydHMgdGhpcyBmaWxlIHZpYVxuLy8gc3JjL2luZGV4LnRzLlxuLy8gRmFsbGJhY2sgdG8gdm9pZCBmdW5jdGlvbiB0byBhdm9pZCBwcm9taXNpZnkgdGhyb3dpbmcgYSBUeXBlRXJyb3IuXG5jb25zdCByZWFkRmlsZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSgoX2EgPSBmcy5yZWFkRmlsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKCgpID0+IHsgfSkpO1xuY29uc3QgcmVhbHBhdGggPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoKF9iID0gZnMucmVhbHBhdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICgoKSA9PiB7IH0pKTtcbmNvbnN0IGxzdGF0ID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKChfYyA9IGZzLmxzdGF0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoKCkgPT4geyB9KSk7XG4vKipcbiAqIERlZmluZXMgdGhlIFVybC1zb3VyY2VkIGFuZCBmaWxlLXNvdXJjZWQgZXh0ZXJuYWwgYWNjb3VudCBjbGllbnRzIG1haW5seVxuICogdXNlZCBmb3IgSzhzIGFuZCBBenVyZSB3b3JrbG9hZHMuXG4gKi9cbmNsYXNzIElkZW50aXR5UG9vbENsaWVudCBleHRlbmRzIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGFuIElkZW50aXR5UG9vbENsaWVudCBpbnN0YW5jZSB1c2luZyB0aGUgcHJvdmlkZWQgSlNPTlxuICAgICAqIG9iamVjdCBsb2FkZWQgZnJvbSBhbiBleHRlcm5hbCBhY2NvdW50IGNyZWRlbnRpYWxzIGZpbGUuXG4gICAgICogQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBjcmVkZW50aWFsIGlzIG5vdCBhIHZhbGlkIGZpbGUtc291cmNlZCBvclxuICAgICAqIHVybC1zb3VyY2VkIGNyZWRlbnRpYWwgb3IgYSB3b3JrZm9yY2UgcG9vbCB1c2VyIHByb2plY3QgaXMgcHJvdmlkZWRcbiAgICAgKiB3aXRoIGEgbm9uIHdvcmtmb3JjZSBhdWRpZW5jZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZXh0ZXJuYWwgYWNjb3VudCBvcHRpb25zIG9iamVjdCB0eXBpY2FsbHkgbG9hZGVkXG4gICAgICogICBmcm9tIHRoZSBleHRlcm5hbCBhY2NvdW50IEpTT04gY3JlZGVudGlhbCBmaWxlLiBUaGUgY2FtZWxDYXNlZCBvcHRpb25zXG4gICAgICogICBhcmUgYWxpYXNlcyBmb3IgdGhlIHNuYWtlX2Nhc2VkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zICoqREVQUkVDQVRFRCwgYWxsIG9wdGlvbnMgYXJlIGF2YWlsYWJsZSBpbiB0aGVcbiAgICAgKiAgIGBvcHRpb25zYCBwYXJhbWV0ZXIuKiogT3B0aW9uYWwgYWRkaXRpb25hbCBiZWhhdmlvciBjdXN0b21pemF0aW9uIG9wdGlvbnMuXG4gICAgICogICBUaGVzZSBjdXJyZW50bHkgY3VzdG9taXplIGV4cGlyYXRpb24gdGhyZXNob2xkIHRpbWUgYW5kIHdoZXRoZXIgdG8gcmV0cnlcbiAgICAgKiAgIG9uIDQwMS80MDMgQVBJIHJlcXVlc3QgZXJyb3JzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9ICgwLCB1dGlsXzIub3JpZ2luYWxPckNhbWVsT3B0aW9ucykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxTb3VyY2UgPSBvcHRzLmdldCgnY3JlZGVudGlhbF9zb3VyY2UnKTtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbFNvdXJjZU9wdHMgPSAoMCwgdXRpbF8yLm9yaWdpbmFsT3JDYW1lbE9wdGlvbnMpKGNyZWRlbnRpYWxTb3VyY2UpO1xuICAgICAgICB0aGlzLmZpbGUgPSBjcmVkZW50aWFsU291cmNlT3B0cy5nZXQoJ2ZpbGUnKTtcbiAgICAgICAgdGhpcy51cmwgPSBjcmVkZW50aWFsU291cmNlT3B0cy5nZXQoJ3VybCcpO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBjcmVkZW50aWFsU291cmNlT3B0cy5nZXQoJ2hlYWRlcnMnKTtcbiAgICAgICAgaWYgKHRoaXMuZmlsZSAmJiB0aGlzLnVybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBJZGVudGl0eSBQb29sIFwiY3JlZGVudGlhbF9zb3VyY2VcIiBwcm92aWRlZCwgbXVzdCBiZSBlaXRoZXIgZmlsZSBvciB1cmwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5maWxlICYmICF0aGlzLnVybCkge1xuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFsU291cmNlVHlwZSA9ICdmaWxlJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5maWxlICYmIHRoaXMudXJsKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxTb3VyY2VUeXBlID0gJ3VybCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIElkZW50aXR5IFBvb2wgXCJjcmVkZW50aWFsX3NvdXJjZVwiIHByb3ZpZGVkLCBtdXN0IGJlIGVpdGhlciBmaWxlIG9yIHVybC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXRPcHRzID0gKDAsIHV0aWxfMi5vcmlnaW5hbE9yQ2FtZWxPcHRpb25zKShjcmVkZW50aWFsU291cmNlT3B0cy5nZXQoJ2Zvcm1hdCcpKTtcbiAgICAgICAgLy8gVGV4dCBpcyB0aGUgZGVmYXVsdCBmb3JtYXQgdHlwZS5cbiAgICAgICAgdGhpcy5mb3JtYXRUeXBlID0gZm9ybWF0T3B0cy5nZXQoJ3R5cGUnKSB8fCAndGV4dCc7XG4gICAgICAgIHRoaXMuZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lID0gZm9ybWF0T3B0cy5nZXQoJ3N1YmplY3RfdG9rZW5fZmllbGRfbmFtZScpO1xuICAgICAgICBpZiAodGhpcy5mb3JtYXRUeXBlICE9PSAnanNvbicgJiYgdGhpcy5mb3JtYXRUeXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjcmVkZW50aWFsX3NvdXJjZSBmb3JtYXQgXCIke3RoaXMuZm9ybWF0VHlwZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdFR5cGUgPT09ICdqc29uJyAmJiAhdGhpcy5mb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzdWJqZWN0X3Rva2VuX2ZpZWxkX25hbWUgZm9yIEpTT04gY3JlZGVudGlhbF9zb3VyY2UgZm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSBleHRlcm5hbCBzdWJqZWN0IHRva2VuIGlzIG5lZWRlZCB0byBiZSBleGNoYW5nZWQgZm9yIGEgR0NQXG4gICAgICogYWNjZXNzIHRva2VuIHZpYSBHQ1AgU1RTIGVuZHBvaW50LlxuICAgICAqIFRoaXMgdXNlcyB0aGUgYG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2VgIG9iamVjdCB0byBmaWd1cmUgb3V0IGhvd1xuICAgICAqIHRvIHJldHJpZXZlIHRoZSB0b2tlbiB1c2luZyB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gSW4gdGhpcyBjYXNlLFxuICAgICAqIHRoaXMgZWl0aGVyIHJldHJpZXZlcyB0aGUgbG9jYWwgY3JlZGVudGlhbCBmcm9tIGEgZmlsZSBsb2NhdGlvbiAoazhzXG4gICAgICogd29ya2xvYWQpIG9yIGJ5IHNlbmRpbmcgYSBHRVQgcmVxdWVzdCB0byBhIGxvY2FsIG1ldGFkYXRhIHNlcnZlciAoQXp1cmVcbiAgICAgKiB3b3JrbG9hZHMpLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZVN1YmplY3RUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0VG9rZW5Gcm9tRmlsZSh0aGlzLmZpbGUsIHRoaXMuZm9ybWF0VHlwZSwgdGhpcy5mb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFRva2VuRnJvbVVybCh0aGlzLnVybCwgdGhpcy5mb3JtYXRUeXBlLCB0aGlzLmZvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZSwgdGhpcy5oZWFkZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgdGhlIGV4dGVybmFsIHN1YmplY3QgdG9rZW4gaW4gdGhlIGZpbGUgcGF0aCBwcm92aWRlZCBhbmRcbiAgICAgKiByZXNvbHZlcyB3aXRoIHRoYXQgdG9rZW4uXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgcGF0aCB3aGVyZSB0aGUgZXh0ZXJuYWwgY3JlZGVudGlhbCBpcyBsb2NhdGVkLlxuICAgICAqIEBwYXJhbSBmb3JtYXRUeXBlIFRoZSB0b2tlbiBmaWxlIG9yIFVSTCByZXNwb25zZSB0eXBlIChKU09OIG9yIHRleHQpLlxuICAgICAqIEBwYXJhbSBmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUgRm9yIEpTT04gcmVzcG9uc2UgdHlwZXMsIHRoaXMgaXMgdGhlXG4gICAgICogICBzdWJqZWN0X3Rva2VuIGZpZWxkIG5hbWUuIEZvciBBenVyZSwgdGhpcyBpcyBhY2Nlc3NfdG9rZW4uIEZvciB0ZXh0XG4gICAgICogICByZXNwb25zZSB0eXBlcywgdGhpcyBpcyBpZ25vcmVkLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUb2tlbkZyb21GaWxlKGZpbGVQYXRoLCBmb3JtYXRUeXBlLCBmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIGEgZmlsZSBhdCB0aGUgcGF0aC4gbHN0YXRTeW5jIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXNcbiAgICAgICAgLy8gbm90aGluZyB0aGVyZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgcGF0aCB0byBhY3R1YWwgZmlsZSBpbiBjYXNlIG9mIHN5bWxpbmsuIEV4cGVjdCBhIHRocm93biBlcnJvclxuICAgICAgICAgICAgLy8gaWYgbm90IHJlc29sdmFibGUuXG4gICAgICAgICAgICBmaWxlUGF0aCA9IGF3YWl0IHJlYWxwYXRoKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmICghKGF3YWl0IGxzdGF0KGZpbGVQYXRoKSkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBUaGUgZmlsZSBhdCAke2ZpbGVQYXRofSBkb2VzIG5vdCBleGlzdCwgb3IgaXQgaXMgbm90IGEgZmlsZS4gJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJqZWN0VG9rZW47XG4gICAgICAgIGNvbnN0IHJhd1RleHQgPSBhd2FpdCByZWFkRmlsZShmaWxlUGF0aCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgICAgICBpZiAoZm9ybWF0VHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBzdWJqZWN0VG9rZW4gPSByYXdUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcm1hdFR5cGUgPT09ICdqc29uJyAmJiBmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHJhd1RleHQpO1xuICAgICAgICAgICAgc3ViamVjdFRva2VuID0ganNvbltmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3ViamVjdFRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSB0aGUgc3ViamVjdF90b2tlbiBmcm9tIHRoZSBjcmVkZW50aWFsX3NvdXJjZSBmaWxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YmplY3RUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBHRVQgcmVxdWVzdCB0byB0aGUgVVJMIHByb3ZpZGVkIGFuZCByZXNvbHZlcyB3aXRoIHRoZSByZXR1cm5lZFxuICAgICAqIGV4dGVybmFsIHN1YmplY3QgdG9rZW4uXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIGNhbGwgdG8gcmV0cmlldmUgdGhlIHN1YmplY3QgdG9rZW4uIFRoaXMgaXMgdHlwaWNhbGx5XG4gICAgICogICBhIGxvY2FsIG1ldGFkYXRhIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gZm9ybWF0VHlwZSBUaGUgdG9rZW4gZmlsZSBvciBVUkwgcmVzcG9uc2UgdHlwZSAoSlNPTiBvciB0ZXh0KS5cbiAgICAgKiBAcGFyYW0gZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lIEZvciBKU09OIHJlc3BvbnNlIHR5cGVzLCB0aGlzIGlzIHRoZVxuICAgICAqICAgc3ViamVjdF90b2tlbiBmaWVsZCBuYW1lLiBGb3IgQXp1cmUsIHRoaXMgaXMgYWNjZXNzX3Rva2VuLiBGb3IgdGV4dFxuICAgICAqICAgcmVzcG9uc2UgdHlwZXMsIHRoaXMgaXMgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0gaGVhZGVycyBUaGUgb3B0aW9uYWwgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdCB0b1xuICAgICAqICAgdGhlIG1ldGFkYXRhIHNlcnZlciB1cmwuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBleHRlcm5hbCBzdWJqZWN0IHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRva2VuRnJvbVVybCh1cmwsIGZvcm1hdFR5cGUsIGZvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZSwgaGVhZGVycykge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6IGZvcm1hdFR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdWJqZWN0VG9rZW47XG4gICAgICAgIGlmIChmb3JtYXRUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICAgICAgc3ViamVjdFRva2VuID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JtYXRUeXBlID09PSAnanNvbicgJiYgZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIHN1YmplY3RUb2tlbiA9IHJlc3BvbnNlLmRhdGFbZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1YmplY3RUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgdGhlIHN1YmplY3RfdG9rZW4gZnJvbSB0aGUgY3JlZGVudGlhbF9zb3VyY2UgVVJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YmplY3RUb2tlbjtcbiAgICB9XG59XG5leHBvcnRzLklkZW50aXR5UG9vbENsaWVudCA9IElkZW50aXR5UG9vbENsaWVudDtcbiJdLCJuYW1lcyI6WyJfYSIsIl9iIiwiX2MiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIklkZW50aXR5UG9vbENsaWVudCIsImZzIiwicmVxdWlyZSIsInV0aWxfMSIsImJhc2VleHRlcm5hbGNsaWVudF8xIiwidXRpbF8yIiwicmVhZEZpbGUiLCJwcm9taXNpZnkiLCJyZWFscGF0aCIsImxzdGF0IiwiQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImFkZGl0aW9uYWxPcHRpb25zIiwib3B0cyIsIm9yaWdpbmFsT3JDYW1lbE9wdGlvbnMiLCJjcmVkZW50aWFsU291cmNlIiwiZ2V0IiwiY3JlZGVudGlhbFNvdXJjZU9wdHMiLCJmaWxlIiwidXJsIiwiaGVhZGVycyIsIkVycm9yIiwiY3JlZGVudGlhbFNvdXJjZVR5cGUiLCJmb3JtYXRPcHRzIiwiZm9ybWF0VHlwZSIsImZvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZSIsInJldHJpZXZlU3ViamVjdFRva2VuIiwiZ2V0VG9rZW5Gcm9tRmlsZSIsImdldFRva2VuRnJvbVVybCIsImZpbGVQYXRoIiwiaXNGaWxlIiwiZXJyIiwibWVzc2FnZSIsInN1YmplY3RUb2tlbiIsInJhd1RleHQiLCJlbmNvZGluZyIsImpzb24iLCJKU09OIiwicGFyc2UiLCJtZXRob2QiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZSIsInRyYW5zcG9ydGVyIiwicmVxdWVzdCIsImRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/idtokenclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.IdTokenClient = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass IdTokenClient extends oauth2client_1.OAuth2Client {\n    /**\n     * Google ID Token client\n     *\n     * Retrieve ID token from the metadata server.\n     * See: https://cloud.google.com/docs/authentication/get-id-token#metadata-server\n     */ constructor(options){\n        super(options);\n        this.targetAudience = options.targetAudience;\n        this.idTokenProvider = options.idTokenProvider;\n    }\n    async getRequestMetadataAsync(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        if (!this.credentials.id_token || !this.credentials.expiry_date || this.isTokenExpiring()) {\n            const idToken = await this.idTokenProvider.fetchIdToken(this.targetAudience);\n            this.credentials = {\n                id_token: idToken,\n                expiry_date: this.getIdTokenExpiryDate(idToken)\n            };\n        }\n        const headers = {\n            Authorization: \"Bearer \" + this.credentials.id_token\n        };\n        return {\n            headers\n        };\n    }\n    getIdTokenExpiryDate(idToken) {\n        const payloadB64 = idToken.split(\".\")[1];\n        if (payloadB64) {\n            const payload = JSON.parse(Buffer.from(payloadB64, \"base64\").toString(\"ascii\"));\n            return payload.exp * 1000;\n        }\n    }\n}\nexports.IdTokenClient = IdTokenClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2lkdG9rZW5jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBRyxLQUFLO0FBQzdCLE1BQU1HLGlCQUFpQkMsbUJBQU9BLENBQUMsMEdBQWdCO0FBQy9DLE1BQU1GLHNCQUFzQkMsZUFBZUUsWUFBWTtJQUNuRDs7Ozs7S0FLQyxHQUNEQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsY0FBYyxHQUFHRCxRQUFRQyxjQUFjO1FBQzVDLElBQUksQ0FBQ0MsZUFBZSxHQUFHRixRQUFRRSxlQUFlO0lBQ2xEO0lBQ0EsTUFBTUMsd0JBQ04sNkRBQTZEO0lBQzdEQyxHQUFHLEVBQUU7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDQyxXQUFXLENBQUNDLFFBQVEsSUFDMUIsQ0FBQyxJQUFJLENBQUNELFdBQVcsQ0FBQ0UsV0FBVyxJQUM3QixJQUFJLENBQUNDLGVBQWUsSUFBSTtZQUN4QixNQUFNQyxVQUFVLE1BQU0sSUFBSSxDQUFDUCxlQUFlLENBQUNRLFlBQVksQ0FBQyxJQUFJLENBQUNULGNBQWM7WUFDM0UsSUFBSSxDQUFDSSxXQUFXLEdBQUc7Z0JBQ2ZDLFVBQVVHO2dCQUNWRixhQUFhLElBQUksQ0FBQ0ksb0JBQW9CLENBQUNGO1lBQzNDO1FBQ0o7UUFDQSxNQUFNRyxVQUFVO1lBQ1pDLGVBQWUsWUFBWSxJQUFJLENBQUNSLFdBQVcsQ0FBQ0MsUUFBUTtRQUN4RDtRQUNBLE9BQU87WUFBRU07UUFBUTtJQUNyQjtJQUNBRCxxQkFBcUJGLE9BQU8sRUFBRTtRQUMxQixNQUFNSyxhQUFhTCxRQUFRTSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDeEMsSUFBSUQsWUFBWTtZQUNaLE1BQU1FLFVBQVVDLEtBQUtDLEtBQUssQ0FBQ0MsT0FBT0MsSUFBSSxDQUFDTixZQUFZLFVBQVVPLFFBQVEsQ0FBQztZQUN0RSxPQUFPTCxRQUFRTSxHQUFHLEdBQUc7UUFDekI7SUFDSjtBQUNKO0FBQ0E3QixxQkFBcUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pZHRva2VuY2xpZW50LmpzPzJiMzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSWRUb2tlbkNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IG9hdXRoMmNsaWVudF8xID0gcmVxdWlyZShcIi4vb2F1dGgyY2xpZW50XCIpO1xuY2xhc3MgSWRUb2tlbkNsaWVudCBleHRlbmRzIG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR29vZ2xlIElEIFRva2VuIGNsaWVudFxuICAgICAqXG4gICAgICogUmV0cmlldmUgSUQgdG9rZW4gZnJvbSB0aGUgbWV0YWRhdGEgc2VydmVyLlxuICAgICAqIFNlZTogaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RvY3MvYXV0aGVudGljYXRpb24vZ2V0LWlkLXRva2VuI21ldGFkYXRhLXNlcnZlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMudGFyZ2V0QXVkaWVuY2UgPSBvcHRpb25zLnRhcmdldEF1ZGllbmNlO1xuICAgICAgICB0aGlzLmlkVG9rZW5Qcm92aWRlciA9IG9wdGlvbnMuaWRUb2tlblByb3ZpZGVyO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgdXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5jcmVkZW50aWFscy5pZF90b2tlbiB8fFxuICAgICAgICAgICAgIXRoaXMuY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGUgfHxcbiAgICAgICAgICAgIHRoaXMuaXNUb2tlbkV4cGlyaW5nKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB0aGlzLmlkVG9rZW5Qcm92aWRlci5mZXRjaElkVG9rZW4odGhpcy50YXJnZXRBdWRpZW5jZSk7XG4gICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0ge1xuICAgICAgICAgICAgICAgIGlkX3Rva2VuOiBpZFRva2VuLFxuICAgICAgICAgICAgICAgIGV4cGlyeV9kYXRlOiB0aGlzLmdldElkVG9rZW5FeHBpcnlEYXRlKGlkVG9rZW4pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgdGhpcy5jcmVkZW50aWFscy5pZF90b2tlbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVycyB9O1xuICAgIH1cbiAgICBnZXRJZFRva2VuRXhwaXJ5RGF0ZShpZFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWRCNjQgPSBpZFRva2VuLnNwbGl0KCcuJylbMV07XG4gICAgICAgIGlmIChwYXlsb2FkQjY0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShwYXlsb2FkQjY0LCAnYmFzZTY0JykudG9TdHJpbmcoJ2FzY2lpJykpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQuZXhwICogMTAwMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSWRUb2tlbkNsaWVudCA9IElkVG9rZW5DbGllbnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJZFRva2VuQ2xpZW50Iiwib2F1dGgyY2xpZW50XzEiLCJyZXF1aXJlIiwiT0F1dGgyQ2xpZW50IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwidGFyZ2V0QXVkaWVuY2UiLCJpZFRva2VuUHJvdmlkZXIiLCJnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyIsInVybCIsImNyZWRlbnRpYWxzIiwiaWRfdG9rZW4iLCJleHBpcnlfZGF0ZSIsImlzVG9rZW5FeHBpcmluZyIsImlkVG9rZW4iLCJmZXRjaElkVG9rZW4iLCJnZXRJZFRva2VuRXhwaXJ5RGF0ZSIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwicGF5bG9hZEI2NCIsInNwbGl0IiwicGF5bG9hZCIsIkpTT04iLCJwYXJzZSIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsImV4cCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/impersonated.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/impersonated.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(action-browser)/./node_modules/gaxios/build/src/index.js\");\nexports.IMPERSONATED_ACCOUNT_TYPE = \"impersonated_service_account\";\nclass Impersonated extends oauth2client_1.OAuth2Client {\n    /**\n     * Impersonated service account credentials.\n     *\n     * Create a new access token by impersonating another service account.\n     *\n     * Impersonated Credentials allowing credentials issued to a user or\n     * service account to impersonate another. The source project using\n     * Impersonated Credentials must enable the \"IAMCredentials\" API.\n     * Also, the target service account must grant the orginating principal\n     * the \"Service Account Token Creator\" IAM role.\n     *\n     * @param {object} options - The configuration object.\n     * @param {object} [options.sourceClient] the source credential used as to\n     * acquire the impersonated credentials.\n     * @param {string} [options.targetPrincipal] the service account to\n     * impersonate.\n     * @param {string[]} [options.delegates] the chained list of delegates\n     * required to grant the final access_token. If set, the sequence of\n     * identities must have \"Service Account Token Creator\" capability granted to\n     * the preceding identity. For example, if set to [serviceAccountB,\n     * serviceAccountC], the sourceCredential must have the Token Creator role on\n     * serviceAccountB. serviceAccountB must have the Token Creator on\n     * serviceAccountC. Finally, C must have Token Creator on target_principal.\n     * If left unset, sourceCredential must have that role on targetPrincipal.\n     * @param {string[]} [options.targetScopes] scopes to request during the\n     * authorization grant.\n     * @param {number} [options.lifetime] number of seconds the delegated\n     * credential should be valid for up to 3600 seconds by default, or 43,200\n     * seconds by extending the token's lifetime, see:\n     * https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth\n     * @param {string} [options.endpoint] api endpoint override.\n     */ constructor(options = {}){\n        var _a, _b, _c, _d, _e, _f;\n        super(options);\n        // Start with an expired refresh token, which will automatically be\n        // refreshed before the first API call is made.\n        this.credentials = {\n            expiry_date: 1,\n            refresh_token: \"impersonated-placeholder\"\n        };\n        this.sourceClient = (_a = options.sourceClient) !== null && _a !== void 0 ? _a : new oauth2client_1.OAuth2Client();\n        this.targetPrincipal = (_b = options.targetPrincipal) !== null && _b !== void 0 ? _b : \"\";\n        this.delegates = (_c = options.delegates) !== null && _c !== void 0 ? _c : [];\n        this.targetScopes = (_d = options.targetScopes) !== null && _d !== void 0 ? _d : [];\n        this.lifetime = (_e = options.lifetime) !== null && _e !== void 0 ? _e : 3600;\n        this.endpoint = (_f = options.endpoint) !== null && _f !== void 0 ? _f : \"https://iamcredentials.googleapis.com\";\n    }\n    /**\n     * Signs some bytes.\n     *\n     * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob Reference Documentation}\n     * @param blobToSign String to sign.\n     * @return <SignBlobResponse> denoting the keyyID and signedBlob in base64 string\n     */ async sign(blobToSign) {\n        await this.sourceClient.getAccessToken();\n        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;\n        const u = `${this.endpoint}/v1/${name}:signBlob`;\n        const body = {\n            delegates: this.delegates,\n            payload: Buffer.from(blobToSign).toString(\"base64\")\n        };\n        const res = await this.sourceClient.request({\n            url: u,\n            data: body,\n            method: \"POST\"\n        });\n        return res.data;\n    }\n    /** The service account email to be impersonated. */ getTargetPrincipal() {\n        return this.targetPrincipal;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken Unused parameter\n     */ async refreshToken(refreshToken) {\n        var _a, _b, _c, _d, _e, _f;\n        try {\n            await this.sourceClient.getAccessToken();\n            const name = \"projects/-/serviceAccounts/\" + this.targetPrincipal;\n            const u = `${this.endpoint}/v1/${name}:generateAccessToken`;\n            const body = {\n                delegates: this.delegates,\n                scope: this.targetScopes,\n                lifetime: this.lifetime + \"s\"\n            };\n            const res = await this.sourceClient.request({\n                url: u,\n                data: body,\n                method: \"POST\"\n            });\n            const tokenResponse = res.data;\n            this.credentials.access_token = tokenResponse.accessToken;\n            this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);\n            return {\n                tokens: this.credentials,\n                res\n            };\n        } catch (error) {\n            if (!(error instanceof Error)) throw error;\n            let status = 0;\n            let message = \"\";\n            if (error instanceof gaxios_1.GaxiosError) {\n                status = (_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.status;\n                message = (_f = (_e = (_d = error === null || error === void 0 ? void 0 : error.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.message;\n            }\n            if (status && message) {\n                error.message = `${status}: unable to impersonate: ${message}`;\n                throw error;\n            } else {\n                error.message = `unable to impersonate: ${error}`;\n                throw error;\n            }\n        }\n    }\n    /**\n     * Generates an OpenID Connect ID token for a service account.\n     *\n     * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}\n     *\n     * @param targetAudience the audience for the fetched ID token.\n     * @param options the for the request\n     * @return an OpenID Connect ID token\n     */ async fetchIdToken(targetAudience, options) {\n        var _a;\n        await this.sourceClient.getAccessToken();\n        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;\n        const u = `${this.endpoint}/v1/${name}:generateIdToken`;\n        const body = {\n            delegates: this.delegates,\n            audience: targetAudience,\n            includeEmail: (_a = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _a !== void 0 ? _a : true\n        };\n        const res = await this.sourceClient.request({\n            url: u,\n            data: body,\n            method: \"POST\"\n        });\n        return res.data.token;\n    }\n}\nexports.Impersonated = Impersonated;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2ltcGVyc29uYXRlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0EsaUNBQWlDLEdBQUcsS0FBSztBQUNoRSxNQUFNSSxpQkFBaUJDLG1CQUFPQSxDQUFDLDBHQUFnQjtBQUMvQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyx5RUFBUTtBQUNqQ0wsaUNBQWlDLEdBQUc7QUFDcEMsTUFBTUUscUJBQXFCRSxlQUFlRyxZQUFZO0lBQ2xEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBK0JDLEdBQ0RDLFlBQVlDLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDdEIsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7UUFDeEIsS0FBSyxDQUFDTjtRQUNOLG1FQUFtRTtRQUNuRSwrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDTyxXQUFXLEdBQUc7WUFDZkMsYUFBYTtZQUNiQyxlQUFlO1FBQ25CO1FBQ0EsSUFBSSxDQUFDQyxZQUFZLEdBQUcsQ0FBQ1QsS0FBS0QsUUFBUVUsWUFBWSxNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJQSxLQUFLLElBQUlOLGVBQWVHLFlBQVk7UUFDaEgsSUFBSSxDQUFDYSxlQUFlLEdBQUcsQ0FBQ1QsS0FBS0YsUUFBUVcsZUFBZSxNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ3ZGLElBQUksQ0FBQ1UsU0FBUyxHQUFHLENBQUNULEtBQUtILFFBQVFZLFNBQVMsTUFBTSxRQUFRVCxPQUFPLEtBQUssSUFBSUEsS0FBSyxFQUFFO1FBQzdFLElBQUksQ0FBQ1UsWUFBWSxHQUFHLENBQUNULEtBQUtKLFFBQVFhLFlBQVksTUFBTSxRQUFRVCxPQUFPLEtBQUssSUFB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QUNzQixLQUFLO0lBQ3pCO0FBQ0o7QUFDQTVELG9CQUFvQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb3RpZnktdG8teW91dHViZS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2ltcGVyc29uYXRlZC5qcz81YzliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbXBlcnNvbmF0ZWQgPSBleHBvcnRzLklNUEVSU09OQVRFRF9BQ0NPVU5UX1RZUEUgPSB2b2lkIDA7XG5jb25zdCBvYXV0aDJjbGllbnRfMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNsaWVudFwiKTtcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcbmV4cG9ydHMuSU1QRVJTT05BVEVEX0FDQ09VTlRfVFlQRSA9ICdpbXBlcnNvbmF0ZWRfc2VydmljZV9hY2NvdW50JztcbmNsYXNzIEltcGVyc29uYXRlZCBleHRlbmRzIG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW1wZXJzb25hdGVkIHNlcnZpY2UgYWNjb3VudCBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBhY2Nlc3MgdG9rZW4gYnkgaW1wZXJzb25hdGluZyBhbm90aGVyIHNlcnZpY2UgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEltcGVyc29uYXRlZCBDcmVkZW50aWFscyBhbGxvd2luZyBjcmVkZW50aWFscyBpc3N1ZWQgdG8gYSB1c2VyIG9yXG4gICAgICogc2VydmljZSBhY2NvdW50IHRvIGltcGVyc29uYXRlIGFub3RoZXIuIFRoZSBzb3VyY2UgcHJvamVjdCB1c2luZ1xuICAgICAqIEltcGVyc29uYXRlZCBDcmVkZW50aWFscyBtdXN0IGVuYWJsZSB0aGUgXCJJQU1DcmVkZW50aWFsc1wiIEFQSS5cbiAgICAgKiBBbHNvLCB0aGUgdGFyZ2V0IHNlcnZpY2UgYWNjb3VudCBtdXN0IGdyYW50IHRoZSBvcmdpbmF0aW5nIHByaW5jaXBhbFxuICAgICAqIHRoZSBcIlNlcnZpY2UgQWNjb3VudCBUb2tlbiBDcmVhdG9yXCIgSUFNIHJvbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuc291cmNlQ2xpZW50XSB0aGUgc291cmNlIGNyZWRlbnRpYWwgdXNlZCBhcyB0b1xuICAgICAqIGFjcXVpcmUgdGhlIGltcGVyc29uYXRlZCBjcmVkZW50aWFscy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGFyZ2V0UHJpbmNpcGFsXSB0aGUgc2VydmljZSBhY2NvdW50IHRvXG4gICAgICogaW1wZXJzb25hdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMuZGVsZWdhdGVzXSB0aGUgY2hhaW5lZCBsaXN0IG9mIGRlbGVnYXRlc1xuICAgICAqIHJlcXVpcmVkIHRvIGdyYW50IHRoZSBmaW5hbCBhY2Nlc3NfdG9rZW4uIElmIHNldCwgdGhlIHNlcXVlbmNlIG9mXG4gICAgICogaWRlbnRpdGllcyBtdXN0IGhhdmUgXCJTZXJ2aWNlIEFjY291bnQgVG9rZW4gQ3JlYXRvclwiIGNhcGFiaWxpdHkgZ3JhbnRlZCB0b1xuICAgICAqIHRoZSBwcmVjZWRpbmcgaWRlbnRpdHkuIEZvciBleGFtcGxlLCBpZiBzZXQgdG8gW3NlcnZpY2VBY2NvdW50QixcbiAgICAgKiBzZXJ2aWNlQWNjb3VudENdLCB0aGUgc291cmNlQ3JlZGVudGlhbCBtdXN0IGhhdmUgdGhlIFRva2VuIENyZWF0b3Igcm9sZSBvblxuICAgICAqIHNlcnZpY2VBY2NvdW50Qi4gc2VydmljZUFjY291bnRCIG11c3QgaGF2ZSB0aGUgVG9rZW4gQ3JlYXRvciBvblxuICAgICAqIHNlcnZpY2VBY2NvdW50Qy4gRmluYWxseSwgQyBtdXN0IGhhdmUgVG9rZW4gQ3JlYXRvciBvbiB0YXJnZXRfcHJpbmNpcGFsLlxuICAgICAqIElmIGxlZnQgdW5zZXQsIHNvdXJjZUNyZWRlbnRpYWwgbXVzdCBoYXZlIHRoYXQgcm9sZSBvbiB0YXJnZXRQcmluY2lwYWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMudGFyZ2V0U2NvcGVzXSBzY29wZXMgdG8gcmVxdWVzdCBkdXJpbmcgdGhlXG4gICAgICogYXV0aG9yaXphdGlvbiBncmFudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGlmZXRpbWVdIG51bWJlciBvZiBzZWNvbmRzIHRoZSBkZWxlZ2F0ZWRcbiAgICAgKiBjcmVkZW50aWFsIHNob3VsZCBiZSB2YWxpZCBmb3IgdXAgdG8gMzYwMCBzZWNvbmRzIGJ5IGRlZmF1bHQsIG9yIDQzLDIwMFxuICAgICAqIHNlY29uZHMgYnkgZXh0ZW5kaW5nIHRoZSB0b2tlbidzIGxpZmV0aW1lLCBzZWU6XG4gICAgICogaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lhbS9kb2NzL2NyZWF0aW5nLXNob3J0LWxpdmVkLXNlcnZpY2UtYWNjb3VudC1jcmVkZW50aWFscyNzYS1jcmVkZW50aWFscy1vYXV0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmRwb2ludF0gYXBpIGVuZHBvaW50IG92ZXJyaWRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYW4gZXhwaXJlZCByZWZyZXNoIHRva2VuLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICAgICAgLy8gcmVmcmVzaGVkIGJlZm9yZSB0aGUgZmlyc3QgQVBJIGNhbGwgaXMgbWFkZS5cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHtcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiAxLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogJ2ltcGVyc29uYXRlZC1wbGFjZWhvbGRlcicsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc291cmNlQ2xpZW50ID0gKF9hID0gb3B0aW9ucy5zb3VyY2VDbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQoKTtcbiAgICAgICAgdGhpcy50YXJnZXRQcmluY2lwYWwgPSAoX2IgPSBvcHRpb25zLnRhcmdldFByaW5jaXBhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVzID0gKF9jID0gb3B0aW9ucy5kZWxlZ2F0ZXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xuICAgICAgICB0aGlzLnRhcmdldFNjb3BlcyA9IChfZCA9IG9wdGlvbnMudGFyZ2V0U2NvcGVzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXTtcbiAgICAgICAgdGhpcy5saWZldGltZSA9IChfZSA9IG9wdGlvbnMubGlmZXRpbWUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDM2MDA7XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSAoX2YgPSBvcHRpb25zLmVuZHBvaW50KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAnaHR0cHM6Ly9pYW1jcmVkZW50aWFscy5nb29nbGVhcGlzLmNvbSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIHNvbWUgYnl0ZXMuXG4gICAgICpcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lhbS9kb2NzL3JlZmVyZW5jZS9jcmVkZW50aWFscy9yZXN0L3YxL3Byb2plY3RzLnNlcnZpY2VBY2NvdW50cy9zaWduQmxvYiBSZWZlcmVuY2UgRG9jdW1lbnRhdGlvbn1cbiAgICAgKiBAcGFyYW0gYmxvYlRvU2lnbiBTdHJpbmcgdG8gc2lnbi5cbiAgICAgKiBAcmV0dXJuIDxTaWduQmxvYlJlc3BvbnNlPiBkZW5vdGluZyB0aGUga2V5eUlEIGFuZCBzaWduZWRCbG9iIGluIGJhc2U2NCBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBzaWduKGJsb2JUb1NpZ24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zb3VyY2VDbGllbnQuZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGBwcm9qZWN0cy8tL3NlcnZpY2VBY2NvdW50cy8ke3RoaXMudGFyZ2V0UHJpbmNpcGFsfWA7XG4gICAgICAgIGNvbnN0IHUgPSBgJHt0aGlzLmVuZHBvaW50fS92MS8ke25hbWV9OnNpZ25CbG9iYDtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGRlbGVnYXRlczogdGhpcy5kZWxlZ2F0ZXMsXG4gICAgICAgICAgICBwYXlsb2FkOiBCdWZmZXIuZnJvbShibG9iVG9TaWduKS50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuc291cmNlQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsOiB1LFxuICAgICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgIH1cbiAgICAvKiogVGhlIHNlcnZpY2UgYWNjb3VudCBlbWFpbCB0byBiZSBpbXBlcnNvbmF0ZWQuICovXG4gICAgZ2V0VGFyZ2V0UHJpbmNpcGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRQcmluY2lwYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gVW51c2VkIHBhcmFtZXRlclxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNvdXJjZUNsaWVudC5nZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9ICdwcm9qZWN0cy8tL3NlcnZpY2VBY2NvdW50cy8nICsgdGhpcy50YXJnZXRQcmluY2lwYWw7XG4gICAgICAgICAgICBjb25zdCB1ID0gYCR7dGhpcy5lbmRwb2ludH0vdjEvJHtuYW1lfTpnZW5lcmF0ZUFjY2Vzc1Rva2VuYDtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICAgICAgZGVsZWdhdGVzOiB0aGlzLmRlbGVnYXRlcyxcbiAgICAgICAgICAgICAgICBzY29wZTogdGhpcy50YXJnZXRTY29wZXMsXG4gICAgICAgICAgICAgICAgbGlmZXRpbWU6IHRoaXMubGlmZXRpbWUgKyAncycsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5zb3VyY2VDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1LFxuICAgICAgICAgICAgICAgIGRhdGE6IGJvZHksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuUmVzcG9uc2UgPSByZXMuZGF0YTtcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuID0gdG9rZW5SZXNwb25zZS5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGUgPSBEYXRlLnBhcnNlKHRva2VuUmVzcG9uc2UuZXhwaXJlVGltZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5jcmVkZW50aWFscyxcbiAgICAgICAgICAgICAgICByZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBsZXQgc3RhdHVzID0gMDtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBnYXhpb3NfMS5HYXhpb3NFcnJvcikge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IChfYyA9IChfYiA9IChfYSA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5yZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lcnJvcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0YXR1cztcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gKF9mID0gKF9lID0gKF9kID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZGF0YSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmVycm9yKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0dXMgJiYgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgJHtzdGF0dXN9OiB1bmFibGUgdG8gaW1wZXJzb25hdGU6ICR7bWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGB1bmFibGUgdG8gaW1wZXJzb25hdGU6ICR7ZXJyb3J9YDtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gT3BlbklEIENvbm5lY3QgSUQgdG9rZW4gZm9yIGEgc2VydmljZSBhY2NvdW50LlxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pYW0vZG9jcy9yZWZlcmVuY2UvY3JlZGVudGlhbHMvcmVzdC92MS9wcm9qZWN0cy5zZXJ2aWNlQWNjb3VudHMvZ2VuZXJhdGVJZFRva2VuIFJlZmVyZW5jZSBEb2N1bWVudGF0aW9ufVxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldEF1ZGllbmNlIHRoZSBhdWRpZW5jZSBmb3IgdGhlIGZldGNoZWQgSUQgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEByZXR1cm4gYW4gT3BlbklEIENvbm5lY3QgSUQgdG9rZW5cbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaElkVG9rZW4odGFyZ2V0QXVkaWVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhd2FpdCB0aGlzLnNvdXJjZUNsaWVudC5nZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICBjb25zdCBuYW1lID0gYHByb2plY3RzLy0vc2VydmljZUFjY291bnRzLyR7dGhpcy50YXJnZXRQcmluY2lwYWx9YDtcbiAgICAgICAgY29uc3QgdSA9IGAke3RoaXMuZW5kcG9pbnR9L3YxLyR7bmFtZX06Z2VuZXJhdGVJZFRva2VuYDtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGRlbGVnYXRlczogdGhpcy5kZWxlZ2F0ZXMsXG4gICAgICAgICAgICBhdWRpZW5jZTogdGFyZ2V0QXVkaWVuY2UsXG4gICAgICAgICAgICBpbmNsdWRlRW1haWw6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbmNsdWRlRW1haWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuc291cmNlQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsOiB1LFxuICAgICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnRva2VuO1xuICAgIH1cbn1cbmV4cG9ydHMuSW1wZXJzb25hdGVkID0gSW1wZXJzb25hdGVkO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW1wZXJzb25hdGVkIiwiSU1QRVJTT05BVEVEX0FDQ09VTlRfVFlQRSIsIm9hdXRoMmNsaWVudF8xIiwicmVxdWlyZSIsImdheGlvc18xIiwiT0F1dGgyQ2xpZW50IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiY3JlZGVudGlhbHMiLCJleHBpcnlfZGF0ZSIsInJlZnJlc2hfdG9rZW4iLCJzb3VyY2VDbGllbnQiLCJ0YXJnZXRQcmluY2lwYWwiLCJkZWxlZ2F0ZXMiLCJ0YXJnZXRTY29wZXMiLCJsaWZldGltZSIsImVuZHBvaW50Iiwic2lnbiIsImJsb2JUb1NpZ24iLCJnZXRBY2Nlc3NUb2tlbiIsIm5hbWUiLCJ1IiwiYm9keSIsInBheWxvYWQiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJyZXMiLCJyZXF1ZXN0IiwidXJsIiwiZGF0YSIsIm1ldGhvZCIsImdldFRhcmdldFByaW5jaXBhbCIsInJlZnJlc2hUb2tlbiIsInNjb3BlIiwidG9rZW5SZXNwb25zZSIsImFjY2Vzc190b2tlbiIsImFjY2Vzc1Rva2VuIiwiRGF0ZSIsInBhcnNlIiwiZXhwaXJlVGltZSIsInRva2VucyIsImVycm9yIiwiRXJyb3IiLCJzdGF0dXMiLCJtZXNzYWdlIiwiR2F4aW9zRXJyb3IiLCJyZXNwb25zZSIsImZldGNoSWRUb2tlbiIsInRhcmdldEF1ZGllbmNlIiwiYXVkaWVuY2UiLCJpbmNsdWRlRW1haWwiLCJ0b2tlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/impersonated.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/jwtaccess.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JWTAccess = void 0;\nconst jws = __webpack_require__(/*! jws */ \"(action-browser)/./node_modules/jws/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"(action-browser)/./node_modules/google-auth-library/build/src/util.js\");\nconst DEFAULT_HEADER = {\n    alg: \"RS256\",\n    typ: \"JWT\"\n};\nclass JWTAccess {\n    /**\n     * JWTAccess service account credentials.\n     *\n     * Create a new access token by using the credential to create a new JWT token\n     * that's recognized as the access token.\n     *\n     * @param email the service account email address.\n     * @param key the private key that will be used to sign the token.\n     * @param keyId the ID of the private key used to sign the token.\n     */ constructor(email, key, keyId, eagerRefreshThresholdMillis){\n        this.cache = new util_1.LRUCache({\n            capacity: 500,\n            maxAge: 60 * 60 * 1000\n        });\n        this.email = email;\n        this.key = key;\n        this.keyId = keyId;\n        this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;\n    }\n    /**\n     * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url\n     *\n     * @param url The URI being authorized.\n     * @param scopes The scope or scopes being authorized\n     * @returns A string that returns the cached key.\n     */ getCachedKey(url, scopes) {\n        let cacheKey = url;\n        if (scopes && Array.isArray(scopes) && scopes.length) {\n            cacheKey = url ? `${url}_${scopes.join(\"_\")}` : `${scopes.join(\"_\")}`;\n        } else if (typeof scopes === \"string\") {\n            cacheKey = url ? `${url}_${scopes}` : scopes;\n        }\n        if (!cacheKey) {\n            throw Error(\"Scopes or url must be provided\");\n        }\n        return cacheKey;\n    }\n    /**\n     * Get a non-expired access token, after refreshing if necessary.\n     *\n     * @param url The URI being authorized.\n     * @param additionalClaims An object with a set of additional claims to\n     * include in the payload.\n     * @returns An object that includes the authorization header.\n     */ getRequestHeaders(url, additionalClaims, scopes) {\n        // Return cached authorization headers, unless we are within\n        // eagerRefreshThresholdMillis ms of them expiring:\n        const key = this.getCachedKey(url, scopes);\n        const cachedToken = this.cache.get(key);\n        const now = Date.now();\n        if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {\n            return cachedToken.headers;\n        }\n        const iat = Math.floor(Date.now() / 1000);\n        const exp = JWTAccess.getExpirationTime(iat);\n        let defaultClaims;\n        // Turn scopes into space-separated string\n        if (Array.isArray(scopes)) {\n            scopes = scopes.join(\" \");\n        }\n        // If scopes are specified, sign with scopes\n        if (scopes) {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                scope: scopes,\n                exp,\n                iat\n            };\n        } else {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                aud: url,\n                exp,\n                iat\n            };\n        }\n        // if additionalClaims are provided, ensure they do not collide with\n        // other required claims.\n        if (additionalClaims) {\n            for(const claim in defaultClaims){\n                if (additionalClaims[claim]) {\n                    throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\n                }\n            }\n        }\n        const header = this.keyId ? {\n            ...DEFAULT_HEADER,\n            kid: this.keyId\n        } : DEFAULT_HEADER;\n        const payload = Object.assign(defaultClaims, additionalClaims);\n        // Sign the jwt and add it to the cache\n        const signedJWT = jws.sign({\n            header,\n            payload,\n            secret: this.key\n        });\n        const headers = {\n            Authorization: `Bearer ${signedJWT}`\n        };\n        this.cache.set(key, {\n            expiration: exp * 1000,\n            headers\n        });\n        return headers;\n    }\n    /**\n     * Returns an expiration time for the JWT token.\n     *\n     * @param iat The issued at time for the JWT.\n     * @returns An expiration time for the JWT.\n     */ static getExpirationTime(iat) {\n        const exp = iat + 3600; // 3600 seconds = 1 hour\n        return exp;\n    }\n    /**\n     * Create a JWTAccess credentials instance using the given input options.\n     * @param json The input object.\n     */ fromJSON(json) {\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing the service account auth settings.\");\n        }\n        if (!json.client_email) {\n            throw new Error(\"The incoming JSON object does not contain a client_email field\");\n        }\n        if (!json.private_key) {\n            throw new Error(\"The incoming JSON object does not contain a private_key field\");\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(()=>callback(), callback);\n        } else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                reject(new Error(\"Must pass in a stream containing the service account auth settings.\"));\n            }\n            let s = \"\";\n            inputStream.setEncoding(\"utf8\").on(\"data\", (chunk)=>s += chunk).on(\"error\", reject).on(\"end\", ()=>{\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                } catch (err) {\n                    reject(err);\n                }\n            });\n        });\n    }\n}\nexports.JWTAccess = JWTAccess;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2p3dGFjY2Vzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsTUFBTUcsTUFBTUMsbUJBQU9BLENBQUMseURBQUs7QUFDekIsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUMsc0ZBQVM7QUFDaEMsTUFBTUUsaUJBQWlCO0lBQ25CQyxLQUFLO0lBQ0xDLEtBQUs7QUFDVDtBQUNBLE1BQU1OO0lBQ0Y7Ozs7Ozs7OztLQVNDLEdBQ0RPLFlBQVlDLEtBQUssRUFBRUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLDJCQUEyQixDQUFFO1FBQ3hELElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUlULE9BQU9VLFFBQVEsQ0FBQztZQUM3QkMsVUFBVTtZQUNWQyxRQUFRLEtBQUssS0FBSztRQUN0QjtRQUNBLElBQUksQ0FBQ1AsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsMkJBQTJCLEdBQzVCQSxnQ0FBZ0MsUUFBUUEsZ0NBQWdDLEtBQUssSUFBSUEsOEJBQThCLElBQUksS0FBSztJQUNoSTtJQUNBOzs7Ozs7S0FNQyxHQUNESyxhQUFhQyxHQUFHLEVBQUVDLE1BQU0sRUFBRTtRQUN0QixJQUFJQyxXQUFXRjtRQUNmLElBQUlDLFVBQVVFLE1BQU1DLE9BQU8sQ0FBQ0gs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Ly4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvand0YWNjZXNzLmpzP2NiOTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSldUQWNjZXNzID0gdm9pZCAwO1xuY29uc3QgandzID0gcmVxdWlyZShcImp3c1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgREVGQVVMVF9IRUFERVIgPSB7XG4gICAgYWxnOiAnUlMyNTYnLFxuICAgIHR5cDogJ0pXVCcsXG59O1xuY2xhc3MgSldUQWNjZXNzIHtcbiAgICAvKipcbiAgICAgKiBKV1RBY2Nlc3Mgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IGFjY2VzcyB0b2tlbiBieSB1c2luZyB0aGUgY3JlZGVudGlhbCB0byBjcmVhdGUgYSBuZXcgSldUIHRva2VuXG4gICAgICogdGhhdCdzIHJlY29nbml6ZWQgYXMgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbWFpbCB0aGUgc2VydmljZSBhY2NvdW50IGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gc2lnbiB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIGtleUlkIHRoZSBJRCBvZiB0aGUgcHJpdmF0ZSBrZXkgdXNlZCB0byBzaWduIHRoZSB0b2tlbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbWFpbCwga2V5LCBrZXlJZCwgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgdXRpbF8xLkxSVUNhY2hlKHtcbiAgICAgICAgICAgIGNhcGFjaXR5OiA1MDAsXG4gICAgICAgICAgICBtYXhBZ2U6IDYwICogNjAgKiAxMDAwLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWFpbCA9IGVtYWlsO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IGtleUlkO1xuICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9XG4gICAgICAgICAgICBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgIT09IG51bGwgJiYgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzICE9PSB2b2lkIDAgPyBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgOiA1ICogNjAgKiAxMDAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgd2UncmUgY2FjaGluZyBhIGtleSBhcHByb3ByaWF0ZWx5LCBnaXZpbmcgcHJlY2VkZW5jZSB0byBzY29wZXMgdnMuIHVybFxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJJIGJlaW5nIGF1dGhvcml6ZWQuXG4gICAgICogQHBhcmFtIHNjb3BlcyBUaGUgc2NvcGUgb3Igc2NvcGVzIGJlaW5nIGF1dGhvcml6ZWRcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyB0aGF0IHJldHVybnMgdGhlIGNhY2hlZCBrZXkuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVkS2V5KHVybCwgc2NvcGVzKSB7XG4gICAgICAgIGxldCBjYWNoZUtleSA9IHVybDtcbiAgICAgICAgaWYgKHNjb3BlcyAmJiBBcnJheS5pc0FycmF5KHNjb3BlcykgJiYgc2NvcGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FjaGVLZXkgPSB1cmwgPyBgJHt1cmx9XyR7c2NvcGVzLmpvaW4oJ18nKX1gIDogYCR7c2NvcGVzLmpvaW4oJ18nKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY29wZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjYWNoZUtleSA9IHVybCA/IGAke3VybH1fJHtzY29wZXN9YCA6IHNjb3BlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhY2hlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU2NvcGVzIG9yIHVybCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBub24tZXhwaXJlZCBhY2Nlc3MgdG9rZW4sIGFmdGVyIHJlZnJlc2hpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJJIGJlaW5nIGF1dGhvcml6ZWQuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDbGFpbXMgQW4gb2JqZWN0IHdpdGggYSBzZXQgb2YgYWRkaXRpb25hbCBjbGFpbXMgdG9cbiAgICAgKiBpbmNsdWRlIGluIHRoZSBwYXlsb2FkLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB0aGF0IGluY2x1ZGVzIHRoZSBhdXRob3JpemF0aW9uIGhlYWRlci5cbiAgICAgKi9cbiAgICBnZXRSZXF1ZXN0SGVhZGVycyh1cmwsIGFkZGl0aW9uYWxDbGFpbXMsIHNjb3Blcykge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGF1dGhvcml6YXRpb24gaGVhZGVycywgdW5sZXNzIHdlIGFyZSB3aXRoaW5cbiAgICAgICAgLy8gZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIG1zIG9mIHRoZW0gZXhwaXJpbmc6XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0Q2FjaGVkS2V5KHVybCwgc2NvcGVzKTtcbiAgICAgICAgY29uc3QgY2FjaGVkVG9rZW4gPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoY2FjaGVkVG9rZW4gJiZcbiAgICAgICAgICAgIGNhY2hlZFRva2VuLmV4cGlyYXRpb24gLSBub3cgPiB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFRva2VuLmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWF0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgIGNvbnN0IGV4cCA9IEpXVEFjY2Vzcy5nZXRFeHBpcmF0aW9uVGltZShpYXQpO1xuICAgICAgICBsZXQgZGVmYXVsdENsYWltcztcbiAgICAgICAgLy8gVHVybiBzY29wZXMgaW50byBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjb3BlcykpIHtcbiAgICAgICAgICAgIHNjb3BlcyA9IHNjb3Blcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgc2NvcGVzIGFyZSBzcGVjaWZpZWQsIHNpZ24gd2l0aCBzY29wZXNcbiAgICAgICAgaWYgKHNjb3Blcykge1xuICAgICAgICAgICAgZGVmYXVsdENsYWltcyA9IHtcbiAgICAgICAgICAgICAgICBpc3M6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICAgICAgc3ViOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBzY29wZXMsXG4gICAgICAgICAgICAgICAgZXhwLFxuICAgICAgICAgICAgICAgIGlhdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2xhaW1zID0ge1xuICAgICAgICAgICAgICAgIGlzczogdGhpcy5lbWFpbCxcbiAgICAgICAgICAgICAgICBzdWI6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICAgICAgYXVkOiB1cmwsXG4gICAgICAgICAgICAgICAgZXhwLFxuICAgICAgICAgICAgICAgIGlhdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYWRkaXRpb25hbENsYWltcyBhcmUgcHJvdmlkZWQsIGVuc3VyZSB0aGV5IGRvIG5vdCBjb2xsaWRlIHdpdGhcbiAgICAgICAgLy8gb3RoZXIgcmVxdWlyZWQgY2xhaW1zLlxuICAgICAgICBpZiAoYWRkaXRpb25hbENsYWltcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjbGFpbSBpbiBkZWZhdWx0Q2xhaW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxDbGFpbXNbY2xhaW1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke2NsYWltfScgcHJvcGVydHkgaXMgbm90IGFsbG93ZWQgd2hlbiBwYXNzaW5nIGFkZGl0aW9uYWxDbGFpbXMuIFRoaXMgY2xhaW0gaXMgaW5jbHVkZWQgaW4gdGhlIEpXVCBieSBkZWZhdWx0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLmtleUlkXG4gICAgICAgICAgICA/IHsgLi4uREVGQVVMVF9IRUFERVIsIGtpZDogdGhpcy5rZXlJZCB9XG4gICAgICAgICAgICA6IERFRkFVTFRfSEVBREVSO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0Q2xhaW1zLCBhZGRpdGlvbmFsQ2xhaW1zKTtcbiAgICAgICAgLy8gU2lnbiB0aGUgand0IGFuZCBhZGQgaXQgdG8gdGhlIGNhY2hlXG4gICAgICAgIGNvbnN0IHNpZ25lZEpXVCA9IGp3cy5zaWduKHsgaGVhZGVyLCBwYXlsb2FkLCBzZWNyZXQ6IHRoaXMua2V5IH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7c2lnbmVkSldUfWAgfTtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB7XG4gICAgICAgICAgICBleHBpcmF0aW9uOiBleHAgKiAxMDAwLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIEpXVCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpYXQgVGhlIGlzc3VlZCBhdCB0aW1lIGZvciB0aGUgSldULlxuICAgICAqIEByZXR1cm5zIEFuIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIEpXVC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RXhwaXJhdGlvblRpbWUoaWF0KSB7XG4gICAgICAgIGNvbnN0IGV4cCA9IGlhdCArIDM2MDA7IC8vIDM2MDAgc2Vjb25kcyA9IDEgaG91clxuICAgICAgICByZXR1cm4gZXhwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBKV1RBY2Nlc3MgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGlucHV0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXJ2aWNlIGFjY291bnQgYXV0aCBzZXR0aW5ncy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uY2xpZW50X2VtYWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgY2xpZW50X2VtYWlsIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgcHJpdmF0ZV9rZXkgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IHRoZSByZWxldmFudCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBqc29uIGtleSBmaWxlLlxuICAgICAgICB0aGlzLmVtYWlsID0ganNvbi5jbGllbnRfZW1haWw7XG4gICAgICAgIHRoaXMua2V5ID0ganNvbi5wcml2YXRlX2tleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IGpzb24ucHJpdmF0ZV9rZXlfaWQ7XG4gICAgICAgIHRoaXMucHJvamVjdElkID0ganNvbi5wcm9qZWN0X2lkO1xuICAgIH1cbiAgICBmcm9tU3RyZWFtKGlucHV0U3RyZWFtLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKS50aGVuKCgpID0+IGNhbGxiYWNrKCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIHNlcnZpY2UgYWNjb3VudCBhdXRoIHNldHRpbmdzLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbVxuICAgICAgICAgICAgICAgIC5zZXRFbmNvZGluZygndXRmOCcpXG4gICAgICAgICAgICAgICAgLm9uKCdkYXRhJywgY2h1bmsgPT4gKHMgKz0gY2h1bmspKVxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUpTT04oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5KV1RBY2Nlc3MgPSBKV1RBY2Nlc3M7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJKV1RBY2Nlc3MiLCJqd3MiLCJyZXF1aXJlIiwidXRpbF8xIiwiREVGQVVMVF9IRUFERVIiLCJhbGciLCJ0eXAiLCJjb25zdHJ1Y3RvciIsImVtYWlsIiwia2V5Iiwia2V5SWQiLCJlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMiLCJjYWNoZSIsIkxSVUNhY2hlIiwiY2FwYWNpdHkiLCJtYXhBZ2UiLCJnZXRDYWNoZWRLZXkiLCJ1cmwiLCJzY29wZXMiLCJjYWNoZUtleSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImpvaW4iLCJFcnJvciIsImdldFJlcXVlc3RIZWFkZXJzIiwiYWRkaXRpb25hbENsYWltcyIsImNhY2hlZFRva2VuIiwiZ2V0Iiwibm93IiwiRGF0ZSIsImV4cGlyYXRpb24iLCJoZWFkZXJzIiwiaWF0IiwiTWF0aCIsImZsb29yIiwiZXhwIiwiZ2V0RXhwaXJhdGlvblRpbWUiLCJkZWZhdWx0Q2xhaW1zIiwiaXNzIiwic3ViIiwic2NvcGUiLCJhdWQiLCJjbGFpbSIsImhlYWRlciIsImtpZCIsInBheWxvYWQiLCJhc3NpZ24iLCJzaWduZWRKV1QiLCJzaWduIiwic2VjcmV0IiwiQXV0aG9yaXphdGlvbiIsInNldCIsImZyb21KU09OIiwianNvbiIsImNsaWVudF9lbWFpbCIsInByaXZhdGVfa2V5IiwicHJpdmF0ZV9rZXlfaWQiLCJwcm9qZWN0SWQiLCJwcm9qZWN0X2lkIiwiZnJvbVN0cmVhbSIsImlucHV0U3RyZWFtIiwiY2FsbGJhY2siLCJmcm9tU3RyZWFtQXN5bmMiLCJ0aGVuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzIiwic2V0RW5jb2RpbmciLCJvbiIsImNodW5rIiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsImVyciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/jwtclient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/jwtclient.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JWT = void 0;\nconst gtoken_1 = __webpack_require__(/*! gtoken */ \"(action-browser)/./node_modules/gtoken/build/src/index.js\");\nconst jwtaccess_1 = __webpack_require__(/*! ./jwtaccess */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\");\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nclass JWT extends oauth2client_1.OAuth2Client {\n    constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId){\n        const opts = optionsOrEmail && typeof optionsOrEmail === \"object\" ? optionsOrEmail : {\n            email: optionsOrEmail,\n            keyFile,\n            key,\n            keyId,\n            scopes,\n            subject\n        };\n        super(opts);\n        this.email = opts.email;\n        this.keyFile = opts.keyFile;\n        this.key = opts.key;\n        this.keyId = opts.keyId;\n        this.scopes = opts.scopes;\n        this.subject = opts.subject;\n        this.additionalClaims = opts.additionalClaims;\n        // Start with an expired refresh token, which will automatically be\n        // refreshed before the first API call is made.\n        this.credentials = {\n            refresh_token: \"jwt-placeholder\",\n            expiry_date: 1\n        };\n    }\n    /**\n     * Creates a copy of the credential with the specified scopes.\n     * @param scopes List of requested scopes or a single scope.\n     * @return The cloned instance.\n     */ createScoped(scopes) {\n        const jwt = new JWT(this);\n        jwt.scopes = scopes;\n        return jwt;\n    }\n    /**\n     * Obtains the metadata to be sent with the request.\n     *\n     * @param url the URI being authorized.\n     */ async getRequestMetadataAsync(url) {\n        url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;\n        const useSelfSignedJWT = !this.hasUserScopes() && url || this.useJWTAccessWithScope && this.hasAnyScopes() || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;\n        if (this.subject && this.universeDomain !== authclient_1.DEFAULT_UNIVERSE) {\n            throw new RangeError(`Service Account user is configured for the credential. Domain-wide delegation is not supported in universes other than ${authclient_1.DEFAULT_UNIVERSE}`);\n        }\n        if (!this.apiKey && useSelfSignedJWT) {\n            if (this.additionalClaims && this.additionalClaims.target_audience) {\n                const { tokens } = await this.refreshToken();\n                return {\n                    headers: this.addSharedMetadataHeaders({\n                        Authorization: `Bearer ${tokens.id_token}`\n                    })\n                };\n            } else {\n                // no scopes have been set, but a uri has been provided. Use JWTAccess\n                // credentials.\n                if (!this.access) {\n                    this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);\n                }\n                let scopes;\n                if (this.hasUserScopes()) {\n                    scopes = this.scopes;\n                } else if (!url) {\n                    scopes = this.defaultScopes;\n                }\n                const useScopes = this.useJWTAccessWithScope || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;\n                const headers = await this.access.getRequestHeaders(url !== null && url !== void 0 ? url : undefined, this.additionalClaims, // Scopes take precedent over audience for signing,\n                // so we only provide them if `useJWTAccessWithScope` is on or\n                // if we are in a non-default universe\n                useScopes ? scopes : undefined);\n                return {\n                    headers: this.addSharedMetadataHeaders(headers)\n                };\n            }\n        } else if (this.hasAnyScopes() || this.apiKey) {\n            return super.getRequestMetadataAsync(url);\n        } else {\n            // If no audience, apiKey, or scopes are provided, we should not attempt\n            // to populate any headers:\n            return {\n                headers: {}\n            };\n        }\n    }\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */ async fetchIdToken(targetAudience) {\n        // Create a new gToken for fetching an ID token\n        const gtoken = new gtoken_1.GoogleToken({\n            iss: this.email,\n            sub: this.subject,\n            scope: this.scopes || this.defaultScopes,\n            keyFile: this.keyFile,\n            key: this.key,\n            additionalClaims: {\n                target_audience: targetAudience\n            },\n            transporter: this.transporter\n        });\n        await gtoken.getToken({\n            forceRefresh: true\n        });\n        if (!gtoken.idToken) {\n            throw new Error(\"Unknown error: Failed to fetch ID token\");\n        }\n        return gtoken.idToken;\n    }\n    /**\n     * Determine if there are currently scopes available.\n     */ hasUserScopes() {\n        if (!this.scopes) {\n            return false;\n        }\n        return this.scopes.length > 0;\n    }\n    /**\n     * Are there any default or user scopes defined.\n     */ hasAnyScopes() {\n        if (this.scopes && this.scopes.length > 0) return true;\n        if (this.defaultScopes && this.defaultScopes.length > 0) return true;\n        return false;\n    }\n    authorize(callback) {\n        if (callback) {\n            this.authorizeAsync().then((r)=>callback(null, r), callback);\n        } else {\n            return this.authorizeAsync();\n        }\n    }\n    async authorizeAsync() {\n        const result = await this.refreshToken();\n        if (!result) {\n            throw new Error(\"No result returned\");\n        }\n        this.credentials = result.tokens;\n        this.credentials.refresh_token = \"jwt-placeholder\";\n        this.key = this.gtoken.key;\n        this.email = this.gtoken.iss;\n        return result.tokens;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken ignored\n     * @private\n     */ async refreshTokenNoCache(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        const gtoken = this.createGToken();\n        const token = await gtoken.getToken({\n            forceRefresh: this.isTokenExpiring()\n        });\n        const tokens = {\n            access_token: token.access_token,\n            token_type: \"Bearer\",\n            expiry_date: gtoken.expiresAt,\n            id_token: gtoken.idToken\n        };\n        this.emit(\"tokens\", tokens);\n        return {\n            res: null,\n            tokens\n        };\n    }\n    /**\n     * Create a gToken if it doesn't already exist.\n     */ createGToken() {\n        if (!this.gtoken) {\n            this.gtoken = new gtoken_1.GoogleToken({\n                iss: this.email,\n                sub: this.subject,\n                scope: this.scopes || this.defaultScopes,\n                keyFile: this.keyFile,\n                key: this.key,\n                additionalClaims: this.additionalClaims,\n                transporter: this.transporter\n            });\n        }\n        return this.gtoken;\n    }\n    /**\n     * Create a JWT credentials instance using the given input options.\n     * @param json The input object.\n     */ fromJSON(json) {\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing the service account auth settings.\");\n        }\n        if (!json.client_email) {\n            throw new Error(\"The incoming JSON object does not contain a client_email field\");\n        }\n        if (!json.private_key) {\n            throw new Error(\"The incoming JSON object does not contain a private_key field\");\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n        this.quotaProjectId = json.quota_project_id;\n        this.universeDomain = json.universe_domain || this.universeDomain;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(()=>callback(), callback);\n        } else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                throw new Error(\"Must pass in a stream containing the service account auth settings.\");\n            }\n            let s = \"\";\n            inputStream.setEncoding(\"utf8\").on(\"error\", reject).on(\"data\", (chunk)=>s += chunk).on(\"end\", ()=>{\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Creates a JWT credentials instance using an API Key for authentication.\n     * @param apiKey The API Key in string form.\n     */ fromAPIKey(apiKey) {\n        if (typeof apiKey !== \"string\") {\n            throw new Error(\"Must provide an API Key string.\");\n        }\n        this.apiKey = apiKey;\n    }\n    /**\n     * Using the key or keyFile on the JWT client, obtain an object that contains\n     * the key and the client email.\n     */ async getCredentials() {\n        if (this.key) {\n            return {\n                private_key: this.key,\n                client_email: this.email\n            };\n        } else if (this.keyFile) {\n            const gtoken = this.createGToken();\n            const creds = await gtoken.getCredentials(this.keyFile);\n            return {\n                private_key: creds.privateKey,\n                client_email: creds.clientEmail\n            };\n        }\n        throw new Error(\"A key or a keyFile must be provided to getCredentials.\");\n    }\n}\nexports.JWT = JWT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2p3dGNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFdBQVcsR0FBRyxLQUFLO0FBQ25CLE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLHlFQUFRO0FBQ2pDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLG9HQUFhO0FBQ3pDLE1BQU1FLGlCQUFpQkYsbUJBQU9BLENBQUMsMEdBQWdCO0FBQy9DLE1BQU1HLGVBQWVILG1CQUFPQSxDQUFDLHNHQUFjO0FBQzNDLE1BQU1GLFlBQVlJLGVBQWVFLFlBQVk7SUFDekNDLFlBQVlDLGNBQWMsRUFBRUMsT0FBTyxFQUFFQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxLQUFLLENBQUU7UUFDOUQsTUFBTUMsT0FBT04sa0JBQWtCLE9BQU9BLG1CQUFtQixXQUNuREEsaUJBQ0E7WUFBRU8sT0FBT1A7WUFBZ0JDO1lBQVNDO1lBQUtHO1lBQU9GO1lBQVFDO1FBQVE7UUFDcEUsS0FBSyxDQUFDRTtRQUNOLElBQUksQ0FBQ0MsS0FBSyxHQUFHRCxLQUFLQyxLQUFLO1FBQ3ZCLElBQUksQ0FBQ04sT0FBTyxHQUFHSyxLQUFLTCxPQUFPO1FBQzNCLElBQUksQ0FBQ0MsR0FBRyxHQUFHSSxLQUFLSixHQUFHO1FBQ25CLElBQUksQ0FBQ0csS0FBSyxHQUFHQyxLQUFLRCxLQUFLO1FBQ3ZCLElBQUksQ0FBQ0YsTUFBTSxHQUFHRyxLQUFLSCxNQUFNO1FBQ3pCLElBQUksQ0FBQ0MsT0FBTyxHQUFHRSxLQUFLRixPQUFPO1FBQzNCLElBQUksQ0FBQ0ksZ0JBQWdCLEdBQUdGLEtBQUtFLGdCQUFnQjtRQUM3QyxtRUFBbUU7UUFDbkUsK0NBQStDO1FBQy9DLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1lBQUVDLGVBQWU7WUFBbUJDLGFBQWE7UUFBRTtJQUMxRTtJQUNBOzs7O0tBSUMsR0FDREMsYUFBYVQsTUFBTSxFQUFFO1FBQ2pCLE1BQU1VLE1BQU0sSUFBSXJCLElBQUksSUFBSTtRQUN4QnFCLElBQUlWLE1BQU0sR0FBR0E7UUFDYixPQUFPVTtJQUNYO0lBQ0E7Ozs7S0FJQyxHQUNELE1BQU1DLHdCQUF3QkMsR0FBRyxFQUFFO1FBQy9CQSxNQUFNLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDQSxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsR0FBR0Q7UUFDeEUsTUFBTUUsbUJBQW1CLENBQUUsSUFBSSxDQUFDQyxhQUFhLE1BQU1ILE9BQzlDLElBQUksQ0FBQ0kscUJBQXFCLElBQUksSUFBSSxDQUFDQyxZQUFZLE1BQ2hELElBQUksQ0FBQ0MsY0FBYyxLQUFLeEIsYUFBYXlCLGdCQUFnQjtRQUN6RCxJQUFJLElBQUksQ0FBQ2xCLE9BQU8sSUFBSSxJQUFJLENBQUNpQixjQUFjLEtBQUt4QixhQUFheUIsZ0JBQWdCLEVBQUU7WUFDdkUsTUFBTSxJQUFJQyxXQUFXLENBQUMsdUhBQXVILEVBQUUxQixhQUFheUIsZ0JBQWdCLENBQUMsQ0FBQztRQUNsTDtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNFLE1BQU0sSUFBSVAsa0JBQWtCO1lBQ2xDLElBQUksSUFBSSxDQUFDVCxnQkFBZ0IsSUFDckIsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQ2lCLGVBQWUsRUFBRTtnQkFDdkMsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ0MsWUFBWTtnQkFDMUMsT0FBTztvQkFDSEMsU0FBUyxJQUFJLENBQUNDLHdCQUF3QixDQUFDO3dCQUNuQ0MsZUFBZSxDQUFDLE9BQU8sRUFBRUosT0FBT0ssUUFBUSxDQUFDLENBQUM7b0JBQzlDO2dCQUNKO1lBQ0osT0FDSztnQkFDRCxzRUFBc0U7Z0JBQ3RFLGVBQWU7Z0JBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQ0MsTUFBTSxFQUFFO29CQUNkLElBQUksQ0FBQ0EsTUFBTSxHQUFHLElBQUlyQyxZQUFZc0MsU0FBUyxDQUFDLElBQUksQ0FBQzFCLEtBQUssRUFBRSxJQUFJLENBQUNMLEdBQUcsRUFBRSxJQUFJLENBQUNHLEtBQUssRUFBRSxJQUFJLENBQUM2QiwyQkFBMkI7Z0JBQzlHO2dCQUNBLElBQUkvQjtnQkFDSixJQUFJLElBQUksQ0FBQ2UsYUFBYSxJQUFJO29CQUN0QmYsU0FBUyxJQUFJLENBQUNBLE1BQU07Z0JBQ3hCLE9BQ0ssSUFBSSxDQUFDWSxLQUFLO29CQUNYWixTQUFTLElBQUksQ0FBQ2dDLGFBQWE7Z0JBQy9CO2dCQUNBLE1BQU1DLFlBQVksSUFBSSxDQUFDakIscUJBQXFCLElBQ3hDLElBQUksQ0FBQ0UsY0FBYyxLQUFLeEIsYUFBYXlCLGdCQUFnQjtnQkFDekQsTUFBTU0sVUFBVSxNQUFNLElBQUksQ0FBQ0ksTUFBTSxDQUFDSyxpQkFBaUIsQ0FBQ3RCLFFBQVEsUUFBUUEsUUFBUSxLQUFLLElBQUlBLE1BQU11QixXQUFXLElBQUksQ0FBQzlCLGdCQUFnQixFQUMzSCxtREFBbUQ7Z0JBQ25ELDhEQUE4RDtnQkFDOUQsc0NBQXNDO2dCQUN0QzRCLFlBQVlqQyxTQUFTbUM7Z0JBQ3JCLE9BQU87b0JBQUVWLFNBQVMsSUFBSSxDQUFDQyx3QkFBd0IsQ0FBQ0Q7Z0JBQVM7WUFDN0Q7UUFDSixPQUNLLElBQUksSUFBSSxDQUFDUixZQUFZLE1BQU0sSUFBSSxDQUFDSSxNQUFNLEVBQUU7WUFDekMsT0FBTyxLQUFLLENBQUNWLHdCQUF3QkM7UUFDekMsT0FDSztZQUNELHdFQUF3RTtZQUN4RSwyQkFBMkI7WUFDM0IsT0FBTztnQkFBRWEsU0FBUyxDQUFDO1lBQUU7UUFDekI7SUFDSjtJQUNBOzs7S0FHQyxHQUNELE1BQU1XLGFBQWFDLGNBQWMsRUFBRTtRQUMvQiwrQ0FBK0M7UUFDL0MsTUFBTUMsU0FBUyxJQUFJaEQsU0FBU2lELFdBQVcsQ0FBQztZQUNwQ0MsS0FBSyxJQUFJLENBQUNwQyxLQUFLO1lBQ2ZxQyxLQUFLLElBQUksQ0FBQ3hDLE9BQU87WUFDakJ5QyxPQUFPLElBQUksQ0FBQzFDLE1BQU0sSUFBSSxJQUFJLENBQUNnQyxhQUFhO1lBQ3hDbEMsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJDLEtBQUssSUFBSSxDQUFDQSxHQUFHO1lBQ2JNLGtCQUFrQjtnQkFBRWlCLGlCQUFpQmU7WUFBZTtZQUNwRE0sYUFBYSxJQUFJLENBQUNBLFdBQVc7UUFDakM7UUFDQSxNQUFNTCxPQUFPTSxRQUFRLENBQUM7WUFDbEJDLGNBQWM7UUFDbEI7UUFDQSxJQUFJLENBQUNQLE9BQU9RLE9BQU8sRUFBRTtZQUNqQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxPQUFPVCxPQUFPUSxPQUFPO0lBQ3pCO0lBQ0E7O0tBRUMsR0FDRC9CLGdCQUFnQjtRQUNaLElBQUksQ0FBQyxJQUFJLENBQUNmLE1BQU0sRUFBRTtZQUNkLE9BQU87UUFDWDtRQUNBLE9BQU8sSUFBSSxDQUFDQSxNQUFNLENBQUNnRCxNQUFNLEdBQUc7SUFDaEM7SUFDQTs7S0FFQyxHQUNEL0IsZUFBZTtRQUNYLElBQUksSUFBSSxDQUFDakIsTUFBTSxJQUFJLElBQUksQ0FBQ0EsTUFBTSxDQUFDZ0QsTUFBTSxHQUFHLEdBQ3BDLE9BQU87UUFDWCxJQUFJLElBQUksQ0FBQ2hCLGFBQWEsSUFBSSxJQUFJLENBQUNBLGFBQWEsQ0FBQ2dCLE1BQU0sR0FBRyxHQUNsRCxPQUFPO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLFVBQVVDLFFBQVEsRUFBRTtRQUNoQixJQUFJQSxVQUFVO1lBQ1YsSUFBSSxDQUFDQyxjQUFjLEdBQUdDLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0gsU0FBUyxNQUFNRyxJQUFJSDtRQUN2RCxPQUNLO1lBQ0QsT0FBTyxJQUFJLENBQUNDLGNBQWM7UUFDOUI7SUFDSjtJQUNBLE1BQU1BLGlCQUFpQjtRQUNuQixNQUFNRyxTQUFTLE1BQU0sSUFBSSxDQUFDOUIsWUFBWTtRQUN0QyxJQUFJLENBQUM4QixRQUFRO1lBQ1QsTUFBTSxJQUFJUCxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDekMsV0FBVyxHQUFHZ0QsT0FBTy9CLE1BQU07UUFDaEMsSUFBSSxDQUFDakIsV0FBVyxDQUFDQyxhQUFhLEdBQUc7UUFDakMsSUFBSSxDQUFDUixHQUFHLEdBQUcsSUFBSSxDQUFDdUMsTUFBTSxDQUFDdkMsR0FBRztRQUMxQixJQUFJLENBQUNLLEtBQUssR0FBRyxJQUFJLENBQUNrQyxNQUFNLENBQUNFLEdBQUc7UUFDNUIsT0FBT2MsT0FBTy9CLE1BQU07SUFDeEI7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTWdDLG9CQUNOLDZEQUE2RDtJQUM3RC9CLFlBQVksRUFBRTtRQUNWLE1BQU1jLFNBQVMsSUFBSSxDQUFDa0IsWUFBWTtRQUNoQyxNQUFNQyxRQUFRLE1BQU1uQixPQUFPTSxRQUFRLENBQUM7WUFDaENDLGNBQWMsSUFBSSxDQUFDYSxlQUFlO1FBQ3RDO1FBQ0EsTUFBTW5DLFNBQVM7WUFDWG9DLGNBQWNGLE1BQU1FLFlBQVk7WUFDaENDLFlBQVk7WUFDWnBELGFBQWE4QixPQUFPdUIsU0FBUztZQUM3QmpDLFVBQVVVLE9BQU9RLE9BQU87UUFDNUI7UUFDQSxJQUFJLENBQUNnQixJQUFJLENBQUMsVUFBVXZDO1FBQ3BCLE9BQU87WUFBRXdDLEtBQUs7WUFBTXhDO1FBQU87SUFDL0I7SUFDQTs7S0FFQyxHQUNEaUMsZUFBZTtRQUNYLElBQUksQ0FBQyxJQUFJLENBQUNsQixNQUFNLEVBQUU7WUFDZCxJQUFJLENBQUNBLE1BQU0sR0FBRyxJQUFJaEQsU0FBU2lELFdBQVcsQ0FBQztnQkFDbkNDLEtBQUssSUFBSSxDQUFDcEMsS0FBSztnQkFDZnFDLEtBQUssSUFBSSxDQUFDeEMsT0FBTztnQkFDakJ5QyxPQUFPLElBQUksQ0FBQzFDLE1BQU0sSUFBSSxJQUFJLENBQUNnQyxhQUFhO2dCQUN4Q2xDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQkMsS0FBSyxJQUFJLENBQUNBLEdBQUc7Z0JBQ2JNLGtCQUFrQixJQUFJLENBQUNBLGdCQUFnQjtnQkFDdkNzQyxhQUFhLElBQUksQ0FBQ0EsV0FBVztZQUNqQztRQUNKO1FBQ0EsT0FBTyxJQUFJLENBQUNMLE1BQU07SUFDdEI7SUFDQTs7O0tBR0MsR0FDRDBCLFNBQVNDLElBQUksRUFBRTtRQUNYLElBQUksQ0FBQ0EsTUFBTTtZQUNQLE1BQU0sSUFBSWxCLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNrQixLQUFLQyxZQUFZLEVBQUU7WUFDcEIsTUFBTSxJQUFJbkIsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ2tCLEtBQUtFLFdBQVcsRUFBRTtZQUNuQixNQUFNLElBQUlwQixNQUFNO1FBQ3BCO1FBQ0EsMkRBQTJEO1FBQzNELElBQUksQ0FBQzNDLEtBQUssR0FBRzZELEtBQUtDLFlBQVk7UUFDOUIsSUFBSSxDQUFDbkUsR0FBRyxHQUFHa0UsS0FBS0UsV0FBVztRQUMzQixJQUFJLENBQUNqRSxLQUFLLEdBQUcrRCxLQUFLRyxjQUFjO1FBQ2hDLElBQUksQ0FBQ0MsU0FBUyxHQUFHSixLQUFLSyxVQUFVO1FBQ2hDLElBQUksQ0FBQ0MsY0FBYyxHQUFHTixLQUFLTyxnQkFBZ0I7UUFDM0MsSUFBSSxDQUFDdEQsY0FBYyxHQUFHK0MsS0FBS1EsZUFBZSxJQUFJLElBQUksQ0FBQ3ZELGNBQWM7SUFDckU7SUFDQXdELFdBQVdDLFdBQVcsRUFBRXpCLFFBQVEsRUFBRTtRQUM5QixJQUFJQSxVQUFVO1lBQ1YsSUFBSSxDQUFDMEIsZUFBZSxDQUFDRCxhQUFhdkIsSUFBSSxDQUFDLElBQU1GLFlBQVlBO1FBQzdELE9BQ0s7WUFDRCxPQUFPLElBQUksQ0FBQzBCLGVBQWUsQ0FBQ0Q7UUFDaEM7SUFDSjtJQUNBQyxnQkFBZ0JELFdBQVcsRUFBRTtRQUN6QixPQUFPLElBQUlFLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekIsSUFBSSxDQUFDSixhQUFhO2dCQUNkLE1BQU0sSUFBSTVCLE1BQU07WUFDcEI7WUFDQSxJQUFJaUMsSUFBSTtZQUNSTCxZQUNLTSxXQUFXLENBQUMsUUFDWkMsRUFBRSxDQUFDLFNBQVNILFFBQ1pHLEVBQUUsQ0FBQyxRQUFRQyxDQUFBQSxRQUFVSCxLQUFLRyxPQUMxQkQsRUFBRSxDQUFDLE9BQU87Z0JBQ1gsSUFBSTtvQkFDQSxNQUFNRSxPQUFPQyxLQUFLQyxLQUFLLENBQUNOO29CQUN4QixJQUFJLENBQUNoQixRQUFRLENBQUNvQjtvQkFDZE47Z0JBQ0osRUFDQSxPQUFPUyxHQUFHO29CQUNOUixPQUFPUTtnQkFDWDtZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7S0FHQyxHQUNEQyxXQUFXbkUsTUFBTSxFQUFFO1FBQ2YsSUFBSSxPQUFPQSxXQUFXLFVBQVU7WUFDNUIsTUFBTSxJQUFJMEIsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQzFCLE1BQU0sR0FBR0E7SUFDbEI7SUFDQTs7O0tBR0MsR0FDRCxNQUFNb0UsaUJBQWlCO1FBQ25CLElBQUksSUFBSSxDQUFDMUYsR0FBRyxFQUFFO1lBQ1YsT0FBTztnQkFBRW9FLGFBQWEsSUFBSSxDQUFDcEUsR0FBRztnQkFBRW1FLGNBQWMsSUFBSSxDQUFDOUQsS0FBSztZQUFDO1FBQzdELE9BQ0ssSUFBSSxJQUFJLENBQUNOLE9BQU8sRUFBRTtZQUNuQixNQUFNd0MsU0FBUyxJQUFJLENBQUNrQixZQUFZO1lBQ2hDLE1BQU1rQyxRQUFRLE1BQU1wRCxPQUFPbUQsY0FBYyxDQUFDLElBQUksQ0FBQzNGLE9BQU87WUFDdEQsT0FBTztnQkFBRXFFLGFBQWF1QixNQUFNQyxVQUFVO2dCQUFFekIsY0FBY3dCLE1BQU1FLFdBQVc7WUFBQztRQUM1RTtRQUNBLE1BQU0sSUFBSTdDLE1BQU07SUFDcEI7QUFDSjtBQUNBNUQsV0FBVyxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb3RpZnktdG8teW91dHViZS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2p3dGNsaWVudC5qcz9jMmQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTMgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpXVCA9IHZvaWQgMDtcbmNvbnN0IGd0b2tlbl8xID0gcmVxdWlyZShcImd0b2tlblwiKTtcbmNvbnN0IGp3dGFjY2Vzc18xID0gcmVxdWlyZShcIi4vand0YWNjZXNzXCIpO1xuY29uc3Qgb2F1dGgyY2xpZW50XzEgPSByZXF1aXJlKFwiLi9vYXV0aDJjbGllbnRcIik7XG5jb25zdCBhdXRoY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoY2xpZW50XCIpO1xuY2xhc3MgSldUIGV4dGVuZHMgb2F1dGgyY2xpZW50XzEuT0F1dGgyQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zT3JFbWFpbCwga2V5RmlsZSwga2V5LCBzY29wZXMsIHN1YmplY3QsIGtleUlkKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zT3JFbWFpbCAmJiB0eXBlb2Ygb3B0aW9uc09yRW1haWwgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IG9wdGlvbnNPckVtYWlsXG4gICAgICAgICAgICA6IHsgZW1haWw6IG9wdGlvbnNPckVtYWlsLCBrZXlGaWxlLCBrZXksIGtleUlkLCBzY29wZXMsIHN1YmplY3QgfTtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMuZW1haWwgPSBvcHRzLmVtYWlsO1xuICAgICAgICB0aGlzLmtleUZpbGUgPSBvcHRzLmtleUZpbGU7XG4gICAgICAgIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gICAgICAgIHRoaXMua2V5SWQgPSBvcHRzLmtleUlkO1xuICAgICAgICB0aGlzLnNjb3BlcyA9IG9wdHMuc2NvcGVzO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBvcHRzLnN1YmplY3Q7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbENsYWltcyA9IG9wdHMuYWRkaXRpb25hbENsYWltcztcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhbiBleHBpcmVkIHJlZnJlc2ggdG9rZW4sIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBiZVxuICAgICAgICAvLyByZWZyZXNoZWQgYmVmb3JlIHRoZSBmaXJzdCBBUEkgY2FsbCBpcyBtYWRlLlxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0geyByZWZyZXNoX3Rva2VuOiAnand0LXBsYWNlaG9sZGVyJywgZXhwaXJ5X2RhdGU6IDEgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGNyZWRlbnRpYWwgd2l0aCB0aGUgc3BlY2lmaWVkIHNjb3Blcy5cbiAgICAgKiBAcGFyYW0gc2NvcGVzIExpc3Qgb2YgcmVxdWVzdGVkIHNjb3BlcyBvciBhIHNpbmdsZSBzY29wZS5cbiAgICAgKiBAcmV0dXJuIFRoZSBjbG9uZWQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY3JlYXRlU2NvcGVkKHNjb3Blcykge1xuICAgICAgICBjb25zdCBqd3QgPSBuZXcgSldUKHRoaXMpO1xuICAgICAgICBqd3Quc2NvcGVzID0gc2NvcGVzO1xuICAgICAgICByZXR1cm4gand0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIHRoZSBtZXRhZGF0YSB0byBiZSBzZW50IHdpdGggdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIHRoZSBVUkkgYmVpbmcgYXV0aG9yaXplZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyh1cmwpIHtcbiAgICAgICAgdXJsID0gdGhpcy5kZWZhdWx0U2VydmljZVBhdGggPyBgaHR0cHM6Ly8ke3RoaXMuZGVmYXVsdFNlcnZpY2VQYXRofS9gIDogdXJsO1xuICAgICAgICBjb25zdCB1c2VTZWxmU2lnbmVkSldUID0gKCF0aGlzLmhhc1VzZXJTY29wZXMoKSAmJiB1cmwpIHx8XG4gICAgICAgICAgICAodGhpcy51c2VKV1RBY2Nlc3NXaXRoU2NvcGUgJiYgdGhpcy5oYXNBbnlTY29wZXMoKSkgfHxcbiAgICAgICAgICAgIHRoaXMudW5pdmVyc2VEb21haW4gIT09IGF1dGhjbGllbnRfMS5ERUZBVUxUX1VOSVZFUlNFO1xuICAgICAgICBpZiAodGhpcy5zdWJqZWN0ICYmIHRoaXMudW5pdmVyc2VEb21haW4gIT09IGF1dGhjbGllbnRfMS5ERUZBVUxUX1VOSVZFUlNFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgU2VydmljZSBBY2NvdW50IHVzZXIgaXMgY29uZmlndXJlZCBmb3IgdGhlIGNyZWRlbnRpYWwuIERvbWFpbi13aWRlIGRlbGVnYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB1bml2ZXJzZXMgb3RoZXIgdGhhbiAke2F1dGhjbGllbnRfMS5ERUZBVUxUX1VOSVZFUlNFfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hcGlLZXkgJiYgdXNlU2VsZlNpZ25lZEpXVCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkaXRpb25hbENsYWltcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkaXRpb25hbENsYWltcy50YXJnZXRfYXVkaWVuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VucyB9ID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW5zLmlkX3Rva2VufWAsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBubyBzY29wZXMgaGF2ZSBiZWVuIHNldCwgYnV0IGEgdXJpIGhhcyBiZWVuIHByb3ZpZGVkLiBVc2UgSldUQWNjZXNzXG4gICAgICAgICAgICAgICAgLy8gY3JlZGVudGlhbHMuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY2VzcyA9IG5ldyBqd3RhY2Nlc3NfMS5KV1RBY2Nlc3ModGhpcy5lbWFpbCwgdGhpcy5rZXksIHRoaXMua2V5SWQsIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHNjb3BlcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNVc2VyU2NvcGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzID0gdGhpcy5kZWZhdWx0U2NvcGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB1c2VTY29wZXMgPSB0aGlzLnVzZUpXVEFjY2Vzc1dpdGhTY29wZSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuaXZlcnNlRG9tYWluICE9PSBhdXRoY2xpZW50XzEuREVGQVVMVF9VTklWRVJTRTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgdGhpcy5hY2Nlc3MuZ2V0UmVxdWVzdEhlYWRlcnModXJsICE9PSBudWxsICYmIHVybCAhPT0gdm9pZCAwID8gdXJsIDogdW5kZWZpbmVkLCB0aGlzLmFkZGl0aW9uYWxDbGFpbXMsIFxuICAgICAgICAgICAgICAgIC8vIFNjb3BlcyB0YWtlIHByZWNlZGVudCBvdmVyIGF1ZGllbmNlIGZvciBzaWduaW5nLFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIG9ubHkgcHJvdmlkZSB0aGVtIGlmIGB1c2VKV1RBY2Nlc3NXaXRoU2NvcGVgIGlzIG9uIG9yXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGluIGEgbm9uLWRlZmF1bHQgdW5pdmVyc2VcbiAgICAgICAgICAgICAgICB1c2VTY29wZXMgPyBzY29wZXMgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNBbnlTY29wZXMoKSB8fCB0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJlcXVlc3RNZXRhZGF0YUFzeW5jKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBubyBhdWRpZW5jZSwgYXBpS2V5LCBvciBzY29wZXMgYXJlIHByb3ZpZGVkLCB3ZSBzaG91bGQgbm90IGF0dGVtcHRcbiAgICAgICAgICAgIC8vIHRvIHBvcHVsYXRlIGFueSBoZWFkZXJzOlxuICAgICAgICAgICAgcmV0dXJuIHsgaGVhZGVyczoge30gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGFuIElEIHRva2VuLlxuICAgICAqIEBwYXJhbSB0YXJnZXRBdWRpZW5jZSB0aGUgYXVkaWVuY2UgZm9yIHRoZSBmZXRjaGVkIElEIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoSWRUb2tlbih0YXJnZXRBdWRpZW5jZSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZ1Rva2VuIGZvciBmZXRjaGluZyBhbiBJRCB0b2tlblxuICAgICAgICBjb25zdCBndG9rZW4gPSBuZXcgZ3Rva2VuXzEuR29vZ2xlVG9rZW4oe1xuICAgICAgICAgICAgaXNzOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAgc3ViOiB0aGlzLnN1YmplY3QsXG4gICAgICAgICAgICBzY29wZTogdGhpcy5zY29wZXMgfHwgdGhpcy5kZWZhdWx0U2NvcGVzLFxuICAgICAgICAgICAga2V5RmlsZTogdGhpcy5rZXlGaWxlLFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxDbGFpbXM6IHsgdGFyZ2V0X2F1ZGllbmNlOiB0YXJnZXRBdWRpZW5jZSB9LFxuICAgICAgICAgICAgdHJhbnNwb3J0ZXI6IHRoaXMudHJhbnNwb3J0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBndG9rZW4uZ2V0VG9rZW4oe1xuICAgICAgICAgICAgZm9yY2VSZWZyZXNoOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFndG9rZW4uaWRUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVycm9yOiBGYWlsZWQgdG8gZmV0Y2ggSUQgdG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3Rva2VuLmlkVG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGVyZSBhcmUgY3VycmVudGx5IHNjb3BlcyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgaGFzVXNlclNjb3BlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNjb3Blcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3Blcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcmUgdGhlcmUgYW55IGRlZmF1bHQgb3IgdXNlciBzY29wZXMgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBoYXNBbnlTY29wZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlcyAmJiB0aGlzLnNjb3Blcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRTY29wZXMgJiYgdGhpcy5kZWZhdWx0U2NvcGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhdXRob3JpemUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGhvcml6ZUFzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRob3JpemVBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGF1dGhvcml6ZUFzeW5jKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbigpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXN1bHQgcmV0dXJuZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gcmVzdWx0LnRva2VucztcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuID0gJ2p3dC1wbGFjZWhvbGRlcic7XG4gICAgICAgIHRoaXMua2V5ID0gdGhpcy5ndG9rZW4ua2V5O1xuICAgICAgICB0aGlzLmVtYWlsID0gdGhpcy5ndG9rZW4uaXNzO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRva2VucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBpZ25vcmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW5Ob0NhY2hlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICByZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZ3Rva2VuID0gdGhpcy5jcmVhdGVHVG9rZW4oKTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBndG9rZW4uZ2V0VG9rZW4oe1xuICAgICAgICAgICAgZm9yY2VSZWZyZXNoOiB0aGlzLmlzVG9rZW5FeHBpcmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0ge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB0b2tlbl90eXBlOiAnQmVhcmVyJyxcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiBndG9rZW4uZXhwaXJlc0F0LFxuICAgICAgICAgICAgaWRfdG9rZW46IGd0b2tlbi5pZFRva2VuLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB7IHJlczogbnVsbCwgdG9rZW5zIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGdUb2tlbiBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3QuXG4gICAgICovXG4gICAgY3JlYXRlR1Rva2VuKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3Rva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmd0b2tlbiA9IG5ldyBndG9rZW5fMS5Hb29nbGVUb2tlbih7XG4gICAgICAgICAgICAgICAgaXNzOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAgICAgIHN1YjogdGhpcy5zdWJqZWN0LFxuICAgICAgICAgICAgICAgIHNjb3BlOiB0aGlzLnNjb3BlcyB8fCB0aGlzLmRlZmF1bHRTY29wZXMsXG4gICAgICAgICAgICAgICAga2V5RmlsZTogdGhpcy5rZXlGaWxlLFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbENsYWltczogdGhpcy5hZGRpdGlvbmFsQ2xhaW1zLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyOiB0aGlzLnRyYW5zcG9ydGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3Rva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBKV1QgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGlucHV0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXJ2aWNlIGFjY291bnQgYXV0aCBzZXR0aW5ncy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uY2xpZW50X2VtYWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgY2xpZW50X2VtYWlsIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgcHJpdmF0ZV9rZXkgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IHRoZSByZWxldmFudCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBqc29uIGtleSBmaWxlLlxuICAgICAgICB0aGlzLmVtYWlsID0ganNvbi5jbGllbnRfZW1haWw7XG4gICAgICAgIHRoaXMua2V5ID0ganNvbi5wcml2YXRlX2tleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IGpzb24ucHJpdmF0ZV9rZXlfaWQ7XG4gICAgICAgIHRoaXMucHJvamVjdElkID0ganNvbi5wcm9qZWN0X2lkO1xuICAgICAgICB0aGlzLnF1b3RhUHJvamVjdElkID0ganNvbi5xdW90YV9wcm9qZWN0X2lkO1xuICAgICAgICB0aGlzLnVuaXZlcnNlRG9tYWluID0ganNvbi51bml2ZXJzZV9kb21haW4gfHwgdGhpcy51bml2ZXJzZURvbWFpbjtcbiAgICB9XG4gICAgZnJvbVN0cmVhbShpbnB1dFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSkudGhlbigoKSA9PiBjYWxsYmFjaygpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIHNlcnZpY2UgYWNjb3VudCBhdXRoIHNldHRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgICAgIGlucHV0U3RyZWFtXG4gICAgICAgICAgICAgICAgLnNldEVuY29kaW5nKCd1dGY4JylcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgICAgICAgICAgIC5vbignZGF0YScsIGNodW5rID0+IChzICs9IGNodW5rKSlcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm9tSlNPTihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgSldUIGNyZWRlbnRpYWxzIGluc3RhbmNlIHVzaW5nIGFuIEFQSSBLZXkgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBhcGlLZXkgVGhlIEFQSSBLZXkgaW4gc3RyaW5nIGZvcm0uXG4gICAgICovXG4gICAgZnJvbUFQSUtleShhcGlLZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcGlLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhbiBBUEkgS2V5IHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgdGhlIGtleSBvciBrZXlGaWxlIG9uIHRoZSBKV1QgY2xpZW50LCBvYnRhaW4gYW4gb2JqZWN0IHRoYXQgY29udGFpbnNcbiAgICAgKiB0aGUga2V5IGFuZCB0aGUgY2xpZW50IGVtYWlsLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENyZWRlbnRpYWxzKCkge1xuICAgICAgICBpZiAodGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHByaXZhdGVfa2V5OiB0aGlzLmtleSwgY2xpZW50X2VtYWlsOiB0aGlzLmVtYWlsIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5rZXlGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBndG9rZW4gPSB0aGlzLmNyZWF0ZUdUb2tlbigpO1xuICAgICAgICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCBndG9rZW4uZ2V0Q3JlZGVudGlhbHModGhpcy5rZXlGaWxlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHByaXZhdGVfa2V5OiBjcmVkcy5wcml2YXRlS2V5LCBjbGllbnRfZW1haWw6IGNyZWRzLmNsaWVudEVtYWlsIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGtleSBvciBhIGtleUZpbGUgbXVzdCBiZSBwcm92aWRlZCB0byBnZXRDcmVkZW50aWFscy4nKTtcbiAgICB9XG59XG5leHBvcnRzLkpXVCA9IEpXVDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkpXVCIsImd0b2tlbl8xIiwicmVxdWlyZSIsImp3dGFjY2Vzc18xIiwib2F1dGgyY2xpZW50XzEiLCJhdXRoY2xpZW50XzEiLCJPQXV0aDJDbGllbnQiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnNPckVtYWlsIiwia2V5RmlsZSIsImtleSIsInNjb3BlcyIsInN1YmplY3QiLCJrZXlJZCIsIm9wdHMiLCJlbWFpbCIsImFkZGl0aW9uYWxDbGFpbXMiLCJjcmVkZW50aWFscyIsInJlZnJlc2hfdG9rZW4iLCJleHBpcnlfZGF0ZSIsImNyZWF0ZVNjb3BlZCIsImp3dCIsImdldFJlcXVlc3RNZXRhZGF0YUFzeW5jIiwidXJsIiwiZGVmYXVsdFNlcnZpY2VQYXRoIiwidXNlU2VsZlNpZ25lZEpXVCIsImhhc1VzZXJTY29wZXMiLCJ1c2VKV1RBY2Nlc3NXaXRoU2NvcGUiLCJoYXNBbnlTY29wZXMiLCJ1bml2ZXJzZURvbWFpbiIsIkRFRkFVTFRfVU5JVkVSU0UiLCJSYW5nZUVycm9yIiwiYXBpS2V5IiwidGFyZ2V0X2F1ZGllbmNlIiwidG9rZW5zIiwicmVmcmVzaFRva2VuIiwiaGVhZGVycyIsImFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJpZF90b2tlbiIsImFjY2VzcyIsIkpXVEFjY2VzcyIsImVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyIsImRlZmF1bHRTY29wZXMiLCJ1c2VTY29wZXMiLCJnZXRSZXF1ZXN0SGVhZGVycyIsInVuZGVmaW5lZCIsImZldGNoSWRUb2tlbiIsInRhcmdldEF1ZGllbmNlIiwiZ3Rva2VuIiwiR29vZ2xlVG9rZW4iLCJpc3MiLCJzdWIiLCJzY29wZSIsInRyYW5zcG9ydGVyIiwiZ2V0VG9rZW4iLCJmb3JjZVJlZnJlc2giLCJpZFRva2VuIiwiRXJyb3IiLCJsZW5ndGgiLCJhdXRob3JpemUiLCJjYWxsYmFjayIsImF1dGhvcml6ZUFzeW5jIiwidGhlbiIsInIiLCJyZXN1bHQiLCJyZWZyZXNoVG9rZW5Ob0NhY2hlIiwiY3JlYXRlR1Rva2VuIiwidG9rZW4iLCJpc1Rva2VuRXhwaXJpbmciLCJhY2Nlc3NfdG9rZW4iLCJ0b2tlbl90eXBlIiwiZXhwaXJlc0F0IiwiZW1pdCIsInJlcyIsImZyb21KU09OIiwianNvbiIsImNsaWVudF9lbWFpbCIsInByaXZhdGVfa2V5IiwicHJpdmF0ZV9rZXlfaWQiLCJwcm9qZWN0SWQiLCJwcm9qZWN0X2lkIiwicXVvdGFQcm9qZWN0SWQiLCJxdW90YV9wcm9qZWN0X2lkIiwidW5pdmVyc2VfZG9tYWluIiwiZnJvbVN0cmVhbSIsImlucHV0U3RyZWFtIiwiZnJvbVN0cmVhbUFzeW5jIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzIiwic2V0RW5jb2RpbmciLCJvbiIsImNodW5rIiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsImUiLCJmcm9tQVBJS2V5IiwiZ2V0Q3JlZGVudGlhbHMiLCJjcmVkcyIsInByaXZhdGVLZXkiLCJjbGllbnRFbWFpbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/loginticket.js":
/*!************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/loginticket.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LoginTicket = void 0;\nclass LoginTicket {\n    /**\n     * Create a simple class to extract user ID from an ID Token\n     *\n     * @param {string} env Envelope of the jwt\n     * @param {TokenPayload} pay Payload of the jwt\n     * @constructor\n     */ constructor(env, pay){\n        this.envelope = env;\n        this.payload = pay;\n    }\n    getEnvelope() {\n        return this.envelope;\n    }\n    getPayload() {\n        return this.payload;\n    }\n    /**\n     * Create a simple class to extract user ID from an ID Token\n     *\n     * @return The user ID\n     */ getUserId() {\n        const payload = this.getPayload();\n        if (payload && payload.sub) {\n            return payload.sub;\n        }\n        return null;\n    }\n    /**\n     * Returns attributes from the login ticket.  This can contain\n     * various information about the user session.\n     *\n     * @return The envelope and payload\n     */ getAttributes() {\n        return {\n            envelope: this.getEnvelope(),\n            payload: this.getPayload()\n        };\n    }\n}\nexports.LoginTicket = LoginTicket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2xvZ2ludGlja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUcsS0FBSztBQUMzQixNQUFNRTtJQUNGOzs7Ozs7S0FNQyxHQUNEQyxZQUFZQyxHQUFHLEVBQUVDLEdBQUcsQ0FBRTtRQUNsQixJQUFJLENBQUNDLFFBQVEsR0FBR0Y7UUFDaEIsSUFBSSxDQUFDRyxPQUFPLEdBQUdGO0lBQ25CO0lBQ0FHLGNBQWM7UUFDVixPQUFPLElBQUksQ0FBQ0YsUUFBUTtJQUN4QjtJQUNBRyxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNGLE9BQU87SUFDdkI7SUFDQTs7OztLQUlDLEdBQ0RHLFlBQVk7UUFDUixNQUFNSCxVQUFVLElBQUksQ0FBQ0UsVUFBVTtRQUMvQixJQUFJRixXQUFXQSxRQUFRSSxHQUFHLEVBQUU7WUFDeEIsT0FBT0osUUFBUUksR0FBRztRQUN0QjtRQUNBLE9BQU87SUFDWDtJQUNBOzs7OztLQUtDLEdBQ0RDLGdCQUFnQjtRQUNaLE9BQU87WUFBRU4sVUFBVSxJQUFJLENBQUNFLFdBQVc7WUFBSUQsU0FBUyxJQUFJLENBQUNFLFVBQVU7UUFBRztJQUN0RTtBQUNKO0FBQ0FULG1CQUFtQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb3RpZnktdG8teW91dHViZS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2xvZ2ludGlja2V0LmpzP2Y3OWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNCBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9naW5UaWNrZXQgPSB2b2lkIDA7XG5jbGFzcyBMb2dpblRpY2tldCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2ltcGxlIGNsYXNzIHRvIGV4dHJhY3QgdXNlciBJRCBmcm9tIGFuIElEIFRva2VuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW52IEVudmVsb3BlIG9mIHRoZSBqd3RcbiAgICAgKiBAcGFyYW0ge1Rva2VuUGF5bG9hZH0gcGF5IFBheWxvYWQgb2YgdGhlIGp3dFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVudiwgcGF5KSB7XG4gICAgICAgIHRoaXMuZW52ZWxvcGUgPSBlbnY7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheTtcbiAgICB9XG4gICAgZ2V0RW52ZWxvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudmVsb3BlO1xuICAgIH1cbiAgICBnZXRQYXlsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXlsb2FkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzaW1wbGUgY2xhc3MgdG8gZXh0cmFjdCB1c2VyIElEIGZyb20gYW4gSUQgVG9rZW5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIHVzZXIgSURcbiAgICAgKi9cbiAgICBnZXRVc2VySWQoKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLmdldFBheWxvYWQoKTtcbiAgICAgICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5zdWIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkLnN1YjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhdHRyaWJ1dGVzIGZyb20gdGhlIGxvZ2luIHRpY2tldC4gIFRoaXMgY2FuIGNvbnRhaW5cbiAgICAgKiB2YXJpb3VzIGluZm9ybWF0aW9uIGFib3V0IHRoZSB1c2VyIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBlbnZlbG9wZSBhbmQgcGF5bG9hZFxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7IGVudmVsb3BlOiB0aGlzLmdldEVudmVsb3BlKCksIHBheWxvYWQ6IHRoaXMuZ2V0UGF5bG9hZCgpIH07XG4gICAgfVxufVxuZXhwb3J0cy5Mb2dpblRpY2tldCA9IExvZ2luVGlja2V0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTG9naW5UaWNrZXQiLCJjb25zdHJ1Y3RvciIsImVudiIsInBheSIsImVudmVsb3BlIiwicGF5bG9hZCIsImdldEVudmVsb3BlIiwiZ2V0UGF5bG9hZCIsImdldFVzZXJJZCIsInN1YiIsImdldEF0dHJpYnV0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/loginticket.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2client.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/oauth2client.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(action-browser)/./node_modules/gaxios/build/src/index.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst formatEcdsa = __webpack_require__(/*! ecdsa-sig-formatter */ \"(action-browser)/./node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(action-browser)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst loginticket_1 = __webpack_require__(/*! ./loginticket */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/loginticket.js\");\nvar CodeChallengeMethod;\n(function(CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod || (exports.CodeChallengeMethod = CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function(CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat || (exports.CertificateFormat = CertificateFormat = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n    constructor(optionsOrClientId, clientSecret, redirectUri){\n        const opts = optionsOrClientId && typeof optionsOrClientId === \"object\" ? optionsOrClientId : {\n            clientId: optionsOrClientId,\n            clientSecret,\n            redirectUri\n        };\n        super(opts);\n        this.certificateCache = {};\n        this.certificateExpiry = null;\n        this.certificateCacheFormat = CertificateFormat.PEM;\n        this.refreshTokenPromises = new Map();\n        this._clientId = opts.clientId;\n        this._clientSecret = opts.clientSecret;\n        this.redirectUri = opts.redirectUri;\n        this.endpoints = {\n            tokenInfoUrl: \"https://oauth2.googleapis.com/tokeninfo\",\n            oauth2AuthBaseUrl: \"https://accounts.google.com/o/oauth2/v2/auth\",\n            oauth2TokenUrl: \"https://oauth2.googleapis.com/token\",\n            oauth2RevokeUrl: \"https://oauth2.googleapis.com/revoke\",\n            oauth2FederatedSignonPemCertsUrl: \"https://www.googleapis.com/oauth2/v1/certs\",\n            oauth2FederatedSignonJwkCertsUrl: \"https://www.googleapis.com/oauth2/v3/certs\",\n            oauth2IapPublicKeyUrl: \"https://www.gstatic.com/iap/verify/public_key\",\n            ...opts.endpoints\n        };\n        this.issuers = opts.issuers || [\n            \"accounts.google.com\",\n            \"https://accounts.google.com\",\n            this.universeDomain\n        ];\n    }\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */ generateAuthUrl(opts = {}) {\n        if (opts.code_challenge_method && !opts.code_challenge) {\n            throw new Error(\"If a code_challenge_method is provided, code_challenge must be included.\");\n        }\n        opts.response_type = opts.response_type || \"code\";\n        opts.client_id = opts.client_id || this._clientId;\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n        // Allow scopes to be passed either as array or a string\n        if (Array.isArray(opts.scope)) {\n            opts.scope = opts.scope.join(\" \");\n        }\n        const rootUrl = this.endpoints.oauth2AuthBaseUrl.toString();\n        return rootUrl + \"?\" + querystring.stringify(opts);\n    }\n    generateCodeVerifier() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error(\"generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.\");\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and its\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     *\n     * For a full example see:\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\n     */ async generateCodeVerifierAsync() {\n        // base64 encoding uses 6 bits per character, and we want to generate128\n        // characters. 6*128/8 = 96.\n        const crypto = (0, crypto_1.createCrypto)();\n        const randomString = crypto.randomBytesBase64(96);\n        // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n        // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n        // swapping out a few chars.\n        const codeVerifier = randomString.replace(/\\+/g, \"~\").replace(/=/g, \"_\").replace(/\\//g, \"-\");\n        // Generate the base64 encoded SHA256\n        const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\n        // We need to use base64UrlEncoding instead of standard base64\n        const codeChallenge = unencodedCodeChallenge.split(\"=\")[0].replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n        return {\n            codeVerifier,\n            codeChallenge\n        };\n    }\n    getToken(codeOrOptions, callback) {\n        const options = typeof codeOrOptions === \"string\" ? {\n            code: codeOrOptions\n        } : codeOrOptions;\n        if (callback) {\n            this.getTokenAsync(options).then((r)=>callback(null, r.tokens, r.res), (e)=>callback(e, null, e.response));\n        } else {\n            return this.getTokenAsync(options);\n        }\n    }\n    async getTokenAsync(options) {\n        const url = this.endpoints.oauth2TokenUrl.toString();\n        const values = {\n            code: options.code,\n            client_id: options.client_id || this._clientId,\n            client_secret: this._clientSecret,\n            redirect_uri: options.redirect_uri || this.redirectUri,\n            grant_type: \"authorization_code\",\n            code_verifier: options.codeVerifier\n        };\n        const res = await this.transporter.request({\n            method: \"POST\",\n            url,\n            data: querystring.stringify(values),\n            headers: {\n                \"Content-Type\": \"application/x-www-form-urlencoded\"\n            }\n        });\n        const tokens = res.data;\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit(\"tokens\", tokens);\n        return {\n            tokens,\n            res\n        };\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */ async refreshToken(refreshToken) {\n        if (!refreshToken) {\n            return this.refreshTokenNoCache(refreshToken);\n        }\n        // If a request to refresh using the same token has started,\n        // return the same promise.\n        if (this.refreshTokenPromises.has(refreshToken)) {\n            return this.refreshTokenPromises.get(refreshToken);\n        }\n        const p = this.refreshTokenNoCache(refreshToken).then((r)=>{\n            this.refreshTokenPromises.delete(refreshToken);\n            return r;\n        }, (e)=>{\n            this.refreshTokenPromises.delete(refreshToken);\n            throw e;\n        });\n        this.refreshTokenPromises.set(refreshToken, p);\n        return p;\n    }\n    async refreshTokenNoCache(refreshToken) {\n        var _a;\n        if (!refreshToken) {\n            throw new Error(\"No refresh token is set.\");\n        }\n        const url = this.endpoints.oauth2TokenUrl.toString();\n        const data = {\n            refresh_token: refreshToken,\n            client_id: this._clientId,\n            client_secret: this._clientSecret,\n            grant_type: \"refresh_token\"\n        };\n        let res;\n        try {\n            // request for new token\n            res = await this.transporter.request({\n                method: \"POST\",\n                url,\n                data: querystring.stringify(data),\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            });\n        } catch (e) {\n            if (e instanceof gaxios_1.GaxiosError && e.message === \"invalid_grant\" && ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) && /ReAuth/i.test(e.response.data.error_description)) {\n                e.message = JSON.stringify(e.response.data);\n            }\n            throw e;\n        }\n        const tokens = res.data;\n        // TODO: de-duplicate this code from a few spots\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit(\"tokens\", tokens);\n        return {\n            tokens,\n            res\n        };\n    }\n    refreshAccessToken(callback) {\n        if (callback) {\n            this.refreshAccessTokenAsync().then((r)=>callback(null, r.credentials, r.res), callback);\n        } else {\n            return this.refreshAccessTokenAsync();\n        }\n    }\n    async refreshAccessTokenAsync() {\n        const r = await this.refreshToken(this.credentials.refresh_token);\n        const tokens = r.tokens;\n        tokens.refresh_token = this.credentials.refresh_token;\n        this.credentials = tokens;\n        return {\n            credentials: this.credentials,\n            res: r.res\n        };\n    }\n    getAccessToken(callback) {\n        if (callback) {\n            this.getAccessTokenAsync().then((r)=>callback(null, r.token, r.res), callback);\n        } else {\n            return this.getAccessTokenAsync();\n        }\n    }\n    async getAccessTokenAsync() {\n        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n        if (shouldRefresh) {\n            if (!this.credentials.refresh_token) {\n                if (this.refreshHandler) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                        return {\n                            token: this.credentials.access_token\n                        };\n                    }\n                } else {\n                    throw new Error(\"No refresh token or refresh handler callback is set.\");\n                }\n            }\n            const r = await this.refreshAccessTokenAsync();\n            if (!r.credentials || r.credentials && !r.credentials.access_token) {\n                throw new Error(\"Could not refresh access token.\");\n            }\n            return {\n                token: r.credentials.access_token,\n                res: r.res\n            };\n        } else {\n            return {\n                token: this.credentials.access_token\n            };\n        }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */ async getRequestHeaders(url) {\n        const headers = (await this.getRequestMetadataAsync(url)).headers;\n        return headers;\n    }\n    async getRequestMetadataAsync(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        const thisCreds = this.credentials;\n        if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler) {\n            throw new Error(\"No access, refresh token, API key or refresh handler callback is set.\");\n        }\n        if (thisCreds.access_token && !this.isTokenExpiring()) {\n            thisCreds.token_type = thisCreds.token_type || \"Bearer\";\n            const headers = {\n                Authorization: thisCreds.token_type + \" \" + thisCreds.access_token\n            };\n            return {\n                headers: this.addSharedMetadataHeaders(headers)\n            };\n        }\n        // If refreshHandler exists, call processAndValidateRefreshHandler().\n        if (this.refreshHandler) {\n            const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n            if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                this.setCredentials(refreshedAccessToken);\n                const headers = {\n                    Authorization: \"Bearer \" + this.credentials.access_token\n                };\n                return {\n                    headers: this.addSharedMetadataHeaders(headers)\n                };\n            }\n        }\n        if (this.apiKey) {\n            return {\n                headers: {\n                    \"X-Goog-Api-Key\": this.apiKey\n                }\n            };\n        }\n        let r = null;\n        let tokens = null;\n        try {\n            r = await this.refreshToken(thisCreds.refresh_token);\n            tokens = r.tokens;\n        } catch (err) {\n            const e = err;\n            if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n                e.message = `Could not refresh access token: ${e.message}`;\n            }\n            throw e;\n        }\n        const credentials = this.credentials;\n        credentials.token_type = credentials.token_type || \"Bearer\";\n        tokens.refresh_token = credentials.refresh_token;\n        this.credentials = tokens;\n        const headers = {\n            Authorization: credentials.token_type + \" \" + tokens.access_token\n        };\n        return {\n            headers: this.addSharedMetadataHeaders(headers),\n            res: r.res\n        };\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     *\n     * @deprecated use instance method {@link OAuth2Client.getRevokeTokenURL}\n     */ static getRevokeTokenUrl(token) {\n        return new OAuth2Client().getRevokeTokenURL(token).toString();\n    }\n    /**\n     * Generates a URL to revoke the given token.\n     *\n     * @param token The existing token to be revoked.\n     */ getRevokeTokenURL(token) {\n        const url = new URL(this.endpoints.oauth2RevokeUrl);\n        url.searchParams.append(\"token\", token);\n        return url;\n    }\n    revokeToken(token, callback) {\n        const opts = {\n            url: this.getRevokeTokenURL(token).toString(),\n            method: \"POST\"\n        };\n        if (callback) {\n            this.transporter.request(opts).then((r)=>callback(null, r), callback);\n        } else {\n            return this.transporter.request(opts);\n        }\n    }\n    revokeCredentials(callback) {\n        if (callback) {\n            this.revokeCredentialsAsync().then((res)=>callback(null, res), callback);\n        } else {\n            return this.revokeCredentialsAsync();\n        }\n    }\n    async revokeCredentialsAsync() {\n        const token = this.credentials.access_token;\n        this.credentials = {};\n        if (token) {\n            return this.revokeToken(token);\n        } else {\n            throw new Error(\"No access token to revoke.\");\n        }\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    async requestAsync(opts, retry = false) {\n        let r2;\n        try {\n            const r = await this.getRequestMetadataAsync(opts.url);\n            opts.headers = opts.headers || {};\n            if (r.headers && r.headers[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = r.headers[\"x-goog-user-project\"];\n            }\n            if (r.headers && r.headers.Authorization) {\n                opts.headers.Authorization = r.headers.Authorization;\n            }\n            if (this.apiKey) {\n                opts.headers[\"X-Goog-Api-Key\"] = this.apiKey;\n            }\n            r2 = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but either no\n                //   expiry_date was available or the forceRefreshOnFailure flag is set.\n                //   The absent expiry_date case can happen when developers stash the\n                //   access_token and refresh_token for later use, but the access_token\n                //   fails on the first try because it's expired. Some developers may\n                //   choose to enable forceRefreshOnFailure to mitigate time-related\n                //   errors.\n                // Or the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - No refresh_token was available\n                // - An access_token and a refreshHandler callback were available, but\n                //   either no expiry_date was available or the forceRefreshOnFailure\n                //   flag is set. The access_token fails on the first try because it's\n                //   expired. Some developers may choose to enable forceRefreshOnFailure\n                //   to mitigate time-related errors.\n                const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n                const mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n                    await this.refreshAccessTokenAsync();\n                    return this.requestAsync(opts, true);\n                } else if (!retry && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                    }\n                    return this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return r2;\n    }\n    verifyIdToken(options, callback) {\n        // This function used to accept two arguments instead of an options object.\n        // Check the types to help users upgrade with less pain.\n        // This check can be removed after a 2.0 release.\n        if (callback && typeof callback !== \"function\") {\n            throw new Error(\"This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.\");\n        }\n        if (callback) {\n            this.verifyIdTokenAsync(options).then((r)=>callback(null, r), callback);\n        } else {\n            return this.verifyIdTokenAsync(options);\n        }\n    }\n    async verifyIdTokenAsync(options) {\n        if (!options.idToken) {\n            throw new Error(\"The verifyIdToken method requires an ID Token\");\n        }\n        const response = await this.getFederatedSignonCertsAsync();\n        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, this.issuers, options.maxExpiry);\n        return login;\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */ async getTokenInfo(accessToken) {\n        const { data } = await this.transporter.request({\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                Authorization: `Bearer ${accessToken}`\n            },\n            url: this.endpoints.tokenInfoUrl.toString()\n        });\n        const info = Object.assign({\n            expiry_date: new Date().getTime() + data.expires_in * 1000,\n            scopes: data.scope.split(\" \")\n        }, data);\n        delete info.expires_in;\n        delete info.scope;\n        return info;\n    }\n    getFederatedSignonCerts(callback) {\n        if (callback) {\n            this.getFederatedSignonCertsAsync().then((r)=>callback(null, r.certs, r.res), callback);\n        } else {\n            return this.getFederatedSignonCertsAsync();\n        }\n    }\n    async getFederatedSignonCertsAsync() {\n        const nowTime = new Date().getTime();\n        const format = (0, crypto_1.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;\n        if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {\n            return {\n                certs: this.certificateCache,\n                format\n            };\n        }\n        let res;\n        let url;\n        switch(format){\n            case CertificateFormat.PEM:\n                url = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();\n                break;\n            case CertificateFormat.JWK:\n                url = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        try {\n            res = await this.transporter.request({\n                url\n            });\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        const cacheControl = res ? res.headers[\"cache-control\"] : undefined;\n        let cacheAge = -1;\n        if (cacheControl) {\n            const pattern = new RegExp(\"max-age=([0-9]*)\");\n            const regexResult = pattern.exec(cacheControl);\n            if (regexResult && regexResult.length === 2) {\n                // Cache results with max-age (in seconds)\n                cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n            }\n        }\n        let certificates = {};\n        switch(format){\n            case CertificateFormat.PEM:\n                certificates = res.data;\n                break;\n            case CertificateFormat.JWK:\n                for (const key of res.data.keys){\n                    certificates[key.kid] = key;\n                }\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        const now = new Date();\n        this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n        this.certificateCache = certificates;\n        this.certificateCacheFormat = format;\n        return {\n            certs: certificates,\n            format,\n            res\n        };\n    }\n    getIapPublicKeys(callback) {\n        if (callback) {\n            this.getIapPublicKeysAsync().then((r)=>callback(null, r.pubkeys, r.res), callback);\n        } else {\n            return this.getIapPublicKeysAsync();\n        }\n    }\n    async getIapPublicKeysAsync() {\n        let res;\n        const url = this.endpoints.oauth2IapPublicKeyUrl.toString();\n        try {\n            res = await this.transporter.request({\n                url\n            });\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        return {\n            pubkeys: res.data,\n            res\n        };\n    }\n    verifySignedJwtWithCerts() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error(\"verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.\");\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */ async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        const crypto = (0, crypto_1.createCrypto)();\n        if (!maxExpiry) {\n            maxExpiry = OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_;\n        }\n        const segments = jwt.split(\".\");\n        if (segments.length !== 3) {\n            throw new Error(\"Wrong number of segments in token: \" + jwt);\n        }\n        const signed = segments[0] + \".\" + segments[1];\n        let signature = segments[2];\n        let envelope;\n        let payload;\n        try {\n            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n            }\n            throw err;\n        }\n        if (!envelope) {\n            throw new Error(\"Can't parse token envelope: \" + segments[0]);\n        }\n        try {\n            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token payload '${segments[0]}`;\n            }\n            throw err;\n        }\n        if (!payload) {\n            throw new Error(\"Can't parse token payload: \" + segments[1]);\n        }\n        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n            // If this is not present, then there's no reason to attempt verification\n            throw new Error(\"No pem found for envelope: \" + JSON.stringify(envelope));\n        }\n        const cert = certs[envelope.kid];\n        if (envelope.alg === \"ES256\") {\n            signature = formatEcdsa.joseToDer(signature, \"ES256\").toString(\"base64\");\n        }\n        const verified = await crypto.verify(cert, signed, signature);\n        if (!verified) {\n            throw new Error(\"Invalid token signature: \" + jwt);\n        }\n        if (!payload.iat) {\n            throw new Error(\"No issue time in token: \" + JSON.stringify(payload));\n        }\n        if (!payload.exp) {\n            throw new Error(\"No expiration time in token: \" + JSON.stringify(payload));\n        }\n        const iat = Number(payload.iat);\n        if (isNaN(iat)) throw new Error(\"iat field using invalid format\");\n        const exp = Number(payload.exp);\n        if (isNaN(exp)) throw new Error(\"exp field using invalid format\");\n        const now = new Date().getTime() / 1000;\n        if (exp >= now + maxExpiry) {\n            throw new Error(\"Expiration time too far in future: \" + JSON.stringify(payload));\n        }\n        const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n        const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n        if (now < earliest) {\n            throw new Error(\"Token used too early, \" + now + \" < \" + earliest + \": \" + JSON.stringify(payload));\n        }\n        if (now > latest) {\n            throw new Error(\"Token used too late, \" + now + \" > \" + latest + \": \" + JSON.stringify(payload));\n        }\n        if (issuers && issuers.indexOf(payload.iss) < 0) {\n            throw new Error(\"Invalid issuer, expected one of [\" + issuers + \"], but got \" + payload.iss);\n        }\n        // Check the audience matches if we have one\n        if (typeof requiredAudience !== \"undefined\" && requiredAudience !== null) {\n            const aud = payload.aud;\n            let audVerified = false;\n            // If the requiredAudience is an array, check if it contains token\n            // audience\n            if (requiredAudience.constructor === Array) {\n                audVerified = requiredAudience.indexOf(aud) > -1;\n            } else {\n                audVerified = aud === requiredAudience;\n            }\n            if (!audVerified) {\n                throw new Error(\"Wrong recipient, payload audience != requiredAudience\");\n            }\n        }\n        return new loginticket_1.LoginTicket(envelope, payload);\n    }\n    /**\n     * Returns a promise that resolves with AccessTokenResponse type if\n     * refreshHandler is defined.\n     * If not, nothing is returned.\n     */ async processAndValidateRefreshHandler() {\n        if (this.refreshHandler) {\n            const accessTokenResponse = await this.refreshHandler();\n            if (!accessTokenResponse.access_token) {\n                throw new Error(\"No access token is returned by the refreshHandler callback.\");\n            }\n            return accessTokenResponse;\n        }\n        return;\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */ isTokenExpiring() {\n        const expiryDate = this.credentials.expiry_date;\n        return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n    }\n}\nexports.OAuth2Client = OAuth2Client;\n/**\n * @deprecated use instance's {@link OAuth2Client.endpoints}\n */ OAuth2Client.GOOGLE_TOKEN_INFO_URL = \"https://oauth2.googleapis.com/tokeninfo\";\n/**\n * Clock skew - five minutes in seconds\n */ OAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * The default max Token Lifetime is one day in seconds\n */ OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_ = 86400;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL29hdXRoMmNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSx5QkFBeUIsR0FBR0EsMkJBQTJCLEdBQUcsS0FBSztBQUN0RixNQUFNSyxXQUFXQyxtQkFBT0EsQ0FBQyx5RUFBUTtBQUNqQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUN6QyxNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQyxzQkFBUTtBQUMvQixNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQywyR0FBcUI7QUFDakQsTUFBTUksV0FBV0osbUJBQU9BLENBQUMsd0dBQWtCO0FBQzNDLE1BQU1LLGVBQWVMLG1CQUFPQSxDQUFDLHNHQUFjO0FBQzNDLE1BQU1NLGdCQUFnQk4sbUJBQU9BLENBQUMsd0dBQWU7QUFDN0MsSUFBSUY7QUFDSCxVQUFVQSxtQkFBbUI7SUFDMUJBLG1CQUFtQixDQUFDLFFBQVEsR0FBRztJQUMvQkEsbUJBQW1CLENBQUMsT0FBTyxHQUFHO0FBQ2xDLEdBQUdBLHVCQUF3QkosQ0FBQUEsMkJBQTJCLEdBQUdJLHNCQUFzQixDQUFDO0FBQ2hGLElBQUlEO0FBQ0gsVUFBVUEsaUJBQWlCO0lBQ3hCQSxpQkFBaUIsQ0FBQyxNQUFNLEdBQUc7SUFDM0JBLGlCQUFpQixDQUFDLE1BQU0sR0FBRztBQUMvQixHQUFHQSxxQkFBc0JILENBQUFBLHlCQUF5QixHQUFHRyxvQkFBb0IsQ0FBQztBQUMxRSxNQUFNRCxxQkFBcUJTLGFBQWFFLFVBQVU7SUFDOUNDLFlBQVlDLGlCQUFpQixFQUFFQyxZQUFZLEVBQUVDLFdBQVcsQ0FBRTtRQUN0RCxNQUFNQyxPQUFPSCxxQkFBcUIsT0FBT0Esc0JBQXNCLFdBQ3pEQSxvQkFDQTtZQUFFSSxVQUFVSjtZQUFtQkM7WUFBY0M7UUFBWTtRQUMvRCxLQUFLLENBQUNDO1FBQ04sSUFBSSxDQUFDRSxnQkFBZ0IsR0FBRyxDQUFDO1FBQ3pCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxzQkFBc0IsR0FBR25CLGtCQUFrQm9CLEdBQUc7UUFDbkQsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRyxJQUFJQztRQUNoQyxJQUFJLENBQUNDLFNBQVMsR0FBR1IsS0FBS0MsUUFBUTtRQUM5QixJQUFJLENBQUNRLGFBQWEsR0FBR1QsS0FBS0YsWUFBWTtRQUN0QyxJQUFJLENBQUNDLFdBQVcsR0FBR0MsS0FBS0QsV0FBVztRQUNuQyxJQUFJLENBQUNXLFNBQVMsR0FBRztZQUNiQyxjQUFjO1lBQ2RDLG1CQUFtQjtZQUNuQkMsZ0JBQWdCO1lBQ2hCQyxpQkFBaUI7WUFDakJDLGtDQUFrQztZQUNsQ0Msa0NBQWtDO1lBQ2xDQyx1QkFBdUI7WUFDdkIsR0FBR2pCLEtBQUtVLFNBQVM7UUFDckI7UUFDQSxJQUFJLENBQUNRLE9BQU8sR0FBR2xCLEtBQUtrQixPQUFPLElBQUk7WUFDM0I7WUFDQTtZQUNBLElBQUksQ0FBQ0MsY0FBYztTQUN0QjtJQUNMO0lBQ0E7Ozs7S0FJQyxHQUNEQyxnQkFBZ0JwQixPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUlBLEtBQUtxQixxQkFBcUIsSUFBSSxDQUFDckIsS0FBS3NCLGNBQWMsRUFBRTtZQUNwRCxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQXZCLEtBQUt3QixhQUFhLEdBQUd4QixLQUFLd0IsYUFBYSxJQUFJO1FBQzNDeEIsS0FBS3lCLFNBQVMsR0FBR3pCLEtBQUt5QixTQUFTLElBQUksSUFBSSxDQUFDakIsU0FBUztRQUNqRFIsS0FBSzBCLFlBQVksR0FBRzFCLEtBQUswQixZQUFZLElBQUksSUFBSSxDQUFDM0IsV0FBVztRQUN6RCx3REFBd0Q7UUFDeEQsSUFBSTRCLE1BQU1DLE9BQU8sQ0FBQzVCLEtBQUs2QixLQUFLLEdBQUc7WUFDM0I3QixLQUFLNkIsS0FBSyxHQUFHN0IsS0FBSzZCLEtBQUssQ0FBQ0MsSUFBSSxDQUFDO1FBQ2pDO1FBQ0EsTUFBTUMsVUFBVSxJQUFJLENBQUNyQixTQUFTLENBQUNFLGlCQUFpQixDQUFDb0IsUUFBUTtRQUN6RCxPQUFRRCxVQUNKLE1BQ0ExQyxZQUFZNEMsU0FBUyxDQUFDakM7SUFDOUI7SUFDQWtDLHVCQUF1QjtRQUNuQix3RUFBd0U7UUFDeEUscUJBQXFCO1FBQ3JCLE1BQU0sSUFBSVgsTUFBTTtJQUNwQjtJQUNBOzs7Ozs7O0tBT0MsR0FDRCxNQUFNWSw0QkFBNEI7UUFDOUIsd0VBQXdFO1FBQ3hFLDRCQUE0QjtRQUM1QixNQUFNQyxTQUFTLENBQUMsR0FBRzVDLFNBQVM2QyxZQUFZO1FBQ3hDLE1BQU1DLGVBQWVGLE9BQU9HLGlCQUFpQixDQUFDO1FBQzlDLG1FQUFtRTtRQUNuRSwwRUFBMEU7UUFDMUUsNEJBQTRCO1FBQzVCLE1BQU1DLGVBQWVGLGFBQ2hCRyxPQUFPLENBQUMsT0FBTyxLQUNmQSxPQUFPLENBQUMsTUFBTSxLQUNkQSxPQUFPLENBQUMsT0FBTztRQUNwQixxQ0FBcUM7UUFDckMsTUFBTUMseUJBQXlCLE1BQU1OLE9BQU9PLGtCQUFrQixDQUFDSDtRQUMvRCw4REFBOEQ7UUFDOUQsTUFBTUksZ0JBQWdCRix1QkFDakJHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUNiSixPQUFPLENBQUMsT0FBTyxLQUNmQSxPQUFPLENBQUMsT0FBTztRQUNwQixPQUFPO1lBQUVEO1lBQWNJO1FBQWM7SUFDekM7SUFDQUUsU0FBU0MsYUFBYSxFQUFFQyxRQUFRLEVBQUU7UUFDOUIsTUFBTUMsVUFBVSxPQUFPRixrQkFBa0IsV0FBVztZQUFFRyxNQUFNSDtRQUFjLElBQUlBO1FBQzlFLElBQUlDLFVBQVU7WUFDVixJQUFJLENBQUNHLGFBQWEsQ0FBQ0YsU0FBU0csSUFBSSxDQUFDQyxDQUFBQSxJQUFLTCxTQUFTLE1BQU1LLEVBQUVDLE1BQU0sRUFBRUQsRUFBRUUsR0FBRyxHQUFHQyxDQUFBQSxJQUFLUixTQUFTUSxHQUFHLE1BQU1BLEVBQUVDLFFBQVE7UUFDNUcsT0FDSztZQUNELE9BQU8sSUFBSSxDQUFDTixhQUFhLENBQUNGO1FBQzlCO0lBQ0o7SUFDQSxNQUFNRSxjQUFjRixPQUFPLEVBQUU7UUFDekIsTUFBTVMsTUFBTSxJQUFJLENBQUNoRCxTQUFTLENBQUNHLGNBQWMsQ0FBQ21CLFFBQVE7UUFDbEQsTUFBTTJCLFNBQVM7WUFDWFQsTUFBTUQsUUFBUUMsSUFBSTtZQUNsQnpCLFdBQVd3QixRQUFReEIsU0FBUyxJQUFJLElBQUksQ0FBQ2pCLFNBQVM7WUFDOUNvRCxlQUFlLElBQUksQ0FBQ25ELGFBQWE7WUFDakNpQixjQUFjdUIsUUFBUXZCLFlBQVksSUFBSSxJQUFJLENBQUMzQixXQUFXO1lBQ3REOEQsWUFBWTtZQUNaQyxlQUFlYixRQUFRVCxZQUFZO1FBQ3ZDO1FBQ0EsTUFBTWUsTUFBTSxNQUFNLElBQUksQ0FBQ1EsV0FBVyxDQUFDQyxPQUFPLENBQUM7WUFDdkNDLFFBQVE7WUFDUlA7WUFDQVEsTUFBTTdFLFlBQVk0QyxTQUFTLENBQUMwQjtZQUM1QlEsU0FBUztnQkFBRSxnQkFBZ0I7WUFBb0M7UUFDbkU7UUFDQSxNQUFNYixTQUFTQyxJQUFJVyxJQUFJO1FBQ3ZCLElBQUlYLElBQUlXLElBQUksSUFBSVgsSUFBSVcsSUFBSSxDQUFDRSxVQUFVLEVBQUU7WUFDakNkLE9BQU9lLFdBQVcsR0FBRyxJQUFJQyxPQUFPQyxPQUFPLEtBQUtoQixJQUFJVyxJQUFJLENBQUNFLFVBQVUsR0FBRztZQUNsRSxPQUFPZCxPQUFPYyxVQUFVO1FBQzVCO1FBQ0EsSUFBSSxDQUFDSSxJQUFJLENBQUMsVUFBVWxCO1FBQ3BCLE9BQU87WUFBRUE7WUFBUUM7UUFBSTtJQUN6QjtJQUNBOzs7O0tBSUMsR0FDRCxNQUFNa0IsYUFBYUEsWUFBWSxFQUFFO1FBQzdCLElBQUksQ0FBQ0EsY0FBYztZQUNmLE9BQU8sSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ0Q7UUFDcEM7UUFDQSw0REFBNEQ7UUFDNUQsMkJBQTJCO1FBQzNCLElBQUksSUFBSSxDQUFDbkUsb0JBQW9CLENBQUNxRSxHQUFHLENBQUNGLGVBQWU7WUFDN0MsT0FBTyxJQUFJLENBQUNuRSxvQkFBb0IsQ0FBQ3NFLEdBQUcsQ0FBQ0g7UUFDekM7UUFDQSxNQUFNSSxJQUFJLElBQUksQ0FBQ0gsbUJBQW1CLENBQUNELGNBQWNyQixJQUFJLENBQUNDLENBQUFBO1lBQ2xELElBQUksQ0FBQy9DLG9CQUFvQixDQUFDd0UsTUFBTSxDQUFDTDtZQUNqQyxPQUFPcEI7UUFDWCxHQUFHRyxDQUFBQTtZQUNDLElBQUksQ0FBQ2xELG9CQUFvQixDQUFDd0UsTUFBTSxDQUFDTDtZQUNqQyxNQUFNakI7UUFDVjtRQUNBLElBQUksQ0FBQ2xELG9CQUFvQixDQUFDeUUsR0FBRyxDQUFDTixjQUFjSTtRQUM1QyxPQUFPQTtJQUNYO0lBQ0EsTUFBTUgsb0JBQW9CRCxZQUFZLEVBQUU7UUFDcEMsSUFBSU87UUFDSixJQUFJLENBQUNQLGNBQWM7WUFDZixNQUFNLElBQUlsRCxNQUFNO1FBQ3BCO1FBQ0EsTUFBTW1DLE1BQU0sSUFBSSxDQUFDaEQsU0FBUyxDQUFDRyxjQUFjLENBQUNtQixRQUFRO1FBQ2xELE1BQU1rQyxPQUFPO1lBQ1RlLGVBQWVSO1lBQ2ZoRCxXQUFXLElBQUksQ0FBQ2pCLFNBQVM7WUFDekJvRCxlQUFlLElBQUksQ0FBQ25ELGFBQWE7WUFDakNvRCxZQUFZO1FBQ2hCO1FBQ0EsSUFBSU47UUFDSixJQUFJO1lBQ0Esd0JBQXdCO1lBQ3hCQSxNQUFNLE1BQU0sSUFBSSxDQUFDUSxXQUFXLENBQUNDLE9BQU8sQ0FBQztnQkFDakNDLFFBQVE7Z0JBQ1JQO2dCQUNBUSxNQUFNN0UsWUFBWTRDLFNBQVMsQ0FBQ2lDO2dCQUM1QkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW9DO1lBQ25FO1FBQ0osRUFDQSxPQUFPWCxHQUFHO1lBQ04sSUFBSUEsYUFBYXJFLFNBQVMrRixXQUFXLElBQ2pDMUIsRUFBRTJCLE9BQU8sS0FBSyxtQkFDYixFQUFDSCxLQUFLeEIsRUFBRUMsUUFBUSxNQUFNLFFBQVF1QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdkLElBQUksS0FDL0QsVUFBVWtCLElBQUksQ0FBQzVCLEVBQUVDLFFBQVEsQ0FBQ1MsSUFBSSxDQUFDbUIsaUJBQWlCLEdBQUc7Z0JBQ25EN0IsRUFBRTJCLE9BQU8sR0FBR0csS0FBS3JELFNBQVMsQ0FBQ3VCLEVBQUVDLFFBQVEsQ0FBQ1MsSUFBSTtZQUM5QztZQUNBLE1BQU1WO1FBQ1Y7UUFDQSxNQUFNRixTQUFTQyxJQUFJVyxJQUFJO1FBQ3ZCLGdEQUFnRDtRQUNoRCxJQUFJWCxJQUFJVyxJQUFJLElBQUlYLElBQUlXLElBQUksQ0FBQ0UsVUFBVSxFQUFFO1lBQ2pDZCxPQUFPZSxXQUFXLEdBQUcsSUFBSUMsT0FBT0MsT0FBTyxLQUFLaEIsSUFBSVcsSUFBSSxDQUFDRSxVQUFVLEdBQUc7WUFDbEUsT0FBT2QsT0FBT2MsVUFBVTtRQUM1QjtRQUNBLElBQUksQ0FBQ0ksSUFBSSxDQUFDLFVBQVVsQjtRQUNwQixPQUFPO1lBQUVBO1lBQVFDO1FBQUk7SUFDekI7SUFDQWdDLG1CQUFtQnZDLFFBQVEsRUFBRTtRQUN6QixJQUFJQSxVQUFVO1lBQ1YsSUFBSSxDQUFDd0MsdUJBQXVCLEdBQUdwQyxJQUFJLENBQUNDLENBQUFBLElBQUtMLFNBQVMsTUFBTUssRUFBRW9DLFdBQVcsRUFBRXBDLEVBQUVFLEdBQUcsR0FBR1A7UUFDbkYsT0FDSztZQUNELE9BQU8sSUFBSSxDQUFDd0MsdUJBQXVCO1FBQ3ZDO0lBQ0o7SUFDQSxNQUFNQSwwQkFBMEI7UUFDNUIsTUFBTW5DLElBQUksTUFBTSxJQUFJLENBQUNvQixZQUFZLENBQUMsSUFBSSxDQUFDZ0IsV0FBVyxDQUFDUixhQUFhO1FBQ2hFLE1BQU0zQixTQUFTRCxFQUFFQyxNQUFNO1FBQ3ZCQSxPQUFPMkIsYUFBYSxHQUFHLElBQUksQ0FBQ1EsV0FBVyxDQUFDUixhQUFhO1FBQ3JELElBQUksQ0FBQ1EsV0FBVyxHQUFHbkM7UUFDbkIsT0FBTztZQUFFbUMsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFBRWxDLEtBQUtGLEVBQUVFLEdBQUc7UUFBQztJQUN2RDtJQUNBbUMsZUFBZTFDLFFBQVEsRUFBRTtRQUNyQixJQUFJQSxVQUFVO1lBQ1YsSUFBSSxDQUFDMkMsbUJBQW1CLEdBQUd2QyxJQUFJLENBQUNDLENBQUFBLElBQUtMLFNBQVMsTUFBTUssRUFBRXVDLEtBQUssRUFBRXZDLEVBQUVFLEdBQUcsR0FBR1A7UUFDekUsT0FDSztZQUNELE9BQU8sSUFBSSxDQUFDMkMsbUJBQW1CO1FBQ25DO0lBQ0o7SUFDQSxNQUFNQSxzQkFBc0I7UUFDeEIsTUFBTUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDSixXQUFXLENBQUNLLFlBQVksSUFBSSxJQUFJLENBQUNDLGVBQWU7UUFDNUUsSUFBSUYsZUFBZTtZQUNmLElBQUksQ0FBQyxJQUFJLENBQUNKLFdBQVcsQ0FBQ1IsYUFBYSxFQUFFO2dCQUNqQyxJQUFJLElBQUksQ0FBQ2UsY0FBYyxFQUFFO29CQUNyQixNQUFNQyx1QkFBdUIsTUFBTSxJQUFJLENBQUNDLGdDQUFnQztvQkFDeEUsSUFBSUQseUJBQXlCLFFBQVFBLHlCQUF5QixLQUFLLElBQUksS0FBSyxJQUFJQSxxQkFBcUJILFlBQVksRUFBRTt3QkFDL0csSUFBSSxDQUFDSyxjQUFjLENBQUNGO3dCQUNwQixPQUFPOzRCQUFFTCxPQUFPLElBQUksQ0FBQ0gsV0FBVyxDQUFDSyxZQUFZO3dCQUFDO29CQUNsRDtnQkFDSixPQUNLO29CQUNELE1BQU0sSUFBSXZFLE1BQU07Z0JBQ3BCO1lBQ0o7WUFDQSxNQUFNOEIsSUFBSSxNQUFNLElBQUksQ0FBQ21DLHVCQUF1QjtZQUM1QyxJQUFJLENBQUNuQyxFQUFFb0MsV0FBVyxJQUFLcEMsRUFBRW9DLFdBQVcsSUFBSSxDQUFDcEMsRUFBRW9DLFdBQVcsQ0FBQ0ssWUFBWSxFQUFHO2dCQUNsRSxNQUFNLElBQUl2RSxNQUFNO1lBQ3BCO1lBQ0EsT0FBTztnQkFBRXFFLE9BQU92QyxFQUFFb0MsV0FBVyxDQUFDSyxZQUFZO2dCQUFFdkMsS0FBS0YsRUFBRUUsR0FBRztZQUFDO1FBQzNELE9BQ0s7WUFDRCxPQUFPO2dCQUFFcUMsT0FBTyxJQUFJLENBQUNILFdBQVcsQ0FBQ0ssWUFBWTtZQUFDO1FBQ2xEO0lBQ0o7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNELE1BQU1NLGtCQUFrQjFDLEdBQUcsRUFBRTtRQUN6QixNQUFNUyxVQUFVLENBQUMsTUFBTSxJQUFJLENBQUNrQyx1QkFBdUIsQ0FBQzNDLElBQUcsRUFBR1MsT0FBTztRQUNqRSxPQUFPQTtJQUNYO0lBQ0EsTUFBTWtDLHdCQUNOLDZEQUE2RDtJQUM3RDNDLEdBQUcsRUFBRTtRQUNELE1BQU00QyxZQUFZLElBQUksQ0FBQ2IsV0FBVztRQUNsQyxJQUFJLENBQUNhLFVBQVVSLFlBQVksSUFDdkIsQ0FBQ1EsVUFBVXJCLGFBQWEsSUFDeEIsQ0FBQyxJQUFJLENBQUNzQixNQUFNLElBQ1osQ0FBQyxJQUFJLENBQUNQLGNBQWMsRUFBRTtZQUN0QixNQUFNLElBQUl6RSxNQUFNO1FBQ3BCO1FBQ0EsSUFBSStFLFVBQVVSLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQ0MsZUFBZSxJQUFJO1lBQ25ETyxVQUFVRSxVQUFVLEdBQUdGLFVBQVVFLFVBQVUsSUFBSTtZQUMvQyxNQUFNckMsVUFBVTtnQkFDWnNDLGVBQWVILFVBQVVFLFVBQVUsR0FBRyxNQUFNRixVQUFVUixZQUFZO1lBQ3RFO1lBQ0EsT0FBTztnQkFBRTNCLFNBQVMsSUFBSSxDQUFDdUMsd0JBQXdCLENBQUN2QztZQUFTO1FBQzdEO1FBQ0EscUVBQXFFO1FBQ3JFLElBQUksSUFBSSxDQUFDNkIsY0FBYyxFQUFFO1lBQ3JCLE1BQU1DLHVCQUF1QixNQUFNLElBQUksQ0FBQ0MsZ0NBQWdDO1lBQ3hFLElBQUlELHlCQUF5QixRQUFRQSx5QkFBeUIsS0FBSyxJQUFJLEtBQUssSUFBSUEscUJBQXFCSCxZQUFZLEVBQUU7Z0JBQy9HLElBQUksQ0FBQ0ssY0FBYyxDQUFDRjtnQkFDcEIsTUFBTTlCLFVBQVU7b0JBQ1pzQyxlQUFlLFlBQVksSUFBSSxDQUFDaEIsV0FBVyxDQUFDSyxZQUFZO2dCQUM1RDtnQkFDQSxPQUFPO29CQUFFM0IsU0FBUyxJQUFJLENBQUN1Qyx3QkFBd0IsQ0FBQ3ZDO2dCQUFTO1lBQzdEO1FBQ0o7UUFDQSxJQUFJLElBQUksQ0FBQ29DLE1BQU0sRUFBRTtZQUNiLE9BQU87Z0JBQUVwQyxTQUFTO29CQUFFLGtCQUFrQixJQUFJLENBQUNvQyxNQUFNO2dCQUFDO1lBQUU7UUFDeEQ7UUFDQSxJQUFJbEQsSUFBSTtRQUNSLElBQUlDLFNBQVM7UUFDYixJQUFJO1lBQ0FELElBQUksTUFBTSxJQUFJLENBQUNvQixZQUFZLENBQUM2QixVQUFVckIsYUFBYTtZQUNuRDNCLFNBQVNELEVBQUVDLE1BQU07UUFDckIsRUFDQSxPQUFPcUQsS0FBSztZQUNSLE1BQU1uRCxJQUFJbUQ7WUFDVixJQUFJbkQsRUFBRUMsUUFBUSxJQUNURCxDQUFBQSxFQUFFQyxRQUFRLENBQUNtRCxNQUFNLEtBQUssT0FBT3BELEVBQUVDLFFBQVEsQ0FBQ21ELE1BQU0sS0FBSyxHQUFFLEdBQUk7Z0JBQzFEcEQsRUFBRTJCLE9BQU8sR0FBRyxDQUFDLGdDQUFnQyxFQUFFM0IsRUFBRTJCLE9BQU8sQ0FBQyxDQUFDO1lBQzlEO1lBQ0EsTUFBTTNCO1FBQ1Y7UUFDQSxNQUFNaUMsY0FBYyxJQUFJLENBQUNBLFdBQVc7UUFDcENBLFlBQVllLFVBQVUsR0FBR2YsWUFBWWUsVUFBVSxJQUFJO1FBQ25EbEQsT0FBTzJCLGFBQWEsR0FBR1EsWUFBWVIsYUFBYTtRQUNoRCxJQUFJLENBQUNRLFdBQVcsR0FBR25DO1FBQ25CLE1BQU1hLFVBQVU7WUFDWnNDLGVBQWVoQixZQUFZZSxVQUFVLEdBQUcsTUFBTWxELE9BQU93QyxZQUFZO1FBQ3JFO1FBQ0EsT0FBTztZQUFFM0IsU0FBUyxJQUFJLENBQUN1Qyx3QkFBd0IsQ0FBQ3ZDO1lBQVVaLEtBQUtGLEVBQUVFLEdBQUc7UUFBQztJQUN6RTtJQUNBOzs7OztLQUtDLEdBQ0QsT0FBT3NELGtCQUFrQmpCLEtBQUssRUFBRTtRQUM1QixPQUFPLElBQUk1RyxlQUFlOEgsaUJBQWlCLENBQUNsQixPQUFPNUQsUUFBUTtJQUMvRDtJQUNBOzs7O0tBSUMsR0FDRDhFLGtCQUFrQmxCLEtBQUssRUFBRTtRQUNyQixNQUFNbEMsTUFBTSxJQUFJcUQsSUFBSSxJQUFJLENBQUNyRyxTQUFTLENBQUNJLGVBQWU7UUFDbEQ0QyxJQUFJc0QsWUFBWSxDQUFDQyxNQUFNLENBQUMsU0FBU3JCO1FBQ2pDLE9BQU9sQztJQUNYO0lBQ0F3RCxZQUFZdEIsS0FBSyxFQUFFNUMsUUFBUSxFQUFFO1FBQ3pCLE1BQU1oRCxPQUFPO1lBQ1QwRCxLQUFLLElBQUksQ0FBQ29ELGlCQUFpQixDQUFDbEIsT0FBTzVELFFBQVE7WUFDM0NpQyxRQUFRO1FBQ1o7UUFDQSxJQUFJakIsVUFBVTtZQUNWLElBQUksQ0FBQ2UsV0FBVyxDQUNYQyxPQUFPLENBQUNoRSxNQUNSb0QsSUFBSSxDQUFDQyxDQUFBQSxJQUFLTCxTQUFTLE1BQU1LLElBQUlMO1FBQ3RDLE9BQ0s7WUFDRCxPQUFPLElBQUksQ0FBQ2UsV0FBVyxDQUFDQyxPQUFPLENBQUNoRTtRQUNwQztJQUNKO0lBQ0FtSCxrQkFBa0JuRSxRQUFRLEVBQUU7UUFDeEIsSUFBSUEsVUFBVTtZQUNWLElBQUksQ0FBQ29FLHNCQUFzQixHQUFHaEUsSUFBSSxDQUFDRyxDQUFBQSxNQUFPUCxTQUFTLE1BQU1PLE1BQU1QO1FBQ25FLE9BQ0s7WUFDRCxPQUFPLElBQUksQ0FBQ29FLHNCQUFzQjtRQUN0QztJQUNKO0lBQ0EsTUFBTUEseUJBQXlCO1FBQzNCLE1BQU14QixRQUFRLElBQUksQ0FBQ0gsV0FBVyxDQUFDSyxZQUFZO1FBQzNDLElBQUksQ0FBQ0wsV0FBVyxHQUFHLENBQUM7UUFDcEIsSUFBSUcsT0FBTztZQUNQLE9BQU8sSUFBSSxDQUFDc0IsV0FBVyxDQUFDdEI7UUFDNUIsT0FDSztZQUNELE1BQU0sSUFBSXJFLE1BQU07UUFDcEI7SUFDSjtJQUNBeUMsUUFBUWhFLElBQUksRUFBRWdELFFBQVEsRUFBRTtRQUNwQixJQUFJQSxVQUFVO1lBQ1YsSUFBSSxDQUFDcUUsWUFBWSxDQUFDckgsTUFBTW9ELElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0wsU0FBUyxNQUFNSyxJQUFJRyxDQUFBQTtnQkFDakQsT0FBT1IsU0FBU1EsR0FBR0EsRUFBRUMsUUFBUTtZQUNqQztRQUNKLE9BQ0s7WUFDRCxPQUFPLElBQUksQ0FBQzRELFlBQVksQ0FBQ3JIO1FBQzdCO0lBQ0o7SUFDQSxNQUFNcUgsYUFBYXJILElBQUksRUFBRXNILFFBQVEsS0FBSyxFQUFFO1FBQ3BDLElBQUlDO1FBQ0osSUFBSTtZQUNBLE1BQU1sRSxJQUFJLE1BQU0sSUFBSSxDQUFDZ0QsdUJBQXVCLENBQUNyRyxLQUFLMEQsR0FBRztZQUNyRDFELEtBQUttRSxPQUFPLEdBQUduRSxLQUFLbUUsT0FBTyxJQUFJLENBQUM7WUFDaEMsSUFBSWQsRUFBRWMsT0FBTyxJQUFJZCxFQUFFYyxPQUFPLENBQUMsc0JBQXNCLEVBQUU7Z0JBQy9DbkUsS0FBS21FLE9BQU8sQ0FBQyxzQkFBc0IsR0FBR2QsRUFBRWMsT0FBTyxDQUFDLHNCQUFzQjtZQUMxRTtZQUNBLElBQUlkLEVBQUVjLE9BQU8sSUFBSWQsRUFBRWMsT0FBTyxDQUFDc0MsYUFBYSxFQUFFO2dCQUN0Q3pHLEtBQUttRSxPQUFPLENBQUNzQyxhQUFhLEdBQUdwRCxFQUFFYyxPQUFPLENBQUNzQyxhQUFhO1lBQ3hEO1lBQ0EsSUFBSSxJQUFJLENBQUNGLE1BQU0sRUFBRTtnQkFDYnZHLEtBQUttRSxPQUFPLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDb0MsTUFBTTtZQUNoRDtZQUNBZ0IsS0FBSyxNQUFNLElBQUksQ0FBQ3hELFdBQVcsQ0FBQ0MsT0FBTyxDQUFDaEU7UUFDeEMsRUFDQSxPQUFPd0QsR0FBRztZQUNOLE1BQU1ELE1BQU1DLEVBQUVDLFFBQVE7WUFDdEIsSUFBSUYsS0FBSztnQkFDTCxNQUFNaUUsYUFBYWpFLElBQUlxRCxNQUFNO2dCQUM3QixxRUFBcUU7Z0JBQ3JFLG9FQUFvRTtnQkFDcEUsb0NBQW9DO2dCQUNwQyw2Q0FBNkM7Z0JBQzdDLG9FQUFvRTtnQkFDcEUsd0VBQXdFO2dCQUN4RSxxRUFBcUU7Z0JBQ3JFLHVFQUF1RTtnQkFDdkUscUVBQXFFO2dCQUNyRSxvRUFBb0U7Z0JBQ3BFLFlBQVk7Z0JBQ1osc0NBQXNDO2dCQUN0QyxvRUFBb0U7Z0JBQ3BFLG9DQUFvQztnQkFDcEMsNkNBQTZDO2dCQUM3QyxtQ0FBbUM7Z0JBQ25DLHNFQUFzRTtnQkFDdEUscUVBQXFFO2dCQUNyRSxzRUFBc0U7Z0JBQ3RFLHdFQUF3RTtnQkFDeEUscUNBQXFDO2dCQUNyQyxNQUFNYSxvQkFBb0IsSUFBSSxDQUFDaEMsV0FBVyxJQUN0QyxJQUFJLENBQUNBLFdBQVcsQ0FBQ0ssWUFBWSxJQUM3QixJQUFJLENBQUNMLFdBQVcsQ0FBQ1IsYUFBYSxJQUM3QixFQUFDLElBQUksQ0FBQ1EsV0FBVyxDQUFDcEIsV0FBVyxJQUFJLElBQUksQ0FBQ3FELHFCQUFxQjtnQkFDaEUsTUFBTUMsc0NBQXNDLElBQUksQ0FBQ2xDLFdBQVcsSUFDeEQsSUFBSSxDQUFDQSxXQUFXLENBQUNLLFlBQVksSUFDN0IsQ0FBQyxJQUFJLENBQUNMLFdBQVcsQ0FBQ1IsYUFBYSxJQUM5QixFQUFDLElBQUksQ0FBQ1EsV0FBVyxDQUFDcEIsV0FBVyxJQUFJLElBQUksQ0FBQ3FELHFCQUFxQixLQUM1RCxJQUFJLENBQUMxQixjQUFjO2dCQUN2QixNQUFNNEIsbUJBQW1CckUsSUFBSXNFLE1BQU0sQ0FBQzNELElBQUksWUFBWTVFLE9BQU93SSxRQUFRO2dCQUNuRSxNQUFNQyxZQUFZUCxlQUFlLE9BQU9BLGVBQWU7Z0JBQ3ZELElBQUksQ0FBQ0YsU0FBU1MsYUFBYSxDQUFDSCxvQkFBb0JILG1CQUFtQjtvQkFDL0QsTUFBTSxJQUFJLENBQUNqQyx1QkFBdUI7b0JBQ2xDLE9BQU8sSUFBSSxDQUFDNkIsWUFBWSxDQUFDckgsTUFBTTtnQkFDbkMsT0FDSyxJQUFJLENBQUNzSCxTQUNOUyxhQUNBLENBQUNILG9CQUNERCxxQ0FBcUM7b0JBQ3JDLE1BQU0xQix1QkFBdUIsTUFBTSxJQUFJLENBQUNDLGdDQUFnQztvQkFDeEUsSUFBSUQseUJBQXlCLFFBQVFBLHlCQUF5QixLQUFLLElBQUksS0FBSyxJQUFJQSxxQkFBcUJILFlBQVksRUFBRTt3QkFDL0csSUFBSSxDQUFDSyxjQUFjLENBQUNGO29CQUN4QjtvQkFDQSxPQUFPLElBQUksQ0FBQ29CLFlBQVksQ0FBQ3JILE1BQU07Z0JBQ25DO1lBQ0o7WUFDQSxNQUFNd0Q7UUFDVjtRQUNBLE9BQU8rRDtJQUNYO0lBQ0FTLGNBQWMvRSxPQUFPLEVBQUVELFFBQVEsRUFBRTtRQUM3QiwyRUFBMkU7UUFDM0Usd0RBQXdEO1FBQ3hELGlEQUFpRDtRQUNqRCxJQUFJQSxZQUFZLE9BQU9BLGFBQWEsWUFBWTtZQUM1QyxNQUFNLElBQUl6QixNQUFNO1FBQ3BCO1FBQ0EsSUFBSXlCLFVBQVU7WUFDVixJQUFJLENBQUNpRixrQkFBa0IsQ0FBQ2hGLFNBQVNHLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0wsU0FBUyxNQUFNSyxJQUFJTDtRQUNsRSxPQUNLO1lBQ0QsT0FBTyxJQUFJLENBQUNpRixrQkFBa0IsQ0FBQ2hGO1FBQ25DO0lBQ0o7SUFDQSxNQUFNZ0YsbUJBQW1CaEYsT0FBTyxFQUFFO1FBQzlCLElBQUksQ0FBQ0EsUUFBUWlGLE9BQU8sRUFBRTtZQUNsQixNQUFNLElBQUkzRyxNQUFNO1FBQ3BCO1FBQ0EsTUFBTWtDLFdBQVcsTUFBTSxJQUFJLENBQUMwRSw0QkFBNEI7UUFDeEQsTUFBTUMsUUFBUSxNQUFNLElBQUksQ0FBQ0MsNkJBQTZCLENBQUNwRixRQUFRaUYsT0FBTyxFQUFFekUsU0FBUzZFLEtBQUssRUFBRXJGLFFBQVFzRixRQUFRLEVBQUUsSUFBSSxDQUFDckgsT0FBTyxFQUFFK0IsUUFBUXVGLFNBQVM7UUFDekksT0FBT0o7SUFDWDtJQUNBOzs7Ozs7S0FNQyxHQUNELE1BQU1LLGFBQWFDLFdBQVcsRUFBRTtRQUM1QixNQUFNLEVBQUV4RSxJQUFJLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ0gsV0FBVyxDQUFDQyxPQUFPLENBQUM7WUFDNUNDLFFBQVE7WUFDUkUsU0FBUztnQkFDTCxnQkFBZ0I7Z0JBQ2hCc0MsZUFBZSxDQUFDLE9BQU8sRUFBRWlDLFlBQVksQ0FBQztZQUMxQztZQUNBaEYsS0FBSyxJQUFJLENBQUNoRCxTQUFTLENBQUNDLFlBQVksQ0FBQ3FCLFFBQVE7UUFDN0M7UUFDQSxNQUFNMkcsT0FBTy9KLE9BQU9nSyxNQUFNLENBQUM7WUFDdkJ2RSxhQUFhLElBQUlDLE9BQU9DLE9BQU8sS0FBS0wsS0FBS0UsVUFBVSxHQUFHO1lBQ3REeUUsUUFBUTNFLEtBQUtyQyxLQUFLLENBQUNnQixLQUFLLENBQUM7UUFDN0IsR0FBR3FCO1FBQ0gsT0FBT3lFLEtBQUt2RSxVQUFVO1FBQ3RCLE9BQU91RSxLQUFLOUcsS0FBSztRQUNqQixPQUFPOEc7SUFDWDtJQUNBRyx3QkFBd0I5RixRQUFRLEVBQUU7UUFDOUIsSUFBSUEsVUFBVTtZQUNWLElBQUksQ0FBQ21GLDRCQUE0QixHQUFHL0UsSUFBSSxDQUFDQyxDQUFBQSxJQUFLTCxTQUFTLE1BQU1LLEVBQUVpRixLQUFLLEVBQUVqRixFQUFFRSxHQUFHLEdBQUdQO1FBQ2xGLE9BQ0s7WUFDRCxPQUFPLElBQUksQ0FBQ21GLDRCQUE0QjtRQUM1QztJQUNKO0lBQ0EsTUFBTUEsK0JBQStCO1FBQ2pDLE1BQU1ZLFVBQVUsSUFBSXpFLE9BQU9DLE9BQU87UUFDbEMsTUFBTXlFLFNBQVMsQ0FBQyxHQUFHeEosU0FBU3lKLGdCQUFnQixNQUN0Q2hLLGtCQUFrQmlLLEdBQUcsR0FDckJqSyxrQkFBa0JvQixHQUFHO1FBQzNCLElBQUksSUFBSSxDQUFDRixpQkFBaUIsSUFDdEI0SSxVQUFVLElBQUksQ0FBQzVJLGlCQUFpQixDQUFDb0UsT0FBTyxNQUN4QyxJQUFJLENBQUNuRSxzQkFBc0IsS0FBSzRJLFFBQVE7WUFDeEMsT0FBTztnQkFBRVYsT0FBTyxJQUFJLENBQUNwSSxnQkFBZ0I7Z0JBQUU4STtZQUFPO1FBQ2xEO1FBQ0EsSUFBSXpGO1FBQ0osSUFBSUc7UUFDSixPQUFRc0Y7WUFDSixLQUFLL0osa0JBQWtCb0IsR0FBRztnQkFDdEJxRCxNQUFNLElBQUksQ0FBQ2hELFNBQVMsQ0FBQ0ssZ0NBQWdDLENBQUNpQixRQUFRO2dCQUM5RDtZQUNKLEtBQUsvQyxrQkFBa0JpSyxHQUFHO2dCQUN0QnhGLE1BQU0sSUFBSSxDQUFDaEQsU0FBUyxDQUFDTSxnQ0FBZ0MsQ0FBQ2dCLFFBQVE7Z0JBQzlEO1lBQ0o7Z0JBQ0ksTUFBTSxJQUFJVCxNQUFNLENBQUMsK0JBQStCLEVBQUV5SCxPQUFPLENBQUM7UUFDbEU7UUFDQSxJQUFJO1lBQ0F6RixNQUFNLE1BQU0sSUFBSSxDQUFDUSxXQUFXLENBQUNDLE9BQU8sQ0FBQztnQkFBRU47WUFBSTtRQUMvQyxFQUNBLE9BQU9GLEdBQUc7WUFDTixJQUFJQSxhQUFhakMsT0FBTztnQkFDcEJpQyxFQUFFMkIsT0FBTyxHQUFHLENBQUMsOENBQThDLEVBQUUzQixFQUFFMkIsT0FBTyxDQUFDLENBQUM7WUFDNUU7WUFDQSxNQUFNM0I7UUFDVjtRQUNBLE1BQU0yRixlQUFlNUYsTUFBTUEsSUFBSVksT0FBTyxDQUFDLGdCQUFnQixHQUFHaUY7UUFDMUQsSUFBSUMsV0FBVyxDQUFDO1FBQ2hCLElBQUlGLGNBQWM7WUFDZCxNQUFNRyxVQUFVLElBQUlDLE9BQU87WUFDM0IsTUFBTUMsY0FBY0YsUUFBUUcsSUFBSSxDQUFDTjtZQUNqQyxJQUFJSyxlQUFlQSxZQUFZRSxNQUFNLEtBQUssR0FBRztnQkFDekMsMENBQTBDO2dCQUMxQ0wsV0FBV00sT0FBT0gsV0FBVyxDQUFDLEVBQUUsSUFBSSxNQUFNLGVBQWU7WUFDN0Q7UUFDSjtRQUNBLElBQUlJLGVBQWUsQ0FBQztRQUNwQixPQUFRWjtZQUNKLEtBQUsvSixrQkFBa0JvQixHQUFHO2dCQUN0QnVKLGVBQWVyRyxJQUFJVyxJQUFJO2dCQUN2QjtZQUNKLEtBQUtqRixrQkFBa0JpSyxHQUFHO2dCQUN0QixLQUFLLE1BQU1XLE9BQU90RyxJQUFJVyxJQUFJLENBQUM0RixJQUFJLENBQUU7b0JBQzdCRixZQUFZLENBQUNDLElBQUlFLEdBQUcsQ0FBQyxHQUFHRjtnQkFDNUI7Z0JBQ0E7WUFDSjtnQkFDSSxNQUFNLElBQUl0SSxNQUFNLENBQUMsK0JBQStCLEVBQUV5SCxPQUFPLENBQUM7UUFDbEU7UUFDQSxNQUFNZ0IsTUFBTSxJQUFJMUY7UUFDaEIsSUFBSSxDQUFDbkUsaUJBQWlCLEdBQ2xCa0osYUFBYSxDQUFDLElBQUksT0FBTyxJQUFJL0UsS0FBSzBGLElBQUl6RixPQUFPLEtBQUs4RTtRQUN0RCxJQUFJLENBQUNuSixnQkFBZ0IsR0FBRzBKO1FBQ3hCLElBQUksQ0FBQ3hKLHNCQUFzQixHQUFHNEk7UUFDOUIsT0FBTztZQUFFVixPQUFPc0I7WUFBY1o7WUFBUXpGO1FBQUk7SUFDOUM7SUFDQTBHLGlCQUFpQmpILFFBQVEsRUFBRTtRQUN2QixJQUFJQSxVQUFVO1lBQ1YsSUFBSSxDQUFDa0gscUJBQXFCLEdBQUc5RyxJQUFJLENBQUNDLENBQUFBLElBQUtMLFNBQVMsTUFBTUssRUFBRThHLE9BQU8sRUFBRTlHLEVBQUVFLEdBQUcsR0FBR1A7UUFDN0UsT0FDSztZQUNELE9BQU8sSUFBSSxDQUFDa0gscUJBQXFCO1FBQ3JDO0lBQ0o7SUFDQSxNQUFNQSx3QkFBd0I7UUFDMUIsSUFBSTNHO1FBQ0osTUFBTUcsTUFBTSxJQUFJLENBQUNoRCxTQUFTLENBQUNPLHFCQUFxQixDQUFDZSxRQUFRO1FBQ3pELElBQUk7WUFDQXVCLE1BQU0sTUFBTSxJQUFJLENBQUNRLFdBQVcsQ0FBQ0MsT0FBTyxDQUFDO2dCQUFFTjtZQUFJO1FBQy9DLEVBQ0EsT0FBT0YsR0FBRztZQUNOLElBQUlBLGFBQWFqQyxPQUFPO2dCQUNwQmlDLEVBQUUyQixPQUFPLEdBQUcsQ0FBQyw4Q0FBOEMsRUFBRTNCLEVBQUUyQixPQUFPLENBQUMsQ0FBQztZQUM1RTtZQUNBLE1BQU0zQjtRQUNWO1FBQ0EsT0FBTztZQUFFMkcsU0FBUzVHLElBQUlXLElBQUk7WUFBRVg7UUFBSTtJQUNwQztJQUNBNkcsMkJBQTJCO1FBQ3ZCLHdFQUF3RTtRQUN4RSxxQkFBcUI7UUFDckIsTUFBTSxJQUFJN0ksTUFBTTtJQUNwQjtJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNELE1BQU04Ryw4QkFBOEJnQyxHQUFHLEVBQUUvQixLQUFLLEVBQUVnQyxnQkFBZ0IsRUFBRXBKLE9BQU8sRUFBRXNILFNBQVMsRUFBRTtRQUNsRixNQUFNcEcsU0FBUyxDQUFDLEdBQUc1QyxTQUFTNkMsWUFBWTtRQUN4QyxJQUFJLENBQUNtRyxXQUFXO1lBQ1pBLFlBQVl4SixhQUFhdUwsZ0NBQWdDO1FBQzdEO1FBQ0EsTUFBTUMsV0FBV0gsSUFBSXhILEtBQUssQ0FBQztRQUMzQixJQUFJMkgsU0FBU2QsTUFBTSxLQUFLLEdBQUc7WUFDdkIsTUFBTSxJQUFJbkksTUFBTSx3Q0FBd0M4STtRQUM1RDtRQUNBLE1BQU1JLFNBQVNELFFBQVEsQ0FBQyxFQUFFLEdBQUcsTUFBTUEsUUFBUSxDQUFDLEVBQUU7UUFDOUMsSUFBSUUsWUFBWUYsUUFBUSxDQUFDLEVBQUU7UUFDM0IsSUFBSUc7UUFDSixJQUFJQztRQUNKLElBQUk7WUFDQUQsV0FBV3JGLEtBQUt1RixLQUFLLENBQUN6SSxPQUFPMEksc0JBQXNCLENBQUNOLFFBQVEsQ0FBQyxFQUFFO1FBQ25FLEVBQ0EsT0FBTzdELEtBQUs7WUFDUixJQUFJQSxlQUFlcEYsT0FBTztnQkFDdEJvRixJQUFJeEIsT0FBTyxHQUFHLENBQUMsNEJBQTRCLEVBQUVxRixRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRTdELElBQUl4QixPQUFPLENBQUMsQ0FBQztZQUMvRTtZQUNBLE1BQU13QjtRQUNWO1FBQ0EsSUFBSSxDQUFDZ0UsVUFBVTtZQUNYLE1BQU0sSUFBSXBKLE1BQU0saUNBQWlDaUosUUFBUSxDQUFDLEVBQUU7UUFDaEU7UUFDQSxJQUFJO1lBQ0FJLFVBQVV0RixLQUFLdUYsS0FBSyxDQUFDekksT0FBTzBJLHNCQUFzQixDQUFDTixRQUFRLENBQUMsRUFBRTtRQUNsRSxFQUNBLE9BQU83RCxLQUFLO1lBQ1IsSUFBSUEsZUFBZXBGLE9BQU87Z0JBQ3RCb0YsSUFBSXhCLE9BQU8sR0FBRyxDQUFDLDJCQUEyQixFQUFFcUYsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzdEO1lBQ0EsTUFBTTdEO1FBQ1Y7UUFDQSxJQUFJLENBQUNpRSxTQUFTO1lBQ1YsTUFBTSxJQUFJckosTUFBTSxnQ0FBZ0NpSixRQUFRLENBQUMsRUFBRTtRQUMvRDtRQUNBLElBQUksQ0FBQzVMLE9BQU9tTSxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDM0MsT0FBT3FDLFNBQVNaLEdBQUcsR0FBRztZQUM1RCx5RUFBeUU7WUFDekUsTUFBTSxJQUFJeEksTUFBTSxnQ0FBZ0MrRCxLQUFLckQsU0FBUyxDQUFDMEk7UUFDbkU7UUFDQSxNQUFNTyxPQUFPNUMsS0FBSyxDQUFDcUMsU0FBU1osR0FBRyxDQUFDO1FBQ2hDLElBQUlZLFNBQVNRLEdBQUcsS0FBSyxTQUFTO1lBQzFCVCxZQUFZbkwsWUFBWTZMLFNBQVMsQ0FBQ1YsV0FBVyxTQUFTMUksUUFBUSxDQUFDO1FBQ25FO1FBQ0EsTUFBTXFKLFdBQVcsTUFBTWpKLE9BQU9rSixNQUFNLENBQUNKLE1BQU1ULFFBQVFDO1FBQ25ELElBQUksQ0FBQ1csVUFBVTtZQUNYLE1BQU0sSUFBSTlKLE1BQU0sOEJBQThCOEk7UUFDbEQ7UUFDQSxJQUFJLENBQUNPLFFBQVFXLEdBQUcsRUFBRTtZQUNkLE1BQU0sSUFBSWhLLE1BQU0sNkJBQTZCK0QsS0FBS3JELFNBQVMsQ0FBQzJJO1FBQ2hFO1FBQ0EsSUFBSSxDQUFDQSxRQUFRWSxHQUFHLEVBQUU7WUFDZCxNQUFNLElBQUlqSyxNQUFNLGtDQUFrQytELEtBQUtyRCxTQUFTLENBQUMySTtRQUNyRTtRQUNBLE1BQU1XLE1BQU01QixPQUFPaUIsUUFBUVcsR0FBRztRQUM5QixJQUFJRSxNQUFNRixNQUNOLE1BQU0sSUFBSWhLLE1BQU07UUFDcEIsTUFBTWlLLE1BQU03QixPQUFPaUIsUUFBUVksR0FBRztRQUM5QixJQUFJQyxNQUFNRCxNQUNOLE1BQU0sSUFBSWpLLE1BQU07UUFDcEIsTUFBTXlJLE1BQU0sSUFBSTFGLE9BQU9DLE9BQU8sS0FBSztRQUNuQyxJQUFJaUgsT0FBT3hCLE1BQU14QixXQUFXO1lBQ3hCLE1BQU0sSUFBSWpILE1BQU0sd0NBQXdDK0QsS0FBS3JELFNBQVMsQ0FBQzJJO1FBQzNFO1FBQ0EsTUFBTWMsV0FBV0gsTUFBTXZNLGFBQWEyTSxnQkFBZ0I7UUFDcEQsTUFBTUMsU0FBU0osTUFBTXhNLGFBQWEyTSxnQkFBZ0I7UUFDbEQsSUFBSTNCLE1BQU0wQixVQUFVO1lBQ2hCLE1BQU0sSUFBSW5LLE1BQU0sMkJBQ1p5SSxNQUNBLFFBQ0EwQixXQUNBLE9BQ0FwRyxLQUFLckQsU0FBUyxDQUFDMkk7UUFDdkI7UUFDQSxJQUFJWixNQUFNNEIsUUFBUTtZQUNkLE1BQU0sSUFBSXJLLE1BQU0sMEJBQ1p5SSxNQUNBLFFBQ0E0QixTQUNBLE9BQ0F0RyxLQUFLckQsU0FBUyxDQUFDMkk7UUFDdkI7UUFDQSxJQUFJMUosV0FBV0EsUUFBUTJLLE9BQU8sQ0FBQ2pCLFFBQVFrQixHQUFHLElBQUksR0FBRztZQUM3QyxNQUFNLElBQUl2SyxNQUFNLHNDQUNaTCxVQUNBLGdCQUNBMEosUUFBUWtCLEdBQUc7UUFDbkI7UUFDQSw0Q0FBNEM7UUFDNUMsSUFBSSxPQUFPeEIscUJBQXFCLGVBQWVBLHFCQUFxQixNQUFNO1lBQ3RFLE1BQU15QixNQUFNbkIsUUFBUW1CLEdBQUc7WUFDdkIsSUFBSUMsY0FBYztZQUNsQixrRUFBa0U7WUFDbEUsV0FBVztZQUNYLElBQUkxQixpQkFBaUIxSyxXQUFXLEtBQUsrQixPQUFPO2dCQUN4Q3FLLGNBQWMxQixpQkFBaUJ1QixPQUFPLENBQUNFLE9BQU8sQ0FBQztZQUNuRCxPQUNLO2dCQUNEQyxjQUFjRCxRQUFRekI7WUFDMUI7WUFDQSxJQUFJLENBQUMwQixhQUFhO2dCQUNkLE1BQU0sSUFBSXpLLE1BQU07WUFDcEI7UUFDSjtRQUNBLE9BQU8sSUFBSTdCLGNBQWN1TSxXQUFXLENBQUN0QixVQUFVQztJQUNuRDtJQUNBOzs7O0tBSUMsR0FDRCxNQUFNMUUsbUNBQW1DO1FBQ3JDLElBQUksSUFBSSxDQUFDRixjQUFjLEVBQUU7WUFDckIsTUFBTWtHLHNCQUFzQixNQUFNLElBQUksQ0FBQ2xHLGNBQWM7WUFDckQsSUFBSSxDQUFDa0csb0JBQW9CcEcsWUFBWSxFQUFFO2dCQUNuQyxNQUFNLElBQUl2RSxNQUFNO1lBQ3BCO1lBQ0EsT0FBTzJLO1FBQ1g7UUFDQTtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNEbkcsa0JBQWtCO1FBQ2QsTUFBTW9HLGFBQWEsSUFBSSxDQUFDMUcsV0FBVyxDQUFDcEIsV0FBVztRQUMvQyxPQUFPOEgsYUFDREEsY0FBYyxJQUFJN0gsT0FBT0MsT0FBTyxLQUFLLElBQUksQ0FBQzZILDJCQUEyQixHQUNyRTtJQUNWO0FBQ0o7QUFDQXROLG9CQUFvQixHQUFHRTtBQUN2Qjs7Q0FFQyxHQUNEQSxhQUFhcU4scUJBQXFCLEdBQUc7QUFDckM7O0NBRUMsR0FDRHJOLGFBQWEyTSxnQkFBZ0IsR0FBRztBQUNoQzs7Q0FFQyxHQUNEM00sYUFBYXVMLGdDQUFnQyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvdGlmeS10by15b3V0dWJlLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvb2F1dGgyY2xpZW50LmpzPzY4NmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT0F1dGgyQ2xpZW50ID0gZXhwb3J0cy5DZXJ0aWZpY2F0ZUZvcm1hdCA9IGV4cG9ydHMuQ29kZUNoYWxsZW5nZU1ldGhvZCA9IHZvaWQgMDtcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcbmNvbnN0IHF1ZXJ5c3RyaW5nID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpO1xuY29uc3Qgc3RyZWFtID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGZvcm1hdEVjZHNhID0gcmVxdWlyZShcImVjZHNhLXNpZy1mb3JtYXR0ZXJcIik7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vY3J5cHRvXCIpO1xuY29uc3QgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aGNsaWVudFwiKTtcbmNvbnN0IGxvZ2ludGlja2V0XzEgPSByZXF1aXJlKFwiLi9sb2dpbnRpY2tldFwiKTtcbnZhciBDb2RlQ2hhbGxlbmdlTWV0aG9kO1xuKGZ1bmN0aW9uIChDb2RlQ2hhbGxlbmdlTWV0aG9kKSB7XG4gICAgQ29kZUNoYWxsZW5nZU1ldGhvZFtcIlBsYWluXCJdID0gXCJwbGFpblwiO1xuICAgIENvZGVDaGFsbGVuZ2VNZXRob2RbXCJTMjU2XCJdID0gXCJTMjU2XCI7XG59KShDb2RlQ2hhbGxlbmdlTWV0aG9kIHx8IChleHBvcnRzLkNvZGVDaGFsbGVuZ2VNZXRob2QgPSBDb2RlQ2hhbGxlbmdlTWV0aG9kID0ge30pKTtcbnZhciBDZXJ0aWZpY2F0ZUZvcm1hdDtcbihmdW5jdGlvbiAoQ2VydGlmaWNhdGVGb3JtYXQpIHtcbiAgICBDZXJ0aWZpY2F0ZUZvcm1hdFtcIlBFTVwiXSA9IFwiUEVNXCI7XG4gICAgQ2VydGlmaWNhdGVGb3JtYXRbXCJKV0tcIl0gPSBcIkpXS1wiO1xufSkoQ2VydGlmaWNhdGVGb3JtYXQgfHwgKGV4cG9ydHMuQ2VydGlmaWNhdGVGb3JtYXQgPSBDZXJ0aWZpY2F0ZUZvcm1hdCA9IHt9KSk7XG5jbGFzcyBPQXV0aDJDbGllbnQgZXh0ZW5kcyBhdXRoY2xpZW50XzEuQXV0aENsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9uc09yQ2xpZW50SWQsIGNsaWVudFNlY3JldCwgcmVkaXJlY3RVcmkpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IG9wdGlvbnNPckNsaWVudElkICYmIHR5cGVvZiBvcHRpb25zT3JDbGllbnRJZCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gb3B0aW9uc09yQ2xpZW50SWRcbiAgICAgICAgICAgIDogeyBjbGllbnRJZDogb3B0aW9uc09yQ2xpZW50SWQsIGNsaWVudFNlY3JldCwgcmVkaXJlY3RVcmkgfTtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMuY2VydGlmaWNhdGVDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlRXhwaXJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUNhY2hlRm9ybWF0ID0gQ2VydGlmaWNhdGVGb3JtYXQuUEVNO1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlblByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jbGllbnRJZCA9IG9wdHMuY2xpZW50SWQ7XG4gICAgICAgIHRoaXMuX2NsaWVudFNlY3JldCA9IG9wdHMuY2xpZW50U2VjcmV0O1xuICAgICAgICB0aGlzLnJlZGlyZWN0VXJpID0gb3B0cy5yZWRpcmVjdFVyaTtcbiAgICAgICAgdGhpcy5lbmRwb2ludHMgPSB7XG4gICAgICAgICAgICB0b2tlbkluZm9Vcmw6ICdodHRwczovL29hdXRoMi5nb29nbGVhcGlzLmNvbS90b2tlbmluZm8nLFxuICAgICAgICAgICAgb2F1dGgyQXV0aEJhc2VVcmw6ICdodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20vby9vYXV0aDIvdjIvYXV0aCcsXG4gICAgICAgICAgICBvYXV0aDJUb2tlblVybDogJ2h0dHBzOi8vb2F1dGgyLmdvb2dsZWFwaXMuY29tL3Rva2VuJyxcbiAgICAgICAgICAgIG9hdXRoMlJldm9rZVVybDogJ2h0dHBzOi8vb2F1dGgyLmdvb2dsZWFwaXMuY29tL3Jldm9rZScsXG4gICAgICAgICAgICBvYXV0aDJGZWRlcmF0ZWRTaWdub25QZW1DZXJ0c1VybDogJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL29hdXRoMi92MS9jZXJ0cycsXG4gICAgICAgICAgICBvYXV0aDJGZWRlcmF0ZWRTaWdub25Kd2tDZXJ0c1VybDogJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL29hdXRoMi92My9jZXJ0cycsXG4gICAgICAgICAgICBvYXV0aDJJYXBQdWJsaWNLZXlVcmw6ICdodHRwczovL3d3dy5nc3RhdGljLmNvbS9pYXAvdmVyaWZ5L3B1YmxpY19rZXknLFxuICAgICAgICAgICAgLi4ub3B0cy5lbmRwb2ludHMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNzdWVycyA9IG9wdHMuaXNzdWVycyB8fCBbXG4gICAgICAgICAgICAnYWNjb3VudHMuZ29vZ2xlLmNvbScsXG4gICAgICAgICAgICAnaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tJyxcbiAgICAgICAgICAgIHRoaXMudW5pdmVyc2VEb21haW4sXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBVUkwgZm9yIGNvbnNlbnQgcGFnZSBsYW5kaW5nLlxuICAgICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMuXG4gICAgICogQHJldHVybiBVUkwgdG8gY29uc2VudCBwYWdlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlQXV0aFVybChvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKG9wdHMuY29kZV9jaGFsbGVuZ2VfbWV0aG9kICYmICFvcHRzLmNvZGVfY2hhbGxlbmdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIGEgY29kZV9jaGFsbGVuZ2VfbWV0aG9kIGlzIHByb3ZpZGVkLCBjb2RlX2NoYWxsZW5nZSBtdXN0IGJlIGluY2x1ZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMucmVzcG9uc2VfdHlwZSA9IG9wdHMucmVzcG9uc2VfdHlwZSB8fCAnY29kZSc7XG4gICAgICAgIG9wdHMuY2xpZW50X2lkID0gb3B0cy5jbGllbnRfaWQgfHwgdGhpcy5fY2xpZW50SWQ7XG4gICAgICAgIG9wdHMucmVkaXJlY3RfdXJpID0gb3B0cy5yZWRpcmVjdF91cmkgfHwgdGhpcy5yZWRpcmVjdFVyaTtcbiAgICAgICAgLy8gQWxsb3cgc2NvcGVzIHRvIGJlIHBhc3NlZCBlaXRoZXIgYXMgYXJyYXkgb3IgYSBzdHJpbmdcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5zY29wZSkpIHtcbiAgICAgICAgICAgIG9wdHMuc2NvcGUgPSBvcHRzLnNjb3BlLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb290VXJsID0gdGhpcy5lbmRwb2ludHMub2F1dGgyQXV0aEJhc2VVcmwudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIChyb290VXJsICtcbiAgICAgICAgICAgICc/JyArXG4gICAgICAgICAgICBxdWVyeXN0cmluZy5zdHJpbmdpZnkob3B0cykpO1xuICAgIH1cbiAgICBnZW5lcmF0ZUNvZGVWZXJpZmllcigpIHtcbiAgICAgICAgLy8gVG8gbWFrZSB0aGUgY29kZSBjb21wYXRpYmxlIHdpdGggYnJvd3NlciBTdWJ0bGVDcnlwdG8gd2UgbmVlZCB0byBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRlQ29kZVZlcmlmaWVyIGlzIHJlbW92ZWQsIHBsZWFzZSB1c2UgZ2VuZXJhdGVDb2RlVmVyaWZpZXJBc3luYyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIGNvZGVfdmVyaWZpZXIsIGFuZCBpdHNcbiAgICAgKiByZXN1bHRpbmcgU0hBMjU2LiBJZiB1c2VkLCB0aGlzIG11c3QgYmUgcGFpcmVkIHdpdGggYSBTMjU2XG4gICAgICogY29kZV9jaGFsbGVuZ2VfbWV0aG9kLlxuICAgICAqXG4gICAgICogRm9yIGEgZnVsbCBleGFtcGxlIHNlZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlYXBpcy9nb29nbGUtYXV0aC1saWJyYXJ5LW5vZGVqcy9ibG9iL21haW4vc2FtcGxlcy9vYXV0aDItY29kZVZlcmlmaWVyLmpzXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVDb2RlVmVyaWZpZXJBc3luYygpIHtcbiAgICAgICAgLy8gYmFzZTY0IGVuY29kaW5nIHVzZXMgNiBiaXRzIHBlciBjaGFyYWN0ZXIsIGFuZCB3ZSB3YW50IHRvIGdlbmVyYXRlMTI4XG4gICAgICAgIC8vIGNoYXJhY3RlcnMuIDYqMTI4LzggPSA5Ni5cbiAgICAgICAgY29uc3QgY3J5cHRvID0gKDAsIGNyeXB0b18xLmNyZWF0ZUNyeXB0bykoKTtcbiAgICAgICAgY29uc3QgcmFuZG9tU3RyaW5nID0gY3J5cHRvLnJhbmRvbUJ5dGVzQmFzZTY0KDk2KTtcbiAgICAgICAgLy8gVGhlIHZhbGlkIGNoYXJhY3RlcnMgaW4gdGhlIGNvZGVfdmVyaWZpZXIgYXJlIFtBLVpdL1thLXpdL1swLTldL1xuICAgICAgICAvLyBcIi1cIi9cIi5cIi9cIl9cIi9cIn5cIi4gQmFzZTY0IGVuY29kZWQgc3RyaW5ncyBhcmUgcHJldHR5IGNsb3NlLCBzbyB3ZSdyZSBqdXN0XG4gICAgICAgIC8vIHN3YXBwaW5nIG91dCBhIGZldyBjaGFycy5cbiAgICAgICAgY29uc3QgY29kZVZlcmlmaWVyID0gcmFuZG9tU3RyaW5nXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwrL2csICd+JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC89L2csICdfJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJy0nKTtcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGJhc2U2NCBlbmNvZGVkIFNIQTI1NlxuICAgICAgICBjb25zdCB1bmVuY29kZWRDb2RlQ2hhbGxlbmdlID0gYXdhaXQgY3J5cHRvLnNoYTI1NkRpZ2VzdEJhc2U2NChjb2RlVmVyaWZpZXIpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVzZSBiYXNlNjRVcmxFbmNvZGluZyBpbnN0ZWFkIG9mIHN0YW5kYXJkIGJhc2U2NFxuICAgICAgICBjb25zdCBjb2RlQ2hhbGxlbmdlID0gdW5lbmNvZGVkQ29kZUNoYWxsZW5nZVxuICAgICAgICAgICAgLnNwbGl0KCc9JylbMF1cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xuICAgICAgICByZXR1cm4geyBjb2RlVmVyaWZpZXIsIGNvZGVDaGFsbGVuZ2UgfTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oY29kZU9yT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBjb2RlT3JPcHRpb25zID09PSAnc3RyaW5nJyA/IHsgY29kZTogY29kZU9yT3B0aW9ucyB9IDogY29kZU9yT3B0aW9ucztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldFRva2VuQXN5bmMob3B0aW9ucykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIudG9rZW5zLCByLnJlcyksIGUgPT4gY2FsbGJhY2soZSwgbnVsbCwgZS5yZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Bc3luYyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUb2tlbkFzeW5jKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5lbmRwb2ludHMub2F1dGgyVG9rZW5VcmwudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgICAgICAgY29kZTogb3B0aW9ucy5jb2RlLFxuICAgICAgICAgICAgY2xpZW50X2lkOiBvcHRpb25zLmNsaWVudF9pZCB8fCB0aGlzLl9jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuX2NsaWVudFNlY3JldCxcbiAgICAgICAgICAgIHJlZGlyZWN0X3VyaTogb3B0aW9ucy5yZWRpcmVjdF91cmkgfHwgdGhpcy5yZWRpcmVjdFVyaSxcbiAgICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICAgICAgY29kZV92ZXJpZmllcjogb3B0aW9ucy5jb2RlVmVyaWZpZXIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGRhdGE6IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh2YWx1ZXMpLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHJlcy5kYXRhO1xuICAgICAgICBpZiAocmVzLmRhdGEgJiYgcmVzLmRhdGEuZXhwaXJlc19pbikge1xuICAgICAgICAgICAgdG9rZW5zLmV4cGlyeV9kYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyByZXMuZGF0YS5leHBpcmVzX2luICogMTAwMDtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbnMuZXhwaXJlc19pbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB7IHRva2VucywgcmVzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoX3Rva2VuIEV4aXN0aW5nIHJlZnJlc2ggdG9rZW4uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoVG9rZW5Ob0NhY2hlKHJlZnJlc2hUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSByZXF1ZXN0IHRvIHJlZnJlc2ggdXNpbmcgdGhlIHNhbWUgdG9rZW4gaGFzIHN0YXJ0ZWQsXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2FtZSBwcm9taXNlLlxuICAgICAgICBpZiAodGhpcy5yZWZyZXNoVG9rZW5Qcm9taXNlcy5oYXMocmVmcmVzaFRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaFRva2VuUHJvbWlzZXMuZ2V0KHJlZnJlc2hUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcCA9IHRoaXMucmVmcmVzaFRva2VuTm9DYWNoZShyZWZyZXNoVG9rZW4pLnRoZW4ociA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUb2tlblByb21pc2VzLmRlbGV0ZShyZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0sIGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW5Qcm9taXNlcy5kZWxldGUocmVmcmVzaFRva2VuKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlblByb21pc2VzLnNldChyZWZyZXNoVG9rZW4sIHApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaFRva2VuTm9DYWNoZShyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZWZyZXNoIHRva2VuIGlzIHNldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmVuZHBvaW50cy5vYXV0aDJUb2tlblVybC50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLl9jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuX2NsaWVudFNlY3JldCxcbiAgICAgICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgZm9yIG5ldyB0b2tlblxuICAgICAgICAgICAgcmVzID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgZGF0YTogcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBnYXhpb3NfMS5HYXhpb3NFcnJvciAmJlxuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9PT0gJ2ludmFsaWRfZ3JhbnQnICYmXG4gICAgICAgICAgICAgICAgKChfYSA9IGUucmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSAmJlxuICAgICAgICAgICAgICAgIC9SZUF1dGgvaS50ZXN0KGUucmVzcG9uc2UuZGF0YS5lcnJvcl9kZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShlLnJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbnMgPSByZXMuZGF0YTtcbiAgICAgICAgLy8gVE9ETzogZGUtZHVwbGljYXRlIHRoaXMgY29kZSBmcm9tIGEgZmV3IHNwb3RzXG4gICAgICAgIGlmIChyZXMuZGF0YSAmJiByZXMuZGF0YS5leHBpcmVzX2luKSB7XG4gICAgICAgICAgICB0b2tlbnMuZXhwaXJ5X2RhdGUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHJlcy5kYXRhLmV4cGlyZXNfaW4gKiAxMDAwO1xuICAgICAgICAgICAgZGVsZXRlIHRva2Vucy5leHBpcmVzX2luO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndG9rZW5zJywgdG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHsgdG9rZW5zLCByZXMgfTtcbiAgICB9XG4gICAgcmVmcmVzaEFjY2Vzc1Rva2VuKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByLmNyZWRlbnRpYWxzLCByLnJlcyksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbih0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSByLnRva2VucztcbiAgICAgICAgdG9rZW5zLnJlZnJlc2hfdG9rZW4gPSB0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB0b2tlbnM7XG4gICAgICAgIHJldHVybiB7IGNyZWRlbnRpYWxzOiB0aGlzLmNyZWRlbnRpYWxzLCByZXM6IHIucmVzIH07XG4gICAgfVxuICAgIGdldEFjY2Vzc1Rva2VuKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRBY2Nlc3NUb2tlbkFzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIudG9rZW4sIHIucmVzKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEFjY2Vzc1Rva2VuQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFJlZnJlc2ggPSAhdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4gfHwgdGhpcy5pc1Rva2VuRXhwaXJpbmcoKTtcbiAgICAgICAgaWYgKHNob3VsZFJlZnJlc2gpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVmcmVzaEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcmVzaGVkQWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLnByb2Nlc3NBbmRWYWxpZGF0ZVJlZnJlc2hIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoZWRBY2Nlc3NUb2tlbiA9PT0gbnVsbCB8fCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmcmVzaGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENyZWRlbnRpYWxzKHJlZnJlc2hlZEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRva2VuOiB0aGlzLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbiB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlZnJlc2ggdG9rZW4gb3IgcmVmcmVzaCBoYW5kbGVyIGNhbGxiYWNrIGlzIHNldC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICAgICAgaWYgKCFyLmNyZWRlbnRpYWxzIHx8IChyLmNyZWRlbnRpYWxzICYmICFyLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZWZyZXNoIGFjY2VzcyB0b2tlbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHRva2VuOiByLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbiwgcmVzOiByLnJlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdG9rZW46IHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gYXV0aGVudGljYXRpb24gaW50ZXJmYWNlLiAgSXQgdGFrZXMgYW4gb3B0aW9uYWwgdXJsIHdoaWNoIHdoZW5cbiAgICAgKiBwcmVzZW50IGlzIHRoZSBlbmRwb2ludCBiZWluZyBhY2Nlc3NlZCwgYW5kIHJldHVybnMgYSBQcm9taXNlIHdoaWNoXG4gICAgICogcmVzb2x2ZXMgd2l0aCBhdXRob3JpemF0aW9uIGhlYWRlciBmaWVsZHMuXG4gICAgICpcbiAgICAgKiBJbiBPQXV0aDJDbGllbnQsIHRoZSByZXN1bHQgaGFzIHRoZSBmb3JtOlxuICAgICAqIHsgQXV0aG9yaXphdGlvbjogJ0JlYXJlciA8YWNjZXNzX3Rva2VuX3ZhbHVlPicgfVxuICAgICAqIEBwYXJhbSB1cmwgVGhlIG9wdGlvbmFsIHVybCBiZWluZyBhdXRob3JpemVkXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWVzdEhlYWRlcnModXJsKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSAoYXdhaXQgdGhpcy5nZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyh1cmwpKS5oZWFkZXJzO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVxdWVzdE1ldGFkYXRhQXN5bmMoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHVybCkge1xuICAgICAgICBjb25zdCB0aGlzQ3JlZHMgPSB0aGlzLmNyZWRlbnRpYWxzO1xuICAgICAgICBpZiAoIXRoaXNDcmVkcy5hY2Nlc3NfdG9rZW4gJiZcbiAgICAgICAgICAgICF0aGlzQ3JlZHMucmVmcmVzaF90b2tlbiAmJlxuICAgICAgICAgICAgIXRoaXMuYXBpS2V5ICYmXG4gICAgICAgICAgICAhdGhpcy5yZWZyZXNoSGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MsIHJlZnJlc2ggdG9rZW4sIEFQSSBrZXkgb3IgcmVmcmVzaCBoYW5kbGVyIGNhbGxiYWNrIGlzIHNldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc0NyZWRzLmFjY2Vzc190b2tlbiAmJiAhdGhpcy5pc1Rva2VuRXhwaXJpbmcoKSkge1xuICAgICAgICAgICAgdGhpc0NyZWRzLnRva2VuX3R5cGUgPSB0aGlzQ3JlZHMudG9rZW5fdHlwZSB8fCAnQmVhcmVyJztcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogdGhpc0NyZWRzLnRva2VuX3R5cGUgKyAnICcgKyB0aGlzQ3JlZHMuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcmVmcmVzaEhhbmRsZXIgZXhpc3RzLCBjYWxsIHByb2Nlc3NBbmRWYWxpZGF0ZVJlZnJlc2hIYW5kbGVyKCkuXG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMucHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIoKTtcbiAgICAgICAgICAgIGlmIChyZWZyZXNoZWRBY2Nlc3NUb2tlbiA9PT0gbnVsbCB8fCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmcmVzaGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDcmVkZW50aWFscyhyZWZyZXNoZWRBY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBoZWFkZXJzOiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogeyAnWC1Hb29nLUFwaS1LZXknOiB0aGlzLmFwaUtleSB9IH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHIgPSBudWxsO1xuICAgICAgICBsZXQgdG9rZW5zID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHIgPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbih0aGlzQ3JlZHMucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICB0b2tlbnMgPSByLnRva2VucztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gZXJyO1xuICAgICAgICAgICAgaWYgKGUucmVzcG9uc2UgJiZcbiAgICAgICAgICAgICAgICAoZS5yZXNwb25zZS5zdGF0dXMgPT09IDQwMyB8fCBlLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSkge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBDb3VsZCBub3QgcmVmcmVzaCBhY2Nlc3MgdG9rZW46ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gdGhpcy5jcmVkZW50aWFscztcbiAgICAgICAgY3JlZGVudGlhbHMudG9rZW5fdHlwZSA9IGNyZWRlbnRpYWxzLnRva2VuX3R5cGUgfHwgJ0JlYXJlcic7XG4gICAgICAgIHRva2Vucy5yZWZyZXNoX3Rva2VuID0gY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbjtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHRva2VucztcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGNyZWRlbnRpYWxzLnRva2VuX3R5cGUgKyAnICcgKyB0b2tlbnMuYWNjZXNzX3Rva2VuLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBoZWFkZXJzOiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKSwgcmVzOiByLnJlcyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gVVJMIHRvIHJldm9rZSB0aGUgZ2l2ZW4gdG9rZW4uXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBleGlzdGluZyB0b2tlbiB0byBiZSByZXZva2VkLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGluc3RhbmNlIG1ldGhvZCB7QGxpbmsgT0F1dGgyQ2xpZW50LmdldFJldm9rZVRva2VuVVJMfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSZXZva2VUb2tlblVybCh0b2tlbikge1xuICAgICAgICByZXR1cm4gbmV3IE9BdXRoMkNsaWVudCgpLmdldFJldm9rZVRva2VuVVJMKHRva2VuKS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBVUkwgdG8gcmV2b2tlIHRoZSBnaXZlbiB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiBUaGUgZXhpc3RpbmcgdG9rZW4gdG8gYmUgcmV2b2tlZC5cbiAgICAgKi9cbiAgICBnZXRSZXZva2VUb2tlblVSTCh0b2tlbikge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHRoaXMuZW5kcG9pbnRzLm9hdXRoMlJldm9rZVVybCk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCd0b2tlbicsIHRva2VuKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgcmV2b2tlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICB1cmw6IHRoaXMuZ2V0UmV2b2tlVG9rZW5VUkwodG9rZW4pLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydGVyXG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qob3B0cylcbiAgICAgICAgICAgICAgICAudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldm9rZUNyZWRlbnRpYWxzKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZXZva2VDcmVkZW50aWFsc0FzeW5jKCkudGhlbihyZXMgPT4gY2FsbGJhY2sobnVsbCwgcmVzKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2b2tlQ3JlZGVudGlhbHNBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJldm9rZUNyZWRlbnRpYWxzQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW47XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB7fTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZva2VUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiB0byByZXZva2UuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIGUucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdEFzeW5jKG9wdHMsIHJldHJ5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHIyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdE1ldGFkYXRhQXN5bmMob3B0cy51cmwpO1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHIuaGVhZGVycyAmJiByLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddID0gci5oZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoci5oZWFkZXJzICYmIHIuaGVhZGVycy5BdXRob3JpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSByLmhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1snWC1Hb29nLUFwaS1LZXknXSA9IHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcjIgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGUucmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgLy8gUmV0cnkgdGhlIHJlcXVlc3QgZm9yIG1ldGFkYXRhIGlmIHRoZSBmb2xsb3dpbmcgY3JpdGVyaWEgYXJlIHRydWU6XG4gICAgICAgICAgICAgICAgLy8gLSBXZSBoYXZlbid0IGFscmVhZHkgcmV0cmllZC4gIEl0IG9ubHkgbWFrZXMgc2Vuc2UgdG8gcmV0cnkgb25jZS5cbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXNwb25zZSB3YXMgYSA0MDEgb3IgYSA0MDNcbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXF1ZXN0IGRpZG4ndCBzZW5kIGEgcmVhZGFibGVTdHJlYW1cbiAgICAgICAgICAgICAgICAvLyAtIEFuIGFjY2Vzc190b2tlbiBhbmQgcmVmcmVzaF90b2tlbiB3ZXJlIGF2YWlsYWJsZSwgYnV0IGVpdGhlciBub1xuICAgICAgICAgICAgICAgIC8vICAgZXhwaXJ5X2RhdGUgd2FzIGF2YWlsYWJsZSBvciB0aGUgZm9yY2VSZWZyZXNoT25GYWlsdXJlIGZsYWcgaXMgc2V0LlxuICAgICAgICAgICAgICAgIC8vICAgVGhlIGFic2VudCBleHBpcnlfZGF0ZSBjYXNlIGNhbiBoYXBwZW4gd2hlbiBkZXZlbG9wZXJzIHN0YXNoIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgYWNjZXNzX3Rva2VuIGFuZCByZWZyZXNoX3Rva2VuIGZvciBsYXRlciB1c2UsIGJ1dCB0aGUgYWNjZXNzX3Rva2VuXG4gICAgICAgICAgICAgICAgLy8gICBmYWlscyBvbiB0aGUgZmlyc3QgdHJ5IGJlY2F1c2UgaXQncyBleHBpcmVkLiBTb21lIGRldmVsb3BlcnMgbWF5XG4gICAgICAgICAgICAgICAgLy8gICBjaG9vc2UgdG8gZW5hYmxlIGZvcmNlUmVmcmVzaE9uRmFpbHVyZSB0byBtaXRpZ2F0ZSB0aW1lLXJlbGF0ZWRcbiAgICAgICAgICAgICAgICAvLyAgIGVycm9ycy5cbiAgICAgICAgICAgICAgICAvLyBPciB0aGUgZm9sbG93aW5nIGNyaXRlcmlhIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgIC8vIC0gV2UgaGF2ZW4ndCBhbHJlYWR5IHJldHJpZWQuICBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVzcG9uc2Ugd2FzIGEgNDAxIG9yIGEgNDAzXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVxdWVzdCBkaWRuJ3Qgc2VuZCBhIHJlYWRhYmxlU3RyZWFtXG4gICAgICAgICAgICAgICAgLy8gLSBObyByZWZyZXNoX3Rva2VuIHdhcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAvLyAtIEFuIGFjY2Vzc190b2tlbiBhbmQgYSByZWZyZXNoSGFuZGxlciBjYWxsYmFjayB3ZXJlIGF2YWlsYWJsZSwgYnV0XG4gICAgICAgICAgICAgICAgLy8gICBlaXRoZXIgbm8gZXhwaXJ5X2RhdGUgd2FzIGF2YWlsYWJsZSBvciB0aGUgZm9yY2VSZWZyZXNoT25GYWlsdXJlXG4gICAgICAgICAgICAgICAgLy8gICBmbGFnIGlzIHNldC4gVGhlIGFjY2Vzc190b2tlbiBmYWlscyBvbiB0aGUgZmlyc3QgdHJ5IGJlY2F1c2UgaXQnc1xuICAgICAgICAgICAgICAgIC8vICAgZXhwaXJlZC4gU29tZSBkZXZlbG9wZXJzIG1heSBjaG9vc2UgdG8gZW5hYmxlIGZvcmNlUmVmcmVzaE9uRmFpbHVyZVxuICAgICAgICAgICAgICAgIC8vICAgdG8gbWl0aWdhdGUgdGltZS1yZWxhdGVkIGVycm9ycy5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXlSZXF1aXJlUmVmcmVzaCA9IHRoaXMuY3JlZGVudGlhbHMgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy5jcmVkZW50aWFscy5leHBpcnlfZGF0ZSB8fCB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF5UmVxdWlyZVJlZnJlc2hXaXRoTm9SZWZyZXNoVG9rZW4gPSB0aGlzLmNyZWRlbnRpYWxzICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLmNyZWRlbnRpYWxzLmV4cGlyeV9kYXRlIHx8IHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hIYW5kbGVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSByZXMuY29uZmlnLmRhdGEgaW5zdGFuY2VvZiBzdHJlYW0uUmVhZGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdXRoRXJyID0gc3RhdHVzQ29kZSA9PT0gNDAxIHx8IHN0YXR1c0NvZGUgPT09IDQwMztcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5ICYmIGlzQXV0aEVyciAmJiAhaXNSZWFkYWJsZVN0cmVhbSAmJiBtYXlSZXF1aXJlUmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXJldHJ5ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0aEVyciAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNSZWFkYWJsZVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgICAgICBtYXlSZXF1aXJlUmVmcmVzaFdpdGhOb1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMucHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSBudWxsIHx8IHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWZyZXNoZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3JlZGVudGlhbHMocmVmcmVzaGVkQWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByMjtcbiAgICB9XG4gICAgdmVyaWZ5SWRUb2tlbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZWQgdG8gYWNjZXB0IHR3byBhcmd1bWVudHMgaW5zdGVhZCBvZiBhbiBvcHRpb25zIG9iamVjdC5cbiAgICAgICAgLy8gQ2hlY2sgdGhlIHR5cGVzIHRvIGhlbHAgdXNlcnMgdXBncmFkZSB3aXRoIGxlc3MgcGFpbi5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBjYW4gYmUgcmVtb3ZlZCBhZnRlciBhIDIuMCByZWxlYXNlLlxuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9ucyBvYmplY3QgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciwgd2hpY2ggaW5jbHVkZXMgdGhlIGlkVG9rZW4sIGF1ZGllbmNlLCBhbmQgbWF4RXhwaXJ5LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy52ZXJpZnlJZFRva2VuQXN5bmMob3B0aW9ucykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlJZFRva2VuQXN5bmMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5SWRUb2tlbkFzeW5jKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmlkVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZlcmlmeUlkVG9rZW4gbWV0aG9kIHJlcXVpcmVzIGFuIElEIFRva2VuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldEZlZGVyYXRlZFNpZ25vbkNlcnRzQXN5bmMoKTtcbiAgICAgICAgY29uc3QgbG9naW4gPSBhd2FpdCB0aGlzLnZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0c0FzeW5jKG9wdGlvbnMuaWRUb2tlbiwgcmVzcG9uc2UuY2VydHMsIG9wdGlvbnMuYXVkaWVuY2UsIHRoaXMuaXNzdWVycywgb3B0aW9ucy5tYXhFeHBpcnkpO1xuICAgICAgICByZXR1cm4gbG9naW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHByb3Zpc2lvbmVkIGFjY2VzcyB0b2tlbi4gIEVzcGVjaWFsbHkgdXNlZnVsXG4gICAgICogaWYgeW91IHdhbnQgdG8gY2hlY2sgdGhlIHNjb3BlcyB0aGF0IHdlcmUgcHJvdmlzaW9uZWQgdG8gYSBnaXZlbiB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiBSZXF1aXJlZC4gIFRoZSBBY2Nlc3MgVG9rZW4gZm9yIHdoaWNoIHlvdSB3YW50IHRvIGdldFxuICAgICAqIHVzZXIgaW5mby5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUb2tlbkluZm8oYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVybDogdGhpcy5lbmRwb2ludHMudG9rZW5JbmZvVXJsLnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbmZvID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBleHBpcnlfZGF0ZTogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBkYXRhLmV4cGlyZXNfaW4gKiAxMDAwLFxuICAgICAgICAgICAgc2NvcGVzOiBkYXRhLnNjb3BlLnNwbGl0KCcgJyksXG4gICAgICAgIH0sIGRhdGEpO1xuICAgICAgICBkZWxldGUgaW5mby5leHBpcmVzX2luO1xuICAgICAgICBkZWxldGUgaW5mby5zY29wZTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICAgIGdldEZlZGVyYXRlZFNpZ25vbkNlcnRzKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRGZWRlcmF0ZWRTaWdub25DZXJ0c0FzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIuY2VydHMsIHIucmVzKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmVkZXJhdGVkU2lnbm9uQ2VydHNBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEZlZGVyYXRlZFNpZ25vbkNlcnRzQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IG5vd1RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gKDAsIGNyeXB0b18xLmhhc0Jyb3dzZXJDcnlwdG8pKClcbiAgICAgICAgICAgID8gQ2VydGlmaWNhdGVGb3JtYXQuSldLXG4gICAgICAgICAgICA6IENlcnRpZmljYXRlRm9ybWF0LlBFTTtcbiAgICAgICAgaWYgKHRoaXMuY2VydGlmaWNhdGVFeHBpcnkgJiZcbiAgICAgICAgICAgIG5vd1RpbWUgPCB0aGlzLmNlcnRpZmljYXRlRXhwaXJ5LmdldFRpbWUoKSAmJlxuICAgICAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUNhY2hlRm9ybWF0ID09PSBmb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNlcnRzOiB0aGlzLmNlcnRpZmljYXRlQ2FjaGUsIGZvcm1hdCB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGxldCB1cmw7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIENlcnRpZmljYXRlRm9ybWF0LlBFTTpcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmVuZHBvaW50cy5vYXV0aDJGZWRlcmF0ZWRTaWdub25QZW1DZXJ0c1VybC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDZXJ0aWZpY2F0ZUZvcm1hdC5KV0s6XG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5lbmRwb2ludHMub2F1dGgyRmVkZXJhdGVkU2lnbm9uSndrQ2VydHNVcmwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjZXJ0aWZpY2F0ZSBmb3JtYXQgJHtmb3JtYXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7IHVybCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBGYWlsZWQgdG8gcmV0cmlldmUgdmVyaWZpY2F0aW9uIGNlcnRpZmljYXRlczogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVDb250cm9sID0gcmVzID8gcmVzLmhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNhY2hlQWdlID0gLTE7XG4gICAgICAgIGlmIChjYWNoZUNvbnRyb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKCdtYXgtYWdlPShbMC05XSopJyk7XG4gICAgICAgICAgICBjb25zdCByZWdleFJlc3VsdCA9IHBhdHRlcm4uZXhlYyhjYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgaWYgKHJlZ2V4UmVzdWx0ICYmIHJlZ2V4UmVzdWx0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIENhY2hlIHJlc3VsdHMgd2l0aCBtYXgtYWdlIChpbiBzZWNvbmRzKVxuICAgICAgICAgICAgICAgIGNhY2hlQWdlID0gTnVtYmVyKHJlZ2V4UmVzdWx0WzFdKSAqIDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjZXJ0aWZpY2F0ZXMgPSB7fTtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgQ2VydGlmaWNhdGVGb3JtYXQuUEVNOlxuICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlcyA9IHJlcy5kYXRhO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDZXJ0aWZpY2F0ZUZvcm1hdC5KV0s6XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmVzLmRhdGEua2V5cykge1xuICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZXNba2V5LmtpZF0gPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNlcnRpZmljYXRlIGZvcm1hdCAke2Zvcm1hdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlRXhwaXJ5ID1cbiAgICAgICAgICAgIGNhY2hlQWdlID09PSAtMSA/IG51bGwgOiBuZXcgRGF0ZShub3cuZ2V0VGltZSgpICsgY2FjaGVBZ2UpO1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlQ2FjaGUgPSBjZXJ0aWZpY2F0ZXM7XG4gICAgICAgIHRoaXMuY2VydGlmaWNhdGVDYWNoZUZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHsgY2VydHM6IGNlcnRpZmljYXRlcywgZm9ybWF0LCByZXMgfTtcbiAgICB9XG4gICAgZ2V0SWFwUHVibGljS2V5cyhjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0SWFwUHVibGljS2V5c0FzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIucHVia2V5cywgci5yZXMpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJYXBQdWJsaWNLZXlzQXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRJYXBQdWJsaWNLZXlzQXN5bmMoKSB7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuZW5kcG9pbnRzLm9hdXRoMklhcFB1YmxpY0tleVVybC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHsgdXJsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYEZhaWxlZCB0byByZXRyaWV2ZSB2ZXJpZmljYXRpb24gY2VydGlmaWNhdGVzOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwdWJrZXlzOiByZXMuZGF0YSwgcmVzIH07XG4gICAgfVxuICAgIHZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0cygpIHtcbiAgICAgICAgLy8gVG8gbWFrZSB0aGUgY29kZSBjb21wYXRpYmxlIHdpdGggYnJvd3NlciBTdWJ0bGVDcnlwdG8gd2UgbmVlZCB0byBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0cyBpcyByZW1vdmVkLCBwbGVhc2UgdXNlIHZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0c0FzeW5jIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSB0aGUgaWQgdG9rZW4gaXMgc2lnbmVkIHdpdGggdGhlIGNvcnJlY3QgY2VydGlmaWNhdGVcbiAgICAgKiBhbmQgaXMgZnJvbSB0aGUgY29ycmVjdCBhdWRpZW5jZS5cbiAgICAgKiBAcGFyYW0gand0IFRoZSBqd3QgdG8gdmVyaWZ5IChUaGUgSUQgVG9rZW4gaW4gdGhpcyBjYXNlKS5cbiAgICAgKiBAcGFyYW0gY2VydHMgVGhlIGFycmF5IG9mIGNlcnRzIHRvIHRlc3QgdGhlIGp3dCBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSByZXF1aXJlZEF1ZGllbmNlIFRoZSBhdWRpZW5jZSB0byB0ZXN0IHRoZSBqd3QgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0gaXNzdWVycyBUaGUgYWxsb3dlZCBpc3N1ZXJzIG9mIHRoZSBqd3QgKE9wdGlvbmFsKS5cbiAgICAgKiBAcGFyYW0gbWF4RXhwaXJ5IFRoZSBtYXggZXhwaXJ5IHRoZSBjZXJ0aWZpY2F0ZSBjYW4gYmUgKE9wdGlvbmFsKS5cbiAgICAgKiBAcmV0dXJuIFJldHVybnMgYSBwcm9taXNlIHJlc29sdmluZyB0byBMb2dpblRpY2tldCBvbiB2ZXJpZmljYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgdmVyaWZ5U2lnbmVkSnd0V2l0aENlcnRzQXN5bmMoand0LCBjZXJ0cywgcmVxdWlyZWRBdWRpZW5jZSwgaXNzdWVycywgbWF4RXhwaXJ5KSB7XG4gICAgICAgIGNvbnN0IGNyeXB0byA9ICgwLCBjcnlwdG9fMS5jcmVhdGVDcnlwdG8pKCk7XG4gICAgICAgIGlmICghbWF4RXhwaXJ5KSB7XG4gICAgICAgICAgICBtYXhFeHBpcnkgPSBPQXV0aDJDbGllbnQuREVGQVVMVF9NQVhfVE9LRU5fTElGRVRJTUVfU0VDU187XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBqd3Quc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBudW1iZXIgb2Ygc2VnbWVudHMgaW4gdG9rZW46ICcgKyBqd3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25lZCA9IHNlZ21lbnRzWzBdICsgJy4nICsgc2VnbWVudHNbMV07XG4gICAgICAgIGxldCBzaWduYXR1cmUgPSBzZWdtZW50c1syXTtcbiAgICAgICAgbGV0IGVudmVsb3BlO1xuICAgICAgICBsZXQgcGF5bG9hZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVudmVsb3BlID0gSlNPTi5wYXJzZShjcnlwdG8uZGVjb2RlQmFzZTY0U3RyaW5nVXRmOChzZWdtZW50c1swXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYENhbid0IHBhcnNlIHRva2VuIGVudmVsb3BlOiAke3NlZ21lbnRzWzBdfSc6ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVudmVsb3BlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwYXJzZSB0b2tlbiBlbnZlbG9wZTogXCIgKyBzZWdtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNyeXB0by5kZWNvZGVCYXNlNjRTdHJpbmdVdGY4KHNlZ21lbnRzWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgQ2FuJ3QgcGFyc2UgdG9rZW4gcGF5bG9hZCAnJHtzZWdtZW50c1swXX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF5bG9hZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGFyc2UgdG9rZW4gcGF5bG9hZDogXCIgKyBzZWdtZW50c1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2VydHMsIGVudmVsb3BlLmtpZCkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgbm90IHByZXNlbnQsIHRoZW4gdGhlcmUncyBubyByZWFzb24gdG8gYXR0ZW1wdCB2ZXJpZmljYXRpb25cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcGVtIGZvdW5kIGZvciBlbnZlbG9wZTogJyArIEpTT04uc3RyaW5naWZ5KGVudmVsb3BlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VydCA9IGNlcnRzW2VudmVsb3BlLmtpZF07XG4gICAgICAgIGlmIChlbnZlbG9wZS5hbGcgPT09ICdFUzI1NicpIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IGZvcm1hdEVjZHNhLmpvc2VUb0RlcihzaWduYXR1cmUsICdFUzI1NicpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGNyeXB0by52ZXJpZnkoY2VydCwgc2lnbmVkLCBzaWduYXR1cmUpO1xuICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW4gc2lnbmF0dXJlOiAnICsgand0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBheWxvYWQuaWF0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlzc3VlIHRpbWUgaW4gdG9rZW46ICcgKyBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXlsb2FkLmV4cCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBleHBpcmF0aW9uIHRpbWUgaW4gdG9rZW46ICcgKyBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWF0ID0gTnVtYmVyKHBheWxvYWQuaWF0KTtcbiAgICAgICAgaWYgKGlzTmFOKGlhdCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lhdCBmaWVsZCB1c2luZyBpbnZhbGlkIGZvcm1hdCcpO1xuICAgICAgICBjb25zdCBleHAgPSBOdW1iZXIocGF5bG9hZC5leHApO1xuICAgICAgICBpZiAoaXNOYU4oZXhwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwIGZpZWxkIHVzaW5nIGludmFsaWQgZm9ybWF0Jyk7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICAgICAgaWYgKGV4cCA+PSBub3cgKyBtYXhFeHBpcnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwaXJhdGlvbiB0aW1lIHRvbyBmYXIgaW4gZnV0dXJlOiAnICsgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVhcmxpZXN0ID0gaWF0IC0gT0F1dGgyQ2xpZW50LkNMT0NLX1NLRVdfU0VDU187XG4gICAgICAgIGNvbnN0IGxhdGVzdCA9IGV4cCArIE9BdXRoMkNsaWVudC5DTE9DS19TS0VXX1NFQ1NfO1xuICAgICAgICBpZiAobm93IDwgZWFybGllc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gdXNlZCB0b28gZWFybHksICcgK1xuICAgICAgICAgICAgICAgIG5vdyArXG4gICAgICAgICAgICAgICAgJyA8ICcgK1xuICAgICAgICAgICAgICAgIGVhcmxpZXN0ICtcbiAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdyA+IGxhdGVzdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiB1c2VkIHRvbyBsYXRlLCAnICtcbiAgICAgICAgICAgICAgICBub3cgK1xuICAgICAgICAgICAgICAgICcgPiAnICtcbiAgICAgICAgICAgICAgICBsYXRlc3QgK1xuICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNzdWVycyAmJiBpc3N1ZXJzLmluZGV4T2YocGF5bG9hZC5pc3MpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlzc3VlciwgZXhwZWN0ZWQgb25lIG9mIFsnICtcbiAgICAgICAgICAgICAgICBpc3N1ZXJzICtcbiAgICAgICAgICAgICAgICAnXSwgYnV0IGdvdCAnICtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhlIGF1ZGllbmNlIG1hdGNoZXMgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZEF1ZGllbmNlICE9PSAndW5kZWZpbmVkJyAmJiByZXF1aXJlZEF1ZGllbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBhdWQgPSBwYXlsb2FkLmF1ZDtcbiAgICAgICAgICAgIGxldCBhdWRWZXJpZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVpcmVkQXVkaWVuY2UgaXMgYW4gYXJyYXksIGNoZWNrIGlmIGl0IGNvbnRhaW5zIHRva2VuXG4gICAgICAgICAgICAvLyBhdWRpZW5jZVxuICAgICAgICAgICAgaWYgKHJlcXVpcmVkQXVkaWVuY2UuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXVkVmVyaWZpZWQgPSByZXF1aXJlZEF1ZGllbmNlLmluZGV4T2YoYXVkKSA+IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXVkVmVyaWZpZWQgPSBhdWQgPT09IHJlcXVpcmVkQXVkaWVuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWF1ZFZlcmlmaWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyByZWNpcGllbnQsIHBheWxvYWQgYXVkaWVuY2UgIT0gcmVxdWlyZWRBdWRpZW5jZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgbG9naW50aWNrZXRfMS5Mb2dpblRpY2tldChlbnZlbG9wZSwgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBBY2Nlc3NUb2tlblJlc3BvbnNlIHR5cGUgaWZcbiAgICAgKiByZWZyZXNoSGFuZGxlciBpcyBkZWZpbmVkLlxuICAgICAqIElmIG5vdCwgbm90aGluZyBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9jZXNzQW5kVmFsaWRhdGVSZWZyZXNoSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaEhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlZnJlc2hIYW5kbGVyKCk7XG4gICAgICAgICAgICBpZiAoIWFjY2Vzc1Rva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIHJlZnJlc2hIYW5kbGVyIGNhbGxiYWNrLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2VuUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSB0b2tlbiBpcyBleHBpcmVkIG9yIHdpbGwgZXhwaXJlIHdpdGhpblxuICAgICAqIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpc21pbGxpc2Vjb25kcy5cbiAgICAgKiBJZiB0aGVyZSBpcyBubyBleHBpcnkgdGltZSwgYXNzdW1lcyB0aGUgdG9rZW4gaXMgbm90IGV4cGlyZWQgb3IgZXhwaXJpbmcuXG4gICAgICovXG4gICAgaXNUb2tlbkV4cGlyaW5nKCkge1xuICAgICAgICBjb25zdCBleHBpcnlEYXRlID0gdGhpcy5jcmVkZW50aWFscy5leHBpcnlfZGF0ZTtcbiAgICAgICAgcmV0dXJuIGV4cGlyeURhdGVcbiAgICAgICAgICAgID8gZXhwaXJ5RGF0ZSA8PSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuT0F1dGgyQ2xpZW50ID0gT0F1dGgyQ2xpZW50O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgaW5zdGFuY2UncyB7QGxpbmsgT0F1dGgyQ2xpZW50LmVuZHBvaW50c31cbiAqL1xuT0F1dGgyQ2xpZW50LkdPT0dMRV9UT0tFTl9JTkZPX1VSTCA9ICdodHRwczovL29hdXRoMi5nb29nbGVhcGlzLmNvbS90b2tlbmluZm8nO1xuLyoqXG4gKiBDbG9jayBza2V3IC0gZml2ZSBtaW51dGVzIGluIHNlY29uZHNcbiAqL1xuT0F1dGgyQ2xpZW50LkNMT0NLX1NLRVdfU0VDU18gPSAzMDA7XG4vKipcbiAqIFRoZSBkZWZhdWx0IG1heCBUb2tlbiBMaWZldGltZSBpcyBvbmUgZGF5IGluIHNlY29uZHNcbiAqL1xuT0F1dGgyQ2xpZW50LkRFRkFVTFRfTUFYX1RPS0VOX0xJRkVUSU1FX1NFQ1NfID0gODY0MDA7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJPQXV0aDJDbGllbnQiLCJDZXJ0aWZpY2F0ZUZvcm1hdCIsIkNvZGVDaGFsbGVuZ2VNZXRob2QiLCJnYXhpb3NfMSIsInJlcXVpcmUiLCJxdWVyeXN0cmluZyIsInN0cmVhbSIsImZvcm1hdEVjZHNhIiwiY3J5cHRvXzEiLCJhdXRoY2xpZW50XzEiLCJsb2dpbnRpY2tldF8xIiwiQXV0aENsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9uc09yQ2xpZW50SWQiLCJjbGllbnRTZWNyZXQiLCJyZWRpcmVjdFVyaSIsIm9wdHMiLCJjbGllbnRJZCIsImNlcnRpZmljYXRlQ2FjaGUiLCJjZXJ0aWZpY2F0ZUV4cGlyeSIsImNlcnRpZmljYXRlQ2FjaGVGb3JtYXQiLCJQRU0iLCJyZWZyZXNoVG9rZW5Qcm9taXNlcyIsIk1hcCIsIl9jbGllbnRJZCIsIl9jbGllbnRTZWNyZXQiLCJlbmRwb2ludHMiLCJ0b2tlbkluZm9VcmwiLCJvYXV0aDJBdXRoQmFzZVVybCIsIm9hdXRoMlRva2VuVXJsIiwib2F1dGgyUmV2b2tlVXJsIiwib2F1dGgyRmVkZXJhdGVkU2lnbm9uUGVtQ2VydHNVcmwiLCJvYXV0aDJGZWRlcmF0ZWRTaWdub25Kd2tDZXJ0c1VybCIsIm9hdXRoMklhcFB1YmxpY0tleVVybCIsImlzc3VlcnMiLCJ1bml2ZXJzZURvbWFpbiIsImdlbmVyYXRlQXV0aFVybCIsImNvZGVfY2hhbGxlbmdlX21ldGhvZCIsImNvZGVfY2hhbGxlbmdlIiwiRXJyb3IiLCJyZXNwb25zZV90eXBlIiwiY2xpZW50X2lkIiwicmVkaXJlY3RfdXJpIiwiQXJyYXkiLCJpc0FycmF5Iiwic2NvcGUiLCJqb2luIiwicm9vdFVybCIsInRvU3RyaW5nIiwic3RyaW5naWZ5IiwiZ2VuZXJhdGVDb2RlVmVyaWZpZXIiLCJnZW5lcmF0ZUNvZGVWZXJpZmllckFzeW5jIiwiY3J5cHRvIiwiY3JlYXRlQ3J5cHRvIiwicmFuZG9tU3RyaW5nIiwicmFuZG9tQnl0ZXNCYXNlNjQiLCJjb2RlVmVyaWZpZXIiLCJyZXBsYWNlIiwidW5lbmNvZGVkQ29kZUNoYWxsZW5nZSIsInNoYTI1NkRpZ2VzdEJhc2U2NCIsImNvZGVDaGFsbGVuZ2UiLCJzcGxpdCIsImdldFRva2VuIiwiY29kZU9yT3B0aW9ucyIsImNhbGxiYWNrIiwib3B0aW9ucyIsImNvZGUiLCJnZXRUb2tlbkFzeW5jIiwidGhlbiIsInIiLCJ0b2tlbnMiLCJyZXMiLCJlIiwicmVzcG9uc2UiLCJ1cmwiLCJ2YWx1ZXMiLCJjbGllbnRfc2VjcmV0IiwiZ3JhbnRfdHlwZSIsImNvZGVfdmVyaWZpZXIiLCJ0cmFuc3BvcnRlciIsInJlcXVlc3QiLCJtZXRob2QiLCJkYXRhIiwiaGVhZGVycyIsImV4cGlyZXNfaW4iLCJleHBpcnlfZGF0ZSIsIkRhdGUiLCJnZXRUaW1lIiwiZW1pdCIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hUb2tlbk5vQ2FjaGUiLCJoYXMiLCJnZXQiLCJwIiwiZGVsZXRlIiwic2V0IiwiX2EiLCJyZWZyZXNoX3Rva2VuIiwiR2F4aW9zRXJyb3IiLCJtZXNzYWdlIiwidGVzdCIsImVycm9yX2Rlc2NyaXB0aW9uIiwiSlNPTiIsInJlZnJlc2hBY2Nlc3NUb2tlbiIsInJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jIiwiY3JlZGVudGlhbHMiLCJnZXRBY2Nlc3NUb2tlbiIsImdldEFjY2Vzc1Rva2VuQXN5bmMiLCJ0b2tlbiIsInNob3VsZFJlZnJlc2giLCJhY2Nlc3NfdG9rZW4iLCJpc1Rva2VuRXhwaXJpbmciLCJyZWZyZXNoSGFuZGxlciIsInJlZnJlc2hlZEFjY2Vzc1Rva2VuIiwicHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIiLCJzZXRDcmVkZW50aWFscyIsImdldFJlcXVlc3RIZWFkZXJzIiwiZ2V0UmVxdWVzdE1ldGFkYXRhQXN5bmMiLCJ0aGlzQ3JlZHMiLCJhcGlLZXkiLCJ0b2tlbl90eXBlIiwiQXV0aG9yaXphdGlvbiIsImFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyIsImVyciIsInN0YXR1cyIsImdldFJldm9rZVRva2VuVXJsIiwiZ2V0UmV2b2tlVG9rZW5VUkwiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJyZXZva2VUb2tlbiIsInJldm9rZUNyZWRlbnRpYWxzIiwicmV2b2tlQ3JlZGVudGlhbHNBc3luYyIsInJlcXVlc3RBc3luYyIsInJldHJ5IiwicjIiLCJzdGF0dXNDb2RlIiwibWF5UmVxdWlyZVJlZnJlc2giLCJmb3JjZVJlZnJlc2hPbkZhaWx1cmUiLCJtYXlSZXF1aXJlUmVmcmVzaFdpdGhOb1JlZnJlc2hUb2tlbiIsImlzUmVhZGFibGVTdHJlYW0iLCJjb25maWciLCJSZWFkYWJsZSIsImlzQXV0aEVyciIsInZlcmlmeUlkVG9rZW4iLCJ2ZXJpZnlJZFRva2VuQXN5bmMiLCJpZFRva2VuIiwiZ2V0RmVkZXJhdGVkU2lnbm9uQ2VydHNBc3luYyIsImxvZ2luIiwidmVyaWZ5U2lnbmVkSnd0V2l0aENlcnRzQXN5bmMiLCJjZXJ0cyIsImF1ZGllbmNlIiwibWF4RXhwaXJ5IiwiZ2V0VG9rZW5JbmZvIiwiYWNjZXNzVG9rZW4iLCJpbmZvIiwiYXNzaWduIiwic2NvcGVzIiwiZ2V0RmVkZXJhdGVkU2lnbm9uQ2VydHMiLCJub3dUaW1lIiwiZm9ybWF0IiwiaGFzQnJvd3NlckNyeXB0byIsIkpXSyIsImNhY2hlQ29udHJvbCIsInVuZGVmaW5lZCIsImNhY2hlQWdlIiwicGF0dGVybiIsIlJlZ0V4cCIsInJlZ2V4UmVzdWx0IiwiZXhlYyIsImxlbmd0aCIsIk51bWJlciIsImNlcnRpZmljYXRlcyIsImtleSIsImtleXMiLCJraWQiLCJub3ciLCJnZXRJYXBQdWJsaWNLZXlzIiwiZ2V0SWFwUHVibGljS2V5c0FzeW5jIiwicHVia2V5cyIsInZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0cyIsImp3dCIsInJlcXVpcmVkQXVkaWVuY2UiLCJERUZBVUxUX01BWF9UT0tFTl9MSUZFVElNRV9TRUNTXyIsInNlZ21lbnRzIiwic2lnbmVkIiwic2lnbmF0dXJlIiwiZW52ZWxvcGUiLCJwYXlsb2FkIiwicGFyc2UiLCJkZWNvZGVCYXNlNjRTdHJpbmdVdGY4IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiY2VydCIsImFsZyIsImpvc2VUb0RlciIsInZlcmlmaWVkIiwidmVyaWZ5IiwiaWF0IiwiZXhwIiwiaXNOYU4iLCJlYXJsaWVzdCIsIkNMT0NLX1NLRVdfU0VDU18iLCJsYXRlc3QiLCJpbmRleE9mIiwiaXNzIiwiYXVkIiwiYXVkVmVyaWZpZWQiLCJMb2dpblRpY2tldCIsImFjY2Vzc1Rva2VuUmVzcG9uc2UiLCJleHBpcnlEYXRlIiwiZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIiwiR09PR0xFX1RPS0VOX0lORk9fVVJMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2common.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/oauth2common.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getErrorFromOAuthErrorResponse = exports.OAuthClientAuthHandler = void 0;\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(action-browser)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\n/** List of HTTP methods that accept request bodies. */ const METHODS_SUPPORTING_REQUEST_BODY = [\n    \"PUT\",\n    \"POST\",\n    \"PATCH\"\n];\n/**\n * Abstract class for handling client authentication in OAuth-based\n * operations.\n * When request-body client authentication is used, only application/json and\n * application/x-www-form-urlencoded content types for HTTP methods that support\n * request bodies are supported.\n */ class OAuthClientAuthHandler {\n    /**\n     * Instantiates an OAuth client authentication handler.\n     * @param clientAuthentication The client auth credentials.\n     */ constructor(clientAuthentication){\n        this.clientAuthentication = clientAuthentication;\n        this.crypto = (0, crypto_1.createCrypto)();\n    }\n    /**\n     * Applies client authentication on the OAuth request's headers or POST\n     * body but does not process the request.\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     * @param bearerToken The optional bearer token to use for authentication.\n     *   When this is used, no client authentication credentials are needed.\n     */ applyClientAuthenticationOptions(opts, bearerToken) {\n        // Inject authenticated header.\n        this.injectAuthenticatedHeaders(opts, bearerToken);\n        // Inject authenticated request body.\n        if (!bearerToken) {\n            this.injectAuthenticatedRequestBody(opts);\n        }\n    }\n    /**\n     * Applies client authentication on the request's header if either\n     * basic authentication or bearer token authentication is selected.\n     *\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     * @param bearerToken The optional bearer token to use for authentication.\n     *   When this is used, no client authentication credentials are needed.\n     */ injectAuthenticatedHeaders(opts, bearerToken) {\n        var _a;\n        // Bearer token prioritized higher than basic Auth.\n        if (bearerToken) {\n            opts.headers = opts.headers || {};\n            Object.assign(opts.headers, {\n                Authorization: `Bearer ${bearerToken}}`\n            });\n        } else if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === \"basic\") {\n            opts.headers = opts.headers || {};\n            const clientId = this.clientAuthentication.clientId;\n            const clientSecret = this.clientAuthentication.clientSecret || \"\";\n            const base64EncodedCreds = this.crypto.encodeBase64StringUtf8(`${clientId}:${clientSecret}`);\n            Object.assign(opts.headers, {\n                Authorization: `Basic ${base64EncodedCreds}`\n            });\n        }\n    }\n    /**\n     * Applies client authentication on the request's body if request-body\n     * client authentication is selected.\n     *\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     */ injectAuthenticatedRequestBody(opts) {\n        var _a;\n        if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === \"request-body\") {\n            const method = (opts.method || \"GET\").toUpperCase();\n            // Inject authenticated request body.\n            if (METHODS_SUPPORTING_REQUEST_BODY.indexOf(method) !== -1) {\n                // Get content-type.\n                let contentType;\n                const headers = opts.headers || {};\n                for(const key in headers){\n                    if (key.toLowerCase() === \"content-type\" && headers[key]) {\n                        contentType = headers[key].toLowerCase();\n                        break;\n                    }\n                }\n                if (contentType === \"application/x-www-form-urlencoded\") {\n                    opts.data = opts.data || \"\";\n                    const data = querystring.parse(opts.data);\n                    Object.assign(data, {\n                        client_id: this.clientAuthentication.clientId,\n                        client_secret: this.clientAuthentication.clientSecret || \"\"\n                    });\n                    opts.data = querystring.stringify(data);\n                } else if (contentType === \"application/json\") {\n                    opts.data = opts.data || {};\n                    Object.assign(opts.data, {\n                        client_id: this.clientAuthentication.clientId,\n                        client_secret: this.clientAuthentication.clientSecret || \"\"\n                    });\n                } else {\n                    throw new Error(`${contentType} content-types are not supported with ` + `${this.clientAuthentication.confidentialClientType} ` + \"client authentication\");\n                }\n            } else {\n                throw new Error(`${method} HTTP method does not support ` + `${this.clientAuthentication.confidentialClientType} ` + \"client authentication\");\n            }\n        }\n    }\n}\nexports.OAuthClientAuthHandler = OAuthClientAuthHandler;\n/**\n * Converts an OAuth error response to a native JavaScript Error.\n * @param resp The OAuth error response to convert to a native Error object.\n * @param err The optional original error. If provided, the error properties\n *   will be copied to the new error.\n * @return The converted native Error object.\n */ function getErrorFromOAuthErrorResponse(resp, err) {\n    // Error response.\n    const errorCode = resp.error;\n    const errorDescription = resp.error_description;\n    const errorUri = resp.error_uri;\n    let message = `Error code ${errorCode}`;\n    if (typeof errorDescription !== \"undefined\") {\n        message += `: ${errorDescription}`;\n    }\n    if (typeof errorUri !== \"undefined\") {\n        message += ` - ${errorUri}`;\n    }\n    const newError = new Error(message);\n    // Copy properties from original error to newly generated error.\n    if (err) {\n        const keys = Object.keys(err);\n        if (err.stack) {\n            // Copy error.stack if available.\n            keys.push(\"stack\");\n        }\n        keys.forEach((key)=>{\n            // Do not overwrite the message field.\n            if (key !== \"message\") {\n                Object.defineProperty(newError, key, {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    value: err[key],\n                    writable: false,\n                    enumerable: true\n                });\n            }\n        });\n    }\n    return newError;\n}\nexports.getErrorFromOAuthErrorResponse = getErrorFromOAuthErrorResponse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL29hdXRoMmNvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNDQUFzQyxHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQy9FLE1BQU1JLGNBQWNDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3pDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLHdHQUFrQjtBQUMzQyxxREFBcUQsR0FDckQsTUFBTUUsa0NBQWtDO0lBQUM7SUFBTztJQUFRO0NBQVE7QUFDaEU7Ozs7OztDQU1DLEdBQ0QsTUFBTUo7SUFDRjs7O0tBR0MsR0FDREssWUFBWUMsb0JBQW9CLENBQUU7UUFDOUIsSUFBSSxDQUFDQSxvQkFBb0IsR0FBR0E7UUFDNUIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxHQUFHSixTQUFTSyxZQUFZO0lBQzNDO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNEQyxpQ0FBaUNDLElBQUksRUFBRUMsV0FBVyxFQUFFO1FBQ2hELCtCQUErQjtRQUMvQixJQUFJLENBQUNDLDBCQUEwQixDQUFDRixNQUFNQztRQUN0QyxxQ0FBcUM7UUFDckMsSUFBSSxDQUFDQSxhQUFhO1lBQ2QsSUFBSSxDQUFDRSw4QkFBOEIsQ0FBQ0g7UUFDeEM7SUFDSjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0RFLDJCQUEyQkYsSUFBSSxFQUFFQyxXQUFXLEVBQUU7UUFDMUMsSUFBSUc7UUFDSixtREFBbUQ7UUFDbkQsSUFBSUgsYUFBYTtZ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QUFDakIsb0JBQW9CLENBQUNZLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxHQUN0RDtZQUNSO1FBQ0o7SUFDSjtBQUNKO0FBQ0FyQiw4QkFBOEIsR0FBR0c7QUFDakM7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsK0JBQStCb0MsSUFBSSxFQUFFQyxHQUFHO0lBQzdDLGtCQUFrQjtJQUNsQixNQUFNQyxZQUFZRixLQUFLRyxLQUFLO0lBQzVCLE1BQU1DLG1CQUFtQkosS0FBS0ssaUJBQWlCO0lBQy9DLE1BQU1DLFdBQVdOLEtBQUtPLFNBQVM7SUFDL0IsSUFBSUMsVUFBVSxDQUFDLFdBQVcsRUFBRU4sVUFBVSxDQUFDO0lBQ3ZDLElBQUksT0FBT0UscUJBQXFCLGFBQWE7UUFDekNJLFdBQVcsQ0FBQyxFQUFFLEVBQUVKLGlCQUFpQixDQUFDO0lBQ3RDO0lBQ0EsSUFBSSxPQUFPRSxhQUFhLGFBQWE7UUFDakNFLFdBQVcsQ0FBQyxHQUFHLEVBQUVGLFNBQVMsQ0FBQztJQUMvQjtJQUNBLE1BQU1HLFdBQVcsSUFBSVYsTUFBTVM7SUFDM0IsZ0VBQWdFO0lBQ2hFLElBQUlQLEtBQUs7UUFDTCxNQUFNUyxPQUFPbEQsT0FBT2tELElBQUksQ0FBQ1Q7UUFDekIsSUFBSUEsSUFBSVUsS0FBSyxFQUFFO1lBQ1gsaUNBQWlDO1lBQ2pDRCxLQUFLRSxJQUFJLENBQUM7UUFDZDtRQUNBRixLQUFLRyxPQUFPLENBQUNyQixDQUFBQTtZQUNULHNDQUFzQztZQUN0QyxJQUFJQSxRQUFRLFdBQVc7Z0JBQ25CaEMsT0FBT0MsY0FBYyxDQUFDZ0QsVUFBVWpCLEtBQUs7b0JBQ2pDLDhEQUE4RDtvQkFDOUQ3QixPQUFPc0MsR0FBRyxDQUFDVCxJQUFJO29CQUNmc0IsVUFBVTtvQkFDVkMsWUFBWTtnQkFDaEI7WUFDSjtRQUNKO0lBQ0o7SUFDQSxPQUFPTjtBQUNYO0FBQ0EvQyxzQ0FBc0MsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjb21tb24uanM/MWYxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UgPSBleHBvcnRzLk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9jcnlwdG9cIik7XG4vKiogTGlzdCBvZiBIVFRQIG1ldGhvZHMgdGhhdCBhY2NlcHQgcmVxdWVzdCBib2RpZXMuICovXG5jb25zdCBNRVRIT0RTX1NVUFBPUlRJTkdfUkVRVUVTVF9CT0RZID0gWydQVVQnLCAnUE9TVCcsICdQQVRDSCddO1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBmb3IgaGFuZGxpbmcgY2xpZW50IGF1dGhlbnRpY2F0aW9uIGluIE9BdXRoLWJhc2VkXG4gKiBvcGVyYXRpb25zLlxuICogV2hlbiByZXF1ZXN0LWJvZHkgY2xpZW50IGF1dGhlbnRpY2F0aW9uIGlzIHVzZWQsIG9ubHkgYXBwbGljYXRpb24vanNvbiBhbmRcbiAqIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBjb250ZW50IHR5cGVzIGZvciBIVFRQIG1ldGhvZHMgdGhhdCBzdXBwb3J0XG4gKiByZXF1ZXN0IGJvZGllcyBhcmUgc3VwcG9ydGVkLlxuICovXG5jbGFzcyBPQXV0aENsaWVudEF1dGhIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gT0F1dGggY2xpZW50IGF1dGhlbnRpY2F0aW9uIGhhbmRsZXIuXG4gICAgICogQHBhcmFtIGNsaWVudEF1dGhlbnRpY2F0aW9uIFRoZSBjbGllbnQgYXV0aCBjcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uID0gY2xpZW50QXV0aGVudGljYXRpb247XG4gICAgICAgIHRoaXMuY3J5cHRvID0gKDAsIGNyeXB0b18xLmNyZWF0ZUNyeXB0bykoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBjbGllbnQgYXV0aGVudGljYXRpb24gb24gdGhlIE9BdXRoIHJlcXVlc3QncyBoZWFkZXJzIG9yIFBPU1RcbiAgICAgKiBib2R5IGJ1dCBkb2VzIG5vdCBwcm9jZXNzIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBHYXhpb3NPcHRpb25zIHdob3NlIGhlYWRlcnMgb3IgZGF0YSBhcmUgdG8gYmUgbW9kaWZpZWRcbiAgICAgKiAgIGRlcGVuZGluZyBvbiB0aGUgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSB0byBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSBiZWFyZXJUb2tlbiBUaGUgb3B0aW9uYWwgYmVhcmVyIHRva2VuIHRvIHVzZSBmb3IgYXV0aGVudGljYXRpb24uXG4gICAgICogICBXaGVuIHRoaXMgaXMgdXNlZCwgbm8gY2xpZW50IGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGFyZSBuZWVkZWQuXG4gICAgICovXG4gICAgYXBwbHlDbGllbnRBdXRoZW50aWNhdGlvbk9wdGlvbnMob3B0cywgYmVhcmVyVG9rZW4pIHtcbiAgICAgICAgLy8gSW5qZWN0IGF1dGhlbnRpY2F0ZWQgaGVhZGVyLlxuICAgICAgICB0aGlzLmluamVjdEF1dGhlbnRpY2F0ZWRIZWFkZXJzKG9wdHMsIGJlYXJlclRva2VuKTtcbiAgICAgICAgLy8gSW5qZWN0IGF1dGhlbnRpY2F0ZWQgcmVxdWVzdCBib2R5LlxuICAgICAgICBpZiAoIWJlYXJlclRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmluamVjdEF1dGhlbnRpY2F0ZWRSZXF1ZXN0Qm9keShvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGNsaWVudCBhdXRoZW50aWNhdGlvbiBvbiB0aGUgcmVxdWVzdCdzIGhlYWRlciBpZiBlaXRoZXJcbiAgICAgKiBiYXNpYyBhdXRoZW50aWNhdGlvbiBvciBiZWFyZXIgdG9rZW4gYXV0aGVudGljYXRpb24gaXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgR2F4aW9zT3B0aW9ucyB3aG9zZSBoZWFkZXJzIG9yIGRhdGEgYXJlIHRvIGJlIG1vZGlmaWVkXG4gICAgICogICBkZXBlbmRpbmcgb24gdGhlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc20gdG8gYmUgdXNlZC5cbiAgICAgKiBAcGFyYW0gYmVhcmVyVG9rZW4gVGhlIG9wdGlvbmFsIGJlYXJlciB0b2tlbiB0byB1c2UgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqICAgV2hlbiB0aGlzIGlzIHVzZWQsIG5vIGNsaWVudCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBhcmUgbmVlZGVkLlxuICAgICAqL1xuICAgIGluamVjdEF1dGhlbnRpY2F0ZWRIZWFkZXJzKG9wdHMsIGJlYXJlclRva2VuKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gQmVhcmVyIHRva2VuIHByaW9yaXRpemVkIGhpZ2hlciB0aGFuIGJhc2ljIEF1dGguXG4gICAgICAgIGlmIChiZWFyZXJUb2tlbikge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YmVhcmVyVG9rZW59fWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9hID0gdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZGVudGlhbENsaWVudFR5cGUpID09PSAnYmFzaWMnKSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICBjb25zdCBjbGllbnRJZCA9IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50SWQ7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRTZWNyZXQgPSB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudFNlY3JldCB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NEVuY29kZWRDcmVkcyA9IHRoaXMuY3J5cHRvLmVuY29kZUJhc2U2NFN0cmluZ1V0ZjgoYCR7Y2xpZW50SWR9OiR7Y2xpZW50U2VjcmV0fWApO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmFzaWMgJHtiYXNlNjRFbmNvZGVkQ3JlZHN9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG9uIHRoZSByZXF1ZXN0J3MgYm9keSBpZiByZXF1ZXN0LWJvZHlcbiAgICAgKiBjbGllbnQgYXV0aGVudGljYXRpb24gaXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgR2F4aW9zT3B0aW9ucyB3aG9zZSBoZWFkZXJzIG9yIGRhdGEgYXJlIHRvIGJlIG1vZGlmaWVkXG4gICAgICogICBkZXBlbmRpbmcgb24gdGhlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc20gdG8gYmUgdXNlZC5cbiAgICAgKi9cbiAgICBpbmplY3RBdXRoZW50aWNhdGVkUmVxdWVzdEJvZHkob3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZGVudGlhbENsaWVudFR5cGUpID09PSAncmVxdWVzdC1ib2R5Jykge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gKG9wdHMubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgLy8gSW5qZWN0IGF1dGhlbnRpY2F0ZWQgcmVxdWVzdCBib2R5LlxuICAgICAgICAgICAgaWYgKE1FVEhPRFNfU1VQUE9SVElOR19SRVFVRVNUX0JPRFkuaW5kZXhPZihtZXRob2QpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIEdldCBjb250ZW50LXR5cGUuXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnICYmIGhlYWRlcnNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBoZWFkZXJzW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kYXRhID0gb3B0cy5kYXRhIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcXVlcnlzdHJpbmcucGFyc2Uob3B0cy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudFNlY3JldCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuZGF0YSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmRhdGEgPSBvcHRzLmRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cy5kYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudFNlY3JldCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGVudFR5cGV9IGNvbnRlbnQtdHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke3RoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY29uZmlkZW50aWFsQ2xpZW50VHlwZX0gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xpZW50IGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21ldGhvZH0gSFRUUCBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbi5jb25maWRlbnRpYWxDbGllbnRUeXBlfSBgICtcbiAgICAgICAgICAgICAgICAgICAgJ2NsaWVudCBhdXRoZW50aWNhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5PQXV0aENsaWVudEF1dGhIYW5kbGVyID0gT0F1dGhDbGllbnRBdXRoSGFuZGxlcjtcbi8qKlxuICogQ29udmVydHMgYW4gT0F1dGggZXJyb3IgcmVzcG9uc2UgdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBFcnJvci5cbiAqIEBwYXJhbSByZXNwIFRoZSBPQXV0aCBlcnJvciByZXNwb25zZSB0byBjb252ZXJ0IHRvIGEgbmF0aXZlIEVycm9yIG9iamVjdC5cbiAqIEBwYXJhbSBlcnIgVGhlIG9wdGlvbmFsIG9yaWdpbmFsIGVycm9yLiBJZiBwcm92aWRlZCwgdGhlIGVycm9yIHByb3BlcnRpZXNcbiAqICAgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBlcnJvci5cbiAqIEByZXR1cm4gVGhlIGNvbnZlcnRlZCBuYXRpdmUgRXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UocmVzcCwgZXJyKSB7XG4gICAgLy8gRXJyb3IgcmVzcG9uc2UuXG4gICAgY29uc3QgZXJyb3JDb2RlID0gcmVzcC5lcnJvcjtcbiAgICBjb25zdCBlcnJvckRlc2NyaXB0aW9uID0gcmVzcC5lcnJvcl9kZXNjcmlwdGlvbjtcbiAgICBjb25zdCBlcnJvclVyaSA9IHJlc3AuZXJyb3JfdXJpO1xuICAgIGxldCBtZXNzYWdlID0gYEVycm9yIGNvZGUgJHtlcnJvckNvZGV9YDtcbiAgICBpZiAodHlwZW9mIGVycm9yRGVzY3JpcHRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYDogJHtlcnJvckRlc2NyaXB0aW9ufWA7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXJyb3JVcmkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYCAtICR7ZXJyb3JVcml9YDtcbiAgICB9XG4gICAgY29uc3QgbmV3RXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gb3JpZ2luYWwgZXJyb3IgdG8gbmV3bHkgZ2VuZXJhdGVkIGVycm9yLlxuICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGVycik7XG4gICAgICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIC8vIENvcHkgZXJyb3Iuc3RhY2sgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAga2V5cy5wdXNoKCdzdGFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLy8gRG8gbm90IG92ZXJ3cml0ZSB0aGUgbWVzc2FnZSBmaWVsZC5cbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdtZXNzYWdlJykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdFcnJvciwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlcnJba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0Vycm9yO1xufVxuZXhwb3J0cy5nZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UgPSBnZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2U7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UiLCJPQXV0aENsaWVudEF1dGhIYW5kbGVyIiwicXVlcnlzdHJpbmciLCJyZXF1aXJlIiwiY3J5cHRvXzEiLCJNRVRIT0RTX1NVUFBPUlRJTkdfUkVRVUVTVF9CT0RZIiwiY29uc3RydWN0b3IiLCJjbGllbnRBdXRoZW50aWNhdGlvbiIsImNyeXB0byIsImNyZWF0ZUNyeXB0byIsImFwcGx5Q2xpZW50QXV0aGVudGljYXRpb25PcHRpb25zIiwib3B0cyIsImJlYXJlclRva2VuIiwiaW5qZWN0QXV0aGVudGljYXRlZEhlYWRlcnMiLCJpbmplY3RBdXRoZW50aWNhdGVkUmVxdWVzdEJvZHkiLCJfYSIsImhlYWRlcnMiLCJhc3NpZ24iLCJBdXRob3JpemF0aW9uIiwiY29uZmlkZW50aWFsQ2xpZW50VHlwZSIsImNsaWVudElkIiwiY2xpZW50U2VjcmV0IiwiYmFzZTY0RW5jb2RlZENyZWRzIiwiZW5jb2RlQmFzZTY0U3RyaW5nVXRmOCIsIm1ldGhvZCIsInRvVXBwZXJDYXNlIiwiaW5kZXhPZiIsImNvbnRlbnRUeXBlIiwia2V5IiwidG9Mb3dlckNhc2UiLCJkYXRhIiwicGFyc2UiLCJjbGllbnRfaWQiLCJjbGllbnRfc2VjcmV0Iiwic3RyaW5naWZ5IiwiRXJyb3IiLCJyZXNwIiwiZXJyIiwiZXJyb3JDb2RlIiwiZXJyb3IiLCJlcnJvckRlc2NyaXB0aW9uIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJlcnJvclVyaSIsImVycm9yX3VyaSIsIm1lc3NhZ2UiLCJuZXdFcnJvciIsImtleXMiLCJzdGFjayIsInB1c2giLCJmb3JFYWNoIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PluggableAuthClient = exports.ExecutableError = void 0;\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst executable_response_1 = __webpack_require__(/*! ./executable-response */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/executable-response.js\");\nconst pluggable_auth_handler_1 = __webpack_require__(/*! ./pluggable-auth-handler */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js\");\n/**\n * Error thrown from the executable run by PluggableAuthClient.\n */ class ExecutableError extends Error {\n    constructor(message, code){\n        super(`The executable failed with exit code: ${code} and error message: ${message}.`);\n        this.code = code;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.ExecutableError = ExecutableError;\n/**\n * The default executable timeout when none is provided, in milliseconds.\n */ const DEFAULT_EXECUTABLE_TIMEOUT_MILLIS = 30 * 1000;\n/**\n * The minimum allowed executable timeout in milliseconds.\n */ const MINIMUM_EXECUTABLE_TIMEOUT_MILLIS = 5 * 1000;\n/**\n * The maximum allowed executable timeout in milliseconds.\n */ const MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS = 120 * 1000;\n/**\n * The environment variable to check to see if executable can be run.\n * Value must be set to '1' for the executable to run.\n */ const GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES = \"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\";\n/**\n * The maximum currently supported executable version.\n */ const MAXIMUM_EXECUTABLE_VERSION = 1;\n/**\n * PluggableAuthClient enables the exchange of workload identity pool external credentials for\n * Google access tokens by retrieving 3rd party tokens through a user supplied executable. These\n * scripts/executables are completely independent of the Google Cloud Auth libraries. These\n * credentials plug into ADC and will call the specified executable to retrieve the 3rd party token\n * to be exchanged for a Google access token.\n *\n * <p>To use these credentials, the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment variable\n * must be set to '1'. This is for security reasons.\n *\n * <p>Both OIDC and SAML are supported. The executable must adhere to a specific response format\n * defined below.\n *\n * <p>The executable must print out the 3rd party token to STDOUT in JSON format. When an\n * output_file is specified in the credential configuration, the executable must also handle writing the\n * JSON response to this file.\n *\n * <pre>\n * OIDC response sample:\n * {\n *   \"version\": 1,\n *   \"success\": true,\n *   \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n *   \"id_token\": \"HEADER.PAYLOAD.SIGNATURE\",\n *   \"expiration_time\": 1620433341\n * }\n *\n * SAML2 response sample:\n * {\n *   \"version\": 1,\n *   \"success\": true,\n *   \"token_type\": \"urn:ietf:params:oauth:token-type:saml2\",\n *   \"saml_response\": \"...\",\n *   \"expiration_time\": 1620433341\n * }\n *\n * Error response sample:\n * {\n *   \"version\": 1,\n *   \"success\": false,\n *   \"code\": \"401\",\n *   \"message\": \"Error message.\"\n * }\n * </pre>\n *\n * <p>The \"expiration_time\" field in the JSON response is only required for successful\n * responses when an output file was specified in the credential configuration\n *\n * <p>The auth libraries will populate certain environment variables that will be accessible by the\n * executable, such as: GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE, GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE,\n * GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE, GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL, and\n * GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE.\n *\n * <p>Please see this repositories README for a complete executable request/response specification.\n */ class PluggableAuthClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiates a PluggableAuthClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid pluggable auth credential.\n     * @param options The external account options object typically loaded from\n     *   the external account JSON credential file.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        super(options, additionalOptions);\n        if (!options.credential_source.executable) {\n            throw new Error('No valid Pluggable Auth \"credential_source\" provided.');\n        }\n        this.command = options.credential_source.executable.command;\n        if (!this.command) {\n            throw new Error('No valid Pluggable Auth \"credential_source\" provided.');\n        }\n        // Check if the provided timeout exists and if it is valid.\n        if (options.credential_source.executable.timeout_millis === undefined) {\n            this.timeoutMillis = DEFAULT_EXECUTABLE_TIMEOUT_MILLIS;\n        } else {\n            this.timeoutMillis = options.credential_source.executable.timeout_millis;\n            if (this.timeoutMillis < MINIMUM_EXECUTABLE_TIMEOUT_MILLIS || this.timeoutMillis > MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS) {\n                throw new Error(`Timeout must be between ${MINIMUM_EXECUTABLE_TIMEOUT_MILLIS} and ` + `${MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS} milliseconds.`);\n            }\n        }\n        this.outputFile = options.credential_source.executable.output_file;\n        this.handler = new pluggable_auth_handler_1.PluggableAuthHandler({\n            command: this.command,\n            timeoutMillis: this.timeoutMillis,\n            outputFile: this.outputFile\n        });\n        this.credentialSourceType = \"executable\";\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this calls a user provided executable which returns the subject token.\n     * The logic is summarized as:\n     * 1. Validated that the executable is allowed to run. The\n     *    GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment must be set to\n     *    1 for security reasons.\n     * 2. If an output file is specified by the user, check the file location\n     *    for a response. If the file exists and contains a valid response,\n     *    return the subject token from the file.\n     * 3. Call the provided executable and return response.\n     * @return A promise that resolves with the external subject token.\n     */ async retrieveSubjectToken() {\n        // Check if the executable is allowed to run.\n        if (process.env[GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES] !== \"1\") {\n            throw new Error(\"Pluggable Auth executables need to be explicitly allowed to run by \" + \"setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment \" + \"Variable to 1.\");\n        }\n        let executableResponse = undefined;\n        // Try to get cached executable response from output file.\n        if (this.outputFile) {\n            executableResponse = await this.handler.retrieveCachedResponse();\n        }\n        // If no response from output file, call the executable.\n        if (!executableResponse) {\n            // Set up environment map with required values for the executable.\n            const envMap = new Map();\n            envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE\", this.audience);\n            envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE\", this.subjectTokenType);\n            // Always set to 0 because interactive mode is not supported.\n            envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE\", \"0\");\n            if (this.outputFile) {\n                envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE\", this.outputFile);\n            }\n            const serviceAccountEmail = this.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL\", serviceAccountEmail);\n            }\n            executableResponse = await this.handler.retrieveResponseFromExecutable(envMap);\n        }\n        if (executableResponse.version > MAXIMUM_EXECUTABLE_VERSION) {\n            throw new Error(`Version of executable is not currently supported, maximum supported version is ${MAXIMUM_EXECUTABLE_VERSION}.`);\n        }\n        // Check that response was successful.\n        if (!executableResponse.success) {\n            throw new ExecutableError(executableResponse.errorMessage, executableResponse.errorCode);\n        }\n        // Check that response contains expiration time if output file was specified.\n        if (this.outputFile) {\n            if (!executableResponse.expirationTime) {\n                throw new executable_response_1.InvalidExpirationTimeFieldError(\"The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.\");\n            }\n        }\n        // Check that response is not expired.\n        if (executableResponse.isExpired()) {\n            throw new Error(\"Executable response is expired.\");\n        }\n        // Return subject token from response.\n        return executableResponse.subjectToken;\n    }\n}\nexports.PluggableAuthClient = PluggableAuthClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL3BsdWdnYWJsZS1hdXRoLWNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQzdELE1BQU1JLHVCQUF1QkMsbUJBQU9BLENBQUMsc0hBQXNCO0FBQzNELE1BQU1DLHdCQUF3QkQsbUJBQU9BLENBQUMsd0hBQXVCO0FBQzdELE1BQU1FLDJCQUEyQkYsbUJBQU9BLENBQUMsOEhBQTBCO0FBQ25FOztDQUVDLEdBQ0QsTUFBTUYsd0JBQXdCSztJQUMxQkMsWUFBWUMsT0FBTyxFQUFFQyxJQUFJLENBQUU7UUFDdkIsS0FBSyxDQUFDLENBQUMsc0NBQXNDLEVBQUVBLEtBQUssb0JBQW9CLEVBQUVELFFBQVEsQ0FBQyxDQUFDO1FBQ3BGLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaYixPQUFPYyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVdDLFNBQVM7SUFDcEQ7QUFDSjtBQUNBYix1QkFBdUIsR0FBR0c7QUFDMUI7O0NBRUMsR0FDRCxNQUFNVyxvQ0FBb0MsS0FBSztBQUMvQzs7Q0FFQyxHQUNELE1BQU1DLG9DQUFvQyxJQUFJO0FBQzlDOztDQUVDLEdBQ0QsTUFBTUMsb0NBQW9DLE1BQU07QUFDaEQ7OztDQUdDLEdBQ0QsTUFBTUMsNENBQTRDO0FBQ2xEOztDQUVDLEdBQ0QsTUFBTUMsNkJBQTZCO0FBQ25DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzREMsR0FDRCxNQUFNaEIsNEJBQTRCRSxxQkFBcUJlLHlCQUF5QjtJQUM1RTs7Ozs7Ozs7OztLQVVDLEdBQ0RWLFlBQVlXLE9BQU8sRUFBRUMsaUJBQWlCLENBQUU7UUFDcEMsS0FBSyxDQUFDRCxTQUFTQztRQUNmLElBQUksQ0FBQ0QsUUFBUUUsaUJBQWlCLENBQUNDLFVBQVUsRUFBRTtZQUN2QyxNQUFNLElBQUlmLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNnQixPQUFPLEdBQUdKLFFBQVFFLGlCQUFpQixDQUFDQyxVQUFVLENBQUNDLE9BQU87UUFDM0QsSUFBSSxDQUFDLElBQUksQ0FBQ0EsT0FBTyxFQUFFO1lBQ2YsTUFBTSxJQUFJaEIsTUFBTTtRQUNwQjtRQUNBLDJEQUEyRDtRQUMzRCxJQUFJWSxRQUFRRSxpQkFBaUIsQ0FBQ0MsVUFBVSxDQUFDRSxjQUFjLEtBQUtDLFdBQVc7WUFDbkUsSUFBSSxDQUFDQyxhQUFhLEdBQUdiO1FBQ3pCLE9BQ0s7WUFDRCxJQUFJLENBQUNhLGFBQWEsR0FBR1AsUUFBUUUsaUJBQWlCLENBQUNDLFVBQVUsQ0FBQ0UsY0FBYztZQUN4RSxJQUFJLElBQUksQ0FBQ0UsYUFBYSxHQUFHWixxQ0FDckIsSUFBSSxDQUFDWSxhQUFhLEdBQUdYLG1DQUFtQztnQkFDeEQsTUFBTSxJQUFJUixNQUFNLENBQUMsd0JBQXdCLEVBQUVPLGtDQUFrQyxLQUFLLENBQUMsR0FDL0UsQ0FBQyxFQUFFQyxrQ0FBa0MsY0FBYyxDQUFDO1lBQzVEO1FBQ0o7UUFDQSxJQUFJLENBQUNZLFVBQVUsR0FBR1IsUUFBUUUsaUJBQWlCLENBQUNDLFVBQVUsQ0FBQ00sV0FBVztRQUNsRSxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJdkIseUJBQXlCd0Isb0JBQW9CLENBQUM7WUFDN0RQLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCRyxlQUFlLElBQUksQ0FBQ0EsYUFBYTtZQUNqQ0MsWUFBWSxJQUFJLENBQUNBLFVBQVU7UUFDL0I7UUFDQSxJQUFJLENBQUNJLG9CQUFvQixHQUFHO0lBQ2hDO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0QsTUFBTUMsdUJBQXVCO1FBQ3pCLDZDQUE2QztRQUM3QyxJQUFJQyxRQUFRQyxHQUFHLENBQUNsQiwwQ0FBMEMsS0FBSyxLQUFLO1lBQ2hFLE1BQU0sSUFBSVQsTUFBTSx3RUFDWix1RUFDQTtRQUNSO1FBQ0EsSUFBSTRCLHFCQUFxQlY7UUFDekIsMERBQTBEO1FBQzFELElBQUksSUFBSSxDQUFDRSxVQUFVLEVBQUU7WUFDakJRLHFCQUFxQixNQUFNLElBQUksQ0FBQ04sT0FBTyxDQUFDTyxzQkFBc0I7UUFDbEU7UUFDQSx3REFBd0Q7UUFDeEQsSUFBSSxDQUFDRCxvQkFBb0I7WUFDckIsa0VBQWtFO1lBQ2xFLE1BQU1FLFNBQVMsSUFBSUM7WUFDbkJELE9BQU9FLEdBQUcsQ0FBQyxvQ0FBb0MsSUFBSSxDQUFDQyxRQUFRO1lBQzVESCxPQUFPRSxHQUFHLENBQUMsc0NBQXNDLElBQUksQ0FBQ0UsZ0JBQWdCO1lBQ3RFLDZEQUE2RDtZQUM3REosT0FBT0UsR0FBRyxDQUFDLHVDQUF1QztZQUNsRCxJQUFJLElBQUksQ0FBQ1osVUFBVSxFQUFFO2dCQUNqQlUsT0FBT0UsR0FBRyxDQUFDLHVDQUF1QyxJQUFJLENBQUNaLFVBQVU7WUFDckU7WUFDQSxNQUFNZSxzQkFBc0IsSUFBSSxDQUFDQyxzQkFBc0I7WUFDdkQsSUFBSUQscUJBQXFCO2dCQUNyQkwsT0FBT0UsR0FBRyxDQUFDLDhDQUE4Q0c7WUFDN0Q7WUFDQVAscUJBQ0ksTUFBTSxJQUFJLENBQUNOLE9BQU8sQ0FBQ2UsOEJBQThCLENBQUNQO1FBQzFEO1FBQ0EsSUFBSUYsbUJBQW1CVSxPQUFPLEdBQUc1Qiw0QkFBNEI7WUFDekQsTUFBTSxJQUFJVixNQUFNLENBQUMsK0VBQStFLEVBQUVVLDJCQUEyQixDQUFDLENBQUM7UUFDbkk7UUFDQSxzQ0FBc0M7UUFDdEMsSUFBSSxDQUFDa0IsbUJBQW1CVyxPQUFPLEVBQUU7WUFDN0IsTUFBTSxJQUFJNUMsZ0JBQWdCaUMsbUJBQW1CWSxZQUFZLEVBQUVaLG1CQUFtQmEsU0FBUztRQUMzRjtRQUNBLDZFQUE2RTtRQUM3RSxJQUFJLElBQUksQ0FBQ3JCLFVBQVUsRUFBRTtZQUNqQixJQUFJLENBQUNRLG1CQUFtQmMsY0FBYyxFQUFFO2dCQUNwQyxNQUFNLElBQUk1QyxzQkFBc0I2QywrQkFBK0IsQ0FBQztZQUNwRTtRQUNKO1FBQ0Esc0NBQXNDO1FBQ3RDLElBQUlmLG1CQUFtQmdCLFNBQVMsSUFBSTtZQUNoQyxNQUFNLElBQUk1QyxNQUFNO1FBQ3BCO1FBQ0Esc0NBQXNDO1FBQ3RDLE9BQU80QixtQkFBbUJpQixZQUFZO0lBQzFDO0FBQ0o7QUFDQXJELDJCQUEyQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb3RpZnktdG8teW91dHViZS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL3BsdWdnYWJsZS1hdXRoLWNsaWVudC5qcz9jMThlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBsdWdnYWJsZUF1dGhDbGllbnQgPSBleHBvcnRzLkV4ZWN1dGFibGVFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuY29uc3QgZXhlY3V0YWJsZV9yZXNwb25zZV8xID0gcmVxdWlyZShcIi4vZXhlY3V0YWJsZS1yZXNwb25zZVwiKTtcbmNvbnN0IHBsdWdnYWJsZV9hdXRoX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL3BsdWdnYWJsZS1hdXRoLWhhbmRsZXJcIik7XG4vKipcbiAqIEVycm9yIHRocm93biBmcm9tIHRoZSBleGVjdXRhYmxlIHJ1biBieSBQbHVnZ2FibGVBdXRoQ2xpZW50LlxuICovXG5jbGFzcyBFeGVjdXRhYmxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICBzdXBlcihgVGhlIGV4ZWN1dGFibGUgZmFpbGVkIHdpdGggZXhpdCBjb2RlOiAke2NvZGV9IGFuZCBlcnJvciBtZXNzYWdlOiAke21lc3NhZ2V9LmApO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhlY3V0YWJsZUVycm9yID0gRXhlY3V0YWJsZUVycm9yO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBleGVjdXRhYmxlIHRpbWVvdXQgd2hlbiBub25lIGlzIHByb3ZpZGVkLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmNvbnN0IERFRkFVTFRfRVhFQ1VUQUJMRV9USU1FT1VUX01JTExJUyA9IDMwICogMTAwMDtcbi8qKlxuICogVGhlIG1pbmltdW0gYWxsb3dlZCBleGVjdXRhYmxlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5jb25zdCBNSU5JTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMgPSA1ICogMTAwMDtcbi8qKlxuICogVGhlIG1heGltdW0gYWxsb3dlZCBleGVjdXRhYmxlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5jb25zdCBNQVhJTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMgPSAxMjAgKiAxMDAwO1xuLyoqXG4gKiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gY2hlY2sgdG8gc2VlIGlmIGV4ZWN1dGFibGUgY2FuIGJlIHJ1bi5cbiAqIFZhbHVlIG11c3QgYmUgc2V0IHRvICcxJyBmb3IgdGhlIGV4ZWN1dGFibGUgdG8gcnVuLlxuICovXG5jb25zdCBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyA9ICdHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyc7XG4vKipcbiAqIFRoZSBtYXhpbXVtIGN1cnJlbnRseSBzdXBwb3J0ZWQgZXhlY3V0YWJsZSB2ZXJzaW9uLlxuICovXG5jb25zdCBNQVhJTVVNX0VYRUNVVEFCTEVfVkVSU0lPTiA9IDE7XG4vKipcbiAqIFBsdWdnYWJsZUF1dGhDbGllbnQgZW5hYmxlcyB0aGUgZXhjaGFuZ2Ugb2Ygd29ya2xvYWQgaWRlbnRpdHkgcG9vbCBleHRlcm5hbCBjcmVkZW50aWFscyBmb3JcbiAqIEdvb2dsZSBhY2Nlc3MgdG9rZW5zIGJ5IHJldHJpZXZpbmcgM3JkIHBhcnR5IHRva2VucyB0aHJvdWdoIGEgdXNlciBzdXBwbGllZCBleGVjdXRhYmxlLiBUaGVzZVxuICogc2NyaXB0cy9leGVjdXRhYmxlcyBhcmUgY29tcGxldGVseSBpbmRlcGVuZGVudCBvZiB0aGUgR29vZ2xlIENsb3VkIEF1dGggbGlicmFyaWVzLiBUaGVzZVxuICogY3JlZGVudGlhbHMgcGx1ZyBpbnRvIEFEQyBhbmQgd2lsbCBjYWxsIHRoZSBzcGVjaWZpZWQgZXhlY3V0YWJsZSB0byByZXRyaWV2ZSB0aGUgM3JkIHBhcnR5IHRva2VuXG4gKiB0byBiZSBleGNoYW5nZWQgZm9yIGEgR29vZ2xlIGFjY2VzcyB0b2tlbi5cbiAqXG4gKiA8cD5UbyB1c2UgdGhlc2UgY3JlZGVudGlhbHMsIHRoZSBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogbXVzdCBiZSBzZXQgdG8gJzEnLiBUaGlzIGlzIGZvciBzZWN1cml0eSByZWFzb25zLlxuICpcbiAqIDxwPkJvdGggT0lEQyBhbmQgU0FNTCBhcmUgc3VwcG9ydGVkLiBUaGUgZXhlY3V0YWJsZSBtdXN0IGFkaGVyZSB0byBhIHNwZWNpZmljIHJlc3BvbnNlIGZvcm1hdFxuICogZGVmaW5lZCBiZWxvdy5cbiAqXG4gKiA8cD5UaGUgZXhlY3V0YWJsZSBtdXN0IHByaW50IG91dCB0aGUgM3JkIHBhcnR5IHRva2VuIHRvIFNURE9VVCBpbiBKU09OIGZvcm1hdC4gV2hlbiBhblxuICogb3V0cHV0X2ZpbGUgaXMgc3BlY2lmaWVkIGluIHRoZSBjcmVkZW50aWFsIGNvbmZpZ3VyYXRpb24sIHRoZSBleGVjdXRhYmxlIG11c3QgYWxzbyBoYW5kbGUgd3JpdGluZyB0aGVcbiAqIEpTT04gcmVzcG9uc2UgdG8gdGhpcyBmaWxlLlxuICpcbiAqIDxwcmU+XG4gKiBPSURDIHJlc3BvbnNlIHNhbXBsZTpcbiAqIHtcbiAqICAgXCJ2ZXJzaW9uXCI6IDEsXG4gKiAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICogICBcInRva2VuX3R5cGVcIjogXCJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTppZF90b2tlblwiLFxuICogICBcImlkX3Rva2VuXCI6IFwiSEVBREVSLlBBWUxPQUQuU0lHTkFUVVJFXCIsXG4gKiAgIFwiZXhwaXJhdGlvbl90aW1lXCI6IDE2MjA0MzMzNDFcbiAqIH1cbiAqXG4gKiBTQU1MMiByZXNwb25zZSBzYW1wbGU6XG4gKiB7XG4gKiAgIFwidmVyc2lvblwiOiAxLFxuICogICBcInN1Y2Nlc3NcIjogdHJ1ZSxcbiAqICAgXCJ0b2tlbl90eXBlXCI6IFwidXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6c2FtbDJcIixcbiAqICAgXCJzYW1sX3Jlc3BvbnNlXCI6IFwiLi4uXCIsXG4gKiAgIFwiZXhwaXJhdGlvbl90aW1lXCI6IDE2MjA0MzMzNDFcbiAqIH1cbiAqXG4gKiBFcnJvciByZXNwb25zZSBzYW1wbGU6XG4gKiB7XG4gKiAgIFwidmVyc2lvblwiOiAxLFxuICogICBcInN1Y2Nlc3NcIjogZmFsc2UsXG4gKiAgIFwiY29kZVwiOiBcIjQwMVwiLFxuICogICBcIm1lc3NhZ2VcIjogXCJFcnJvciBtZXNzYWdlLlwiXG4gKiB9XG4gKiA8L3ByZT5cbiAqXG4gKiA8cD5UaGUgXCJleHBpcmF0aW9uX3RpbWVcIiBmaWVsZCBpbiB0aGUgSlNPTiByZXNwb25zZSBpcyBvbmx5IHJlcXVpcmVkIGZvciBzdWNjZXNzZnVsXG4gKiByZXNwb25zZXMgd2hlbiBhbiBvdXRwdXQgZmlsZSB3YXMgc3BlY2lmaWVkIGluIHRoZSBjcmVkZW50aWFsIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiA8cD5UaGUgYXV0aCBsaWJyYXJpZXMgd2lsbCBwb3B1bGF0ZSBjZXJ0YWluIGVudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IHdpbGwgYmUgYWNjZXNzaWJsZSBieSB0aGVcbiAqIGV4ZWN1dGFibGUsIHN1Y2ggYXM6IEdPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0FVRElFTkNFLCBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9UT0tFTl9UWVBFLFxuICogR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfSU5URVJBQ1RJVkUsIEdPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0lNUEVSU09OQVRFRF9FTUFJTCwgYW5kXG4gKiBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9PVVRQVVRfRklMRS5cbiAqXG4gKiA8cD5QbGVhc2Ugc2VlIHRoaXMgcmVwb3NpdG9yaWVzIFJFQURNRSBmb3IgYSBjb21wbGV0ZSBleGVjdXRhYmxlIHJlcXVlc3QvcmVzcG9uc2Ugc3BlY2lmaWNhdGlvbi5cbiAqL1xuY2xhc3MgUGx1Z2dhYmxlQXV0aENsaWVudCBleHRlbmRzIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIFBsdWdnYWJsZUF1dGhDbGllbnQgaW5zdGFuY2UgdXNpbmcgdGhlIHByb3ZpZGVkIEpTT05cbiAgICAgKiBvYmplY3QgbG9hZGVkIGZyb20gYW4gZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFscyBmaWxlLlxuICAgICAqIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgY3JlZGVudGlhbCBpcyBub3QgYSB2YWxpZCBwbHVnZ2FibGUgYXV0aCBjcmVkZW50aWFsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHRlcm5hbCBhY2NvdW50IG9wdGlvbnMgb2JqZWN0IHR5cGljYWxseSBsb2FkZWQgZnJvbVxuICAgICAqICAgdGhlIGV4dGVybmFsIGFjY291bnQgSlNPTiBjcmVkZW50aWFsIGZpbGUuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zICoqREVQUkVDQVRFRCwgYWxsIG9wdGlvbnMgYXJlIGF2YWlsYWJsZSBpbiB0aGVcbiAgICAgKiAgIGBvcHRpb25zYCBwYXJhbWV0ZXIuKiogT3B0aW9uYWwgYWRkaXRpb25hbCBiZWhhdmlvciBjdXN0b21pemF0aW9uIG9wdGlvbnMuXG4gICAgICogICBUaGVzZSBjdXJyZW50bHkgY3VzdG9taXplIGV4cGlyYXRpb24gdGhyZXNob2xkIHRpbWUgYW5kIHdoZXRoZXIgdG8gcmV0cnlcbiAgICAgKiAgIG9uIDQwMS80MDMgQVBJIHJlcXVlc3QgZXJyb3JzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmV4ZWN1dGFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgUGx1Z2dhYmxlIEF1dGggXCJjcmVkZW50aWFsX3NvdXJjZVwiIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZXhlY3V0YWJsZS5jb21tYW5kO1xuICAgICAgICBpZiAoIXRoaXMuY29tbWFuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBQbHVnZ2FibGUgQXV0aCBcImNyZWRlbnRpYWxfc291cmNlXCIgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByb3ZpZGVkIHRpbWVvdXQgZXhpc3RzIGFuZCBpZiBpdCBpcyB2YWxpZC5cbiAgICAgICAgaWYgKG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZXhlY3V0YWJsZS50aW1lb3V0X21pbGxpcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRNaWxsaXMgPSBERUZBVUxUX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRNaWxsaXMgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmV4ZWN1dGFibGUudGltZW91dF9taWxsaXM7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lb3V0TWlsbGlzIDwgTUlOSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTIHx8XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0TWlsbGlzID4gTUFYSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaW1lb3V0IG11c3QgYmUgYmV0d2VlbiAke01JTklNVU1fRVhFQ1VUQUJMRV9USU1FT1VUX01JTExJU30gYW5kIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHtNQVhJTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVN9IG1pbGxpc2Vjb25kcy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dEZpbGUgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmV4ZWN1dGFibGUub3V0cHV0X2ZpbGU7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG5ldyBwbHVnZ2FibGVfYXV0aF9oYW5kbGVyXzEuUGx1Z2dhYmxlQXV0aEhhbmRsZXIoe1xuICAgICAgICAgICAgY29tbWFuZDogdGhpcy5jb21tYW5kLFxuICAgICAgICAgICAgdGltZW91dE1pbGxpczogdGhpcy50aW1lb3V0TWlsbGlzLFxuICAgICAgICAgICAgb3V0cHV0RmlsZTogdGhpcy5vdXRwdXRGaWxlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFsU291cmNlVHlwZSA9ICdleGVjdXRhYmxlJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYW4gZXh0ZXJuYWwgc3ViamVjdCB0b2tlbiBpcyBuZWVkZWQgdG8gYmUgZXhjaGFuZ2VkIGZvciBhXG4gICAgICogR0NQIGFjY2VzcyB0b2tlbiB2aWEgR0NQIFNUUyBlbmRwb2ludC5cbiAgICAgKiBUaGlzIHVzZXMgdGhlIGBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlYCBvYmplY3QgdG8gZmlndXJlIG91dCBob3dcbiAgICAgKiB0byByZXRyaWV2ZSB0aGUgdG9rZW4gdXNpbmcgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEluIHRoaXMgY2FzZSxcbiAgICAgKiB0aGlzIGNhbGxzIGEgdXNlciBwcm92aWRlZCBleGVjdXRhYmxlIHdoaWNoIHJldHVybnMgdGhlIHN1YmplY3QgdG9rZW4uXG4gICAgICogVGhlIGxvZ2ljIGlzIHN1bW1hcml6ZWQgYXM6XG4gICAgICogMS4gVmFsaWRhdGVkIHRoYXQgdGhlIGV4ZWN1dGFibGUgaXMgYWxsb3dlZCB0byBydW4uIFRoZVxuICAgICAqICAgIEdPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0FMTE9XX0VYRUNVVEFCTEVTIGVudmlyb25tZW50IG11c3QgYmUgc2V0IHRvXG4gICAgICogICAgMSBmb3Igc2VjdXJpdHkgcmVhc29ucy5cbiAgICAgKiAyLiBJZiBhbiBvdXRwdXQgZmlsZSBpcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXIsIGNoZWNrIHRoZSBmaWxlIGxvY2F0aW9uXG4gICAgICogICAgZm9yIGEgcmVzcG9uc2UuIElmIHRoZSBmaWxlIGV4aXN0cyBhbmQgY29udGFpbnMgYSB2YWxpZCByZXNwb25zZSxcbiAgICAgKiAgICByZXR1cm4gdGhlIHN1YmplY3QgdG9rZW4gZnJvbSB0aGUgZmlsZS5cbiAgICAgKiAzLiBDYWxsIHRoZSBwcm92aWRlZCBleGVjdXRhYmxlIGFuZCByZXR1cm4gcmVzcG9uc2UuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBleHRlcm5hbCBzdWJqZWN0IHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIHJldHJpZXZlU3ViamVjdFRva2VuKCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXhlY3V0YWJsZSBpcyBhbGxvd2VkIHRvIHJ1bi5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52W0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0FMTE9XX0VYRUNVVEFCTEVTXSAhPT0gJzEnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsdWdnYWJsZSBBdXRoIGV4ZWN1dGFibGVzIG5lZWQgdG8gYmUgZXhwbGljaXRseSBhbGxvd2VkIHRvIHJ1biBieSAnICtcbiAgICAgICAgICAgICAgICAnc2V0dGluZyB0aGUgR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVMgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICAgICAgICAgJ1ZhcmlhYmxlIHRvIDEuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV4ZWN1dGFibGVSZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBjYWNoZWQgZXhlY3V0YWJsZSByZXNwb25zZSBmcm9tIG91dHB1dCBmaWxlLlxuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWxlKSB7XG4gICAgICAgICAgICBleGVjdXRhYmxlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmhhbmRsZXIucmV0cmlldmVDYWNoZWRSZXNwb25zZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHJlc3BvbnNlIGZyb20gb3V0cHV0IGZpbGUsIGNhbGwgdGhlIGV4ZWN1dGFibGUuXG4gICAgICAgIGlmICghZXhlY3V0YWJsZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBTZXQgdXAgZW52aXJvbm1lbnQgbWFwIHdpdGggcmVxdWlyZWQgdmFsdWVzIGZvciB0aGUgZXhlY3V0YWJsZS5cbiAgICAgICAgICAgIGNvbnN0IGVudk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGVudk1hcC5zZXQoJ0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0FVRElFTkNFJywgdGhpcy5hdWRpZW5jZSk7XG4gICAgICAgICAgICBlbnZNYXAuc2V0KCdHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9UT0tFTl9UWVBFJywgdGhpcy5zdWJqZWN0VG9rZW5UeXBlKTtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBzZXQgdG8gMCBiZWNhdXNlIGludGVyYWN0aXZlIG1vZGUgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgICAgIGVudk1hcC5zZXQoJ0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0lOVEVSQUNUSVZFJywgJzAnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbGUpIHtcbiAgICAgICAgICAgICAgICBlbnZNYXAuc2V0KCdHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9PVVRQVVRfRklMRScsIHRoaXMub3V0cHV0RmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlQWNjb3VudEVtYWlsID0gdGhpcy5nZXRTZXJ2aWNlQWNjb3VudEVtYWlsKCk7XG4gICAgICAgICAgICBpZiAoc2VydmljZUFjY291bnRFbWFpbCkge1xuICAgICAgICAgICAgICAgIGVudk1hcC5zZXQoJ0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0lNUEVSU09OQVRFRF9FTUFJTCcsIHNlcnZpY2VBY2NvdW50RW1haWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhlY3V0YWJsZVJlc3BvbnNlID1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZXIucmV0cmlldmVSZXNwb25zZUZyb21FeGVjdXRhYmxlKGVudk1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4ZWN1dGFibGVSZXNwb25zZS52ZXJzaW9uID4gTUFYSU1VTV9FWEVDVVRBQkxFX1ZFUlNJT04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmVyc2lvbiBvZiBleGVjdXRhYmxlIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLCBtYXhpbXVtIHN1cHBvcnRlZCB2ZXJzaW9uIGlzICR7TUFYSU1VTV9FWEVDVVRBQkxFX1ZFUlNJT059LmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoYXQgcmVzcG9uc2Ugd2FzIHN1Y2Nlc3NmdWwuXG4gICAgICAgIGlmICghZXhlY3V0YWJsZVJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGVjdXRhYmxlRXJyb3IoZXhlY3V0YWJsZVJlc3BvbnNlLmVycm9yTWVzc2FnZSwgZXhlY3V0YWJsZVJlc3BvbnNlLmVycm9yQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCByZXNwb25zZSBjb250YWlucyBleHBpcmF0aW9uIHRpbWUgaWYgb3V0cHV0IGZpbGUgd2FzIHNwZWNpZmllZC5cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsZSkge1xuICAgICAgICAgICAgaWYgKCFleGVjdXRhYmxlUmVzcG9uc2UuZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkludmFsaWRFeHBpcmF0aW9uVGltZUZpZWxkRXJyb3IoJ1RoZSBleGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiB0aGUgYGV4cGlyYXRpb25fdGltZWAgZmllbGQgZm9yIHN1Y2Nlc3NmdWwgcmVzcG9uc2VzIHdoZW4gYW4gb3V0cHV0X2ZpbGUgaGFzIGJlZW4gc3BlY2lmaWVkIGluIHRoZSBjb25maWd1cmF0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoYXQgcmVzcG9uc2UgaXMgbm90IGV4cGlyZWQuXG4gICAgICAgIGlmIChleGVjdXRhYmxlUmVzcG9uc2UuaXNFeHBpcmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhlY3V0YWJsZSByZXNwb25zZSBpcyBleHBpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBzdWJqZWN0IHRva2VuIGZyb20gcmVzcG9uc2UuXG4gICAgICAgIHJldHVybiBleGVjdXRhYmxlUmVzcG9uc2Uuc3ViamVjdFRva2VuO1xuICAgIH1cbn1cbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aENsaWVudCA9IFBsdWdnYWJsZUF1dGhDbGllbnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQbHVnZ2FibGVBdXRoQ2xpZW50IiwiRXhlY3V0YWJsZUVycm9yIiwiYmFzZWV4dGVybmFsY2xpZW50XzEiLCJyZXF1aXJlIiwiZXhlY3V0YWJsZV9yZXNwb25zZV8xIiwicGx1Z2dhYmxlX2F1dGhfaGFuZGxlcl8xIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJjb2RlIiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJERUZBVUxUX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMiLCJNSU5JTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMiLCJNQVhJTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMiLCJHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyIsIk1BWElNVU1fRVhFQ1VUQUJMRV9WRVJTSU9OIiwiQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCIsIm9wdGlvbnMiLCJhZGRpdGlvbmFsT3B0aW9ucyIsImNyZWRlbnRpYWxfc291cmNlIiwiZXhlY3V0YWJsZSIsImNvbW1hbmQiLCJ0aW1lb3V0X21pbGxpcyIsInVuZGVmaW5lZCIsInRpbWVvdXRNaWxsaXMiLCJvdXRwdXRGaWxlIiwib3V0cHV0X2ZpbGUiLCJoYW5kbGVyIiwiUGx1Z2dhYmxlQXV0aEhhbmRsZXIiLCJjcmVkZW50aWFsU291cmNlVHlwZSIsInJldHJpZXZlU3ViamVjdFRva2VuIiwicHJvY2VzcyIsImVudiIsImV4ZWN1dGFibGVSZXNwb25zZSIsInJldHJpZXZlQ2FjaGVkUmVzcG9uc2UiLCJlbnZNYXAiLCJNYXAiLCJzZXQiLCJhdWRpZW5jZSIsInN1YmplY3RUb2tlblR5cGUiLCJzZXJ2aWNlQWNjb3VudEVtYWlsIiwiZ2V0U2VydmljZUFjY291bnRFbWFpbCIsInJldHJpZXZlUmVzcG9uc2VGcm9tRXhlY3V0YWJsZSIsInZlcnNpb24iLCJzdWNjZXNzIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JDb2RlIiwiZXhwaXJhdGlvblRpbWUiLCJJbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yIiwiaXNFeHBpcmVkIiwic3ViamVjdFRva2VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PluggableAuthHandler = void 0;\nconst pluggable_auth_client_1 = __webpack_require__(/*! ./pluggable-auth-client */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\nconst executable_response_1 = __webpack_require__(/*! ./executable-response */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/executable-response.js\");\nconst childProcess = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */ class PluggableAuthHandler {\n    /**\n     * Instantiates a PluggableAuthHandler instance using the provided\n     * PluggableAuthHandlerOptions object.\n     */ constructor(options){\n        if (!options.command) {\n            throw new Error(\"No command provided.\");\n        }\n        this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n        this.timeoutMillis = options.timeoutMillis;\n        if (!this.timeoutMillis) {\n            throw new Error(\"No timeoutMillis provided.\");\n        }\n        this.outputFile = options.outputFile;\n    }\n    /**\n     * Calls user provided executable to get a 3rd party subject token and\n     * returns the response.\n     * @param envMap a Map of additional Environment Variables required for\n     *   the executable.\n     * @return A promise that resolves with the executable response.\n     */ retrieveResponseFromExecutable(envMap) {\n        return new Promise((resolve, reject)=>{\n            // Spawn process to run executable using added environment variables.\n            const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {\n                env: {\n                    ...process.env,\n                    ...Object.fromEntries(envMap)\n                }\n            });\n            let output = \"\";\n            // Append stdout to output as executable runs.\n            child.stdout.on(\"data\", (data)=>{\n                output += data;\n            });\n            // Append stderr as executable runs.\n            child.stderr.on(\"data\", (err)=>{\n                output += err;\n            });\n            // Set up a timeout to end the child process and throw an error.\n            const timeout = setTimeout(()=>{\n                // Kill child process and remove listeners so 'close' event doesn't get\n                // read after child process is killed.\n                child.removeAllListeners();\n                child.kill();\n                return reject(new Error(\"The executable failed to finish within the timeout specified.\"));\n            }, this.timeoutMillis);\n            child.on(\"close\", (code)=>{\n                // Cancel timeout if executable closes before timeout is reached.\n                clearTimeout(timeout);\n                if (code === 0) {\n                    // If the executable completed successfully, try to return the parsed response.\n                    try {\n                        const responseJson = JSON.parse(output);\n                        const response = new executable_response_1.ExecutableResponse(responseJson);\n                        return resolve(response);\n                    } catch (error) {\n                        if (error instanceof executable_response_1.ExecutableResponseError) {\n                            return reject(error);\n                        }\n                        return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));\n                    }\n                } else {\n                    return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));\n                }\n            });\n        });\n    }\n    /**\n     * Checks user provided output file for response from previous run of\n     * executable and return the response if it exists, is formatted correctly, and is not expired.\n     */ async retrieveCachedResponse() {\n        if (!this.outputFile || this.outputFile.length === 0) {\n            return undefined;\n        }\n        let filePath;\n        try {\n            filePath = await fs.promises.realpath(this.outputFile);\n        } catch (_a) {\n            // If file path cannot be resolved, return undefined.\n            return undefined;\n        }\n        if (!(await fs.promises.lstat(filePath)).isFile()) {\n            // If path does not lead to file, return undefined.\n            return undefined;\n        }\n        const responseString = await fs.promises.readFile(filePath, {\n            encoding: \"utf8\"\n        });\n        if (responseString === \"\") {\n            return undefined;\n        }\n        try {\n            const responseJson = JSON.parse(responseString);\n            const response = new executable_response_1.ExecutableResponse(responseJson);\n            // Check if response is successful and unexpired.\n            if (response.isValid()) {\n                return new executable_response_1.ExecutableResponse(responseJson);\n            }\n            return undefined;\n        } catch (error) {\n            if (error instanceof executable_response_1.ExecutableResponseError) {\n                throw error;\n            }\n            throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);\n        }\n    }\n    /**\n     * Parses given command string into component array, splitting on spaces unless\n     * spaces are between quotation marks.\n     */ static parseCommand(command) {\n        // Split the command into components by splitting on spaces,\n        // unless spaces are contained in quotation marks.\n        const components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n        if (!components) {\n            throw new Error(`Provided command: \"${command}\" could not be parsed.`);\n        }\n        // Remove quotation marks from the beginning and end of each component if they are present.\n        for(let i = 0; i < components.length; i++){\n            if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n                components[i] = components[i].slice(1, -1);\n            }\n        }\n        return components;\n    }\n}\nexports.PluggableAuthHandler = PluggableAuthHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL3BsdWdnYWJsZS1hdXRoLWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw0QkFBNEIsR0FBRyxLQUFLO0FBQ3BDLE1BQU1HLDBCQUEwQkMsbUJBQU9BLENBQUMsNEhBQXlCO0FBQ2pFLE1BQU1DLHdCQUF3QkQsbUJBQU9BLENBQUMsd0hBQXVCO0FBQzdELE1BQU1FLGVBQWVGLG1CQUFPQSxDQUFDLG9DQUFlO0FBQzVDLE1BQU1HLEtBQUtILG1CQUFPQSxDQUFDLGNBQUk7QUFDdkI7OztDQUdDLEdBQ0QsTUFBTUY7SUFDRjs7O0tBR0MsR0FDRE0sWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLElBQUksQ0FBQ0EsUUFBUUMsT0FBTyxFQUFFO1lBQ2xCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdWLHFCQUFxQlcsWUFBWSxDQUFDSixRQUFRQyxPQUFPO1FBQzFFLElBQUksQ0FBQ0ksYUFBYSxHQUFHTCxRQUFRSyxhQUFhO1FBQzFDLElBQUksQ0FBQyxJQUFJLENBQUNBLGFBQWEsRUFBRTtZQUNyQixNQUFNLElBQUlILE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNJLFVBQVUsR0FBR04sUUFBUU0sVUFBVTtJQUN4QztJQUNBOzs7Ozs7S0FNQyxHQUNEQywrQkFBK0JDLE1BQU0sRUFBRTtRQUNuQyxPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FB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Q0FBQyxDQUFDLCtDQUErQyxFQUFFWSxlQUFlLENBQUM7UUFDOUg7SUFDSjtJQUNBOzs7S0FHQyxHQUNELE9BQU81QyxhQUFhSCxPQUFPLEVBQUU7UUFDekIsNERBQTREO1FBQzVELGtEQUFrRDtRQUNsRCxNQUFNbUQsYUFBYW5ELFFBQVFvRCxLQUFLLENBQUM7UUFDakMsSUFBSSxDQUFDRCxZQUFZO1lBQ2IsTUFBTSxJQUFJbEQsTUFBTSxDQUFDLG1CQUFtQixFQUFFRCxRQUFRLHNCQUFzQixDQUFDO1FBQ3pFO1FBQ0EsMkZBQTJGO1FBQzNGLElBQUssSUFBSXFELElBQUksR0FBR0EsSUFBSUYsV0FBV1osTUFBTSxFQUFFYyxJQUFLO1lBQ3hDLElBQUlGLFVBQVUsQ0FBQ0UsRUFBRSxDQUFDLEVBQUUsS0FBSyxPQUFPRixVQUFVLENBQUNFLEVBQUUsQ0FBQ3hDLEtBQUssQ0FBQyxDQUFDLE9BQU8sS0FBSztnQkFDN0RzQyxVQUFVLENBQUNFLEVBQUUsR0FBR0YsVUFBVSxDQUFDRSxFQUFFLENBQUN4QyxLQUFLLENBQUMsR0FBRyxDQUFDO1lBQzVDO1FBQ0o7UUFDQSxPQUFPc0M7SUFDWDtBQUNKO0FBQ0E3RCw0QkFBNEIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1oYW5kbGVyLmpzPzBkNDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aEhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3BsdWdnYWJsZS1hdXRoLWNsaWVudFwiKTtcbmNvbnN0IGV4ZWN1dGFibGVfcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGFibGUtcmVzcG9uc2VcIik7XG5jb25zdCBjaGlsZFByb2Nlc3MgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuLyoqXG4gKiBBIGhhbmRsZXIgdXNlZCB0byByZXRyaWV2ZSAzcmQgcGFydHkgdG9rZW4gcmVzcG9uc2VzIGZyb20gdXNlciBkZWZpbmVkXG4gKiBleGVjdXRhYmxlcyBhbmQgY2FjaGVkIGZpbGUgb3V0cHV0IGZvciB0aGUgUGx1Z2dhYmxlQXV0aENsaWVudCBjbGFzcy5cbiAqL1xuY2xhc3MgUGx1Z2dhYmxlQXV0aEhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIFBsdWdnYWJsZUF1dGhIYW5kbGVyIGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZFxuICAgICAqIFBsdWdnYWJsZUF1dGhIYW5kbGVyT3B0aW9ucyBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuY29tbWFuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb21tYW5kIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tbWFuZENvbXBvbmVudHMgPSBQbHVnZ2FibGVBdXRoSGFuZGxlci5wYXJzZUNvbW1hbmQob3B0aW9ucy5jb21tYW5kKTtcbiAgICAgICAgdGhpcy50aW1lb3V0TWlsbGlzID0gb3B0aW9ucy50aW1lb3V0TWlsbGlzO1xuICAgICAgICBpZiAoIXRoaXMudGltZW91dE1pbGxpcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0aW1lb3V0TWlsbGlzIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RmlsZSA9IG9wdGlvbnMub3V0cHV0RmlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdXNlciBwcm92aWRlZCBleGVjdXRhYmxlIHRvIGdldCBhIDNyZCBwYXJ0eSBzdWJqZWN0IHRva2VuIGFuZFxuICAgICAqIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBlbnZNYXAgYSBNYXAgb2YgYWRkaXRpb25hbCBFbnZpcm9ubWVudCBWYXJpYWJsZXMgcmVxdWlyZWQgZm9yXG4gICAgICogICB0aGUgZXhlY3V0YWJsZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGV4ZWN1dGFibGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgcmV0cmlldmVSZXNwb25zZUZyb21FeGVjdXRhYmxlKGVudk1hcCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gU3Bhd24gcHJvY2VzcyB0byBydW4gZXhlY3V0YWJsZSB1c2luZyBhZGRlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkUHJvY2Vzcy5zcGF3bih0aGlzLmNvbW1hbmRDb21wb25lbnRzWzBdLCB0aGlzLmNvbW1hbmRDb21wb25lbnRzLnNsaWNlKDEpLCB7XG4gICAgICAgICAgICAgICAgZW52OiB7IC4uLnByb2Nlc3MuZW52LCAuLi5PYmplY3QuZnJvbUVudHJpZXMoZW52TWFwKSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgICAgICAvLyBBcHBlbmQgc3Rkb3V0IHRvIG91dHB1dCBhcyBleGVjdXRhYmxlIHJ1bnMuXG4gICAgICAgICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBkYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBcHBlbmQgc3RkZXJyIGFzIGV4ZWN1dGFibGUgcnVucy5cbiAgICAgICAgICAgIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgYSB0aW1lb3V0IHRvIGVuZCB0aGUgY2hpbGQgcHJvY2VzcyBhbmQgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gS2lsbCBjaGlsZCBwcm9jZXNzIGFuZCByZW1vdmUgbGlzdGVuZXJzIHNvICdjbG9zZScgZXZlbnQgZG9lc24ndCBnZXRcbiAgICAgICAgICAgICAgICAvLyByZWFkIGFmdGVyIGNoaWxkIHByb2Nlc3MgaXMga2lsbGVkLlxuICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGNoaWxkLmtpbGwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignVGhlIGV4ZWN1dGFibGUgZmFpbGVkIHRvIGZpbmlzaCB3aXRoaW4gdGhlIHRpbWVvdXQgc3BlY2lmaWVkLicpKTtcbiAgICAgICAgICAgIH0sIHRoaXMudGltZW91dE1pbGxpcyk7XG4gICAgICAgICAgICBjaGlsZC5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENhbmNlbCB0aW1lb3V0IGlmIGV4ZWN1dGFibGUgY2xvc2VzIGJlZm9yZSB0aW1lb3V0IGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBleGVjdXRhYmxlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIHRyeSB0byByZXR1cm4gdGhlIHBhcnNlZCByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IGV4ZWN1dGFibGVfcmVzcG9uc2VfMS5FeGVjdXRhYmxlUmVzcG9uc2UocmVzcG9uc2VKc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGV4ZWN1dGFibGVfcmVzcG9uc2VfMS5FeGVjdXRhYmxlUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKGBUaGUgZXhlY3V0YWJsZSByZXR1cm5lZCBhbiBpbnZhbGlkIHJlc3BvbnNlOiAke291dHB1dH1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IHBsdWdnYWJsZV9hdXRoX2NsaWVudF8xLkV4ZWN1dGFibGVFcnJvcihvdXRwdXQsIGNvZGUudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHVzZXIgcHJvdmlkZWQgb3V0cHV0IGZpbGUgZm9yIHJlc3BvbnNlIGZyb20gcHJldmlvdXMgcnVuIG9mXG4gICAgICogZXhlY3V0YWJsZSBhbmQgcmV0dXJuIHRoZSByZXNwb25zZSBpZiBpdCBleGlzdHMsIGlzIGZvcm1hdHRlZCBjb3JyZWN0bHksIGFuZCBpcyBub3QgZXhwaXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZUNhY2hlZFJlc3BvbnNlKCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0RmlsZSB8fCB0aGlzLm91dHB1dEZpbGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWxlUGF0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbGVQYXRoID0gYXdhaXQgZnMucHJvbWlzZXMucmVhbHBhdGgodGhpcy5vdXRwdXRGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIElmIGZpbGUgcGF0aCBjYW5ub3QgYmUgcmVzb2x2ZWQsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IGZzLnByb21pc2VzLmxzdGF0KGZpbGVQYXRoKSkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgIC8vIElmIHBhdGggZG9lcyBub3QgbGVhZCB0byBmaWxlLCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZVN0cmluZyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKGZpbGVQYXRoLCB7XG4gICAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlU3RyaW5nID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VKc29uID0gSlNPTi5wYXJzZShyZXNwb25zZVN0cmluZyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuRXhlY3V0YWJsZVJlc3BvbnNlKHJlc3BvbnNlSnNvbik7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiByZXNwb25zZSBpcyBzdWNjZXNzZnVsIGFuZCB1bmV4cGlyZWQuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuRXhlY3V0YWJsZVJlc3BvbnNlKHJlc3BvbnNlSnNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKGBUaGUgb3V0cHV0IGZpbGUgY29udGFpbmVkIGFuIGludmFsaWQgcmVzcG9uc2U6ICR7cmVzcG9uc2VTdHJpbmd9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGdpdmVuIGNvbW1hbmQgc3RyaW5nIGludG8gY29tcG9uZW50IGFycmF5LCBzcGxpdHRpbmcgb24gc3BhY2VzIHVubGVzc1xuICAgICAqIHNwYWNlcyBhcmUgYmV0d2VlbiBxdW90YXRpb24gbWFya3MuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlQ29tbWFuZChjb21tYW5kKSB7XG4gICAgICAgIC8vIFNwbGl0IHRoZSBjb21tYW5kIGludG8gY29tcG9uZW50cyBieSBzcGxpdHRpbmcgb24gc3BhY2VzLFxuICAgICAgICAvLyB1bmxlc3Mgc3BhY2VzIGFyZSBjb250YWluZWQgaW4gcXVvdGF0aW9uIG1hcmtzLlxuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gY29tbWFuZC5tYXRjaCgvKD86W15cXHNcIl0rfFwiW15cIl0qXCIpKy9nKTtcbiAgICAgICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVkIGNvbW1hbmQ6IFwiJHtjb21tYW5kfVwiIGNvdWxkIG5vdCBiZSBwYXJzZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHF1b3RhdGlvbiBtYXJrcyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBlYWNoIGNvbXBvbmVudCBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzW2ldWzBdID09PSAnXCInICYmIGNvbXBvbmVudHNbaV0uc2xpY2UoLTEpID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpXSA9IGNvbXBvbmVudHNbaV0uc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn1cbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aEhhbmRsZXIgPSBQbHVnZ2FibGVBdXRoSGFuZGxlcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBsdWdnYWJsZUF1dGhIYW5kbGVyIiwicGx1Z2dhYmxlX2F1dGhfY2xpZW50XzEiLCJyZXF1aXJlIiwiZXhlY3V0YWJsZV9yZXNwb25zZV8xIiwiY2hpbGRQcm9jZXNzIiwiZnMiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJjb21tYW5kIiwiRXJyb3IiLCJjb21tYW5kQ29tcG9uZW50cyIsInBhcnNlQ29tbWFuZCIsInRpbWVvdXRNaWxsaXMiLCJvdXRwdXRGaWxlIiwicmV0cmlldmVSZXNwb25zZUZyb21FeGVjdXRhYmxlIiwiZW52TWFwIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjaGlsZCIsInNwYXduIiwic2xpY2UiLCJlbnYiLCJwcm9jZXNzIiwiZnJvbUVudHJpZXMiLCJvdXRwdXQiLCJzdGRvdXQiLCJvbiIsImRhdGEiLCJzdGRlcnIiLCJlcnIiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsInJlbW92ZUFsbExpc3RlbmVycyIsImtpbGwiLCJjb2RlIiwiY2xlYXJUaW1lb3V0IiwicmVzcG9uc2VKc29uIiwiSlNPTiIsInBhcnNlIiwicmVzcG9uc2UiLCJFeGVjdXRhYmxlUmVzcG9uc2UiLCJlcnJvciIsIkV4ZWN1dGFibGVSZXNwb25zZUVycm9yIiwiRXhlY3V0YWJsZUVycm9yIiwidG9TdHJpbmciLCJyZXRyaWV2ZUNhY2hlZFJlc3BvbnNlIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiZmlsZVBhdGgiLCJwcm9taXNlcyIsInJlYWxwYXRoIiwiX2EiLCJsc3RhdCIsImlzRmlsZSIsInJlc3BvbnNlU3RyaW5nIiwicmVhZEZpbGUiLCJlbmNvZGluZyIsImlzVmFsaWQiLCJjb21wb25lbnRzIiwibWF0Y2giLCJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/refreshclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/refreshclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.UserRefreshClient = exports.USER_REFRESH_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nexports.USER_REFRESH_ACCOUNT_TYPE = \"authorized_user\";\nclass UserRefreshClient extends oauth2client_1.OAuth2Client {\n    constructor(optionsOrClientId, clientSecret, refreshToken, eagerRefreshThresholdMillis, forceRefreshOnFailure){\n        const opts = optionsOrClientId && typeof optionsOrClientId === \"object\" ? optionsOrClientId : {\n            clientId: optionsOrClientId,\n            clientSecret,\n            refreshToken,\n            eagerRefreshThresholdMillis,\n            forceRefreshOnFailure\n        };\n        super(opts);\n        this._refreshToken = opts.refreshToken;\n        this.credentials.refresh_token = opts.refreshToken;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken An ignored refreshToken..\n     * @param callback Optional callback.\n     */ async refreshTokenNoCache(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        return super.refreshTokenNoCache(this._refreshToken);\n    }\n    /**\n     * Create a UserRefreshClient credentials instance using the given input\n     * options.\n     * @param json The input object.\n     */ fromJSON(json) {\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing the user refresh token\");\n        }\n        if (json.type !== \"authorized_user\") {\n            throw new Error('The incoming JSON object does not have the \"authorized_user\" type');\n        }\n        if (!json.client_id) {\n            throw new Error(\"The incoming JSON object does not contain a client_id field\");\n        }\n        if (!json.client_secret) {\n            throw new Error(\"The incoming JSON object does not contain a client_secret field\");\n        }\n        if (!json.refresh_token) {\n            throw new Error(\"The incoming JSON object does not contain a refresh_token field\");\n        }\n        this._clientId = json.client_id;\n        this._clientSecret = json.client_secret;\n        this._refreshToken = json.refresh_token;\n        this.credentials.refresh_token = json.refresh_token;\n        this.quotaProjectId = json.quota_project_id;\n        this.universeDomain = json.universe_domain || this.universeDomain;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(()=>callback(), callback);\n        } else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    async fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                return reject(new Error(\"Must pass in a stream containing the user refresh token.\"));\n            }\n            let s = \"\";\n            inputStream.setEncoding(\"utf8\").on(\"error\", reject).on(\"data\", (chunk)=>s += chunk).on(\"end\", ()=>{\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    return resolve();\n                } catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n}\nexports.UserRefreshClient = UserRefreshClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL3JlZnJlc2hjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBR0EsaUNBQWlDLEdBQUcsS0FBSztBQUNyRSxNQUFNSSxpQkFBaUJDLG1CQUFPQSxDQUFDLDBHQUFnQjtBQUMvQ0wsaUNBQWlDLEdBQUc7QUFDcEMsTUFBTUUsMEJBQTBCRSxlQUFlRSxZQUFZO0lBQ3ZEQyxZQUFZQyxpQkFBaUIsRUFBRUMsWUFBWSxFQUFFQyxZQUFZLEVBQUVDLDJCQUEyQixFQUFFQyxxQkFBcUIsQ0FBRTtRQUMzRyxNQUFNQyxPQUFPTCxxQkFBcUIsT0FBT0Esc0JBQXNCLFdBQ3pEQSxvQkFDQTtZQUNFTSxVQUFVTjtZQUNWQztZQUNBQztZQUNBQztZQUNBQztRQUNKO1FBQ0osS0FBSyxDQUFDQztRQUNOLElBQUksQ0FBQ0UsYUFBYSxHQUFHRixLQUFLSCxZQUFZO1FBQ3RDLElBQUksQ0FBQ00sV0FBVyxDQUFDQyxhQUFhLEdBQUdKLEtBQUtILFlBQVk7SUFDdEQ7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTVEsb0JBQ04sNkRBQTZEO0lBQzdEUixZQUFZLEVBQUU7UUFDVixPQUFPLEtBQUssQ0FBQ1Esb0JBQW9CLElBQUksQ0FBQ0gsYUFBYTtJQUN2RDtJQUNBOzs7O0tBSUMsR0FDREksU0FBU0MsSUFBSSxFQUFFO1FBQ1gsSUFBSSxDQUFDQSxNQUFNO1lBQ1AsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSUQsS0FBS0UsSUFBSSxLQUFLLG1CQUFtQjtZQUNqQyxNQUFNLElBQUlELE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNELEtBQUtHLFNBQVMsRUFBRTtZQUNqQixNQUFNLElBQUlGLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNELEtBQUtJLGFBQWEsRUFBRTtZQUNyQixNQUFNLElBQUlILE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNELEtBQUtILGFBQWEsRUFBRTtZQUNyQixNQUFNLElBQUlJLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNJLFNBQVMsR0FBR0wsS0FBS0csU0FBUztRQUMvQixJQUFJLENBQUNHLGFBQWEsR0FBR04sS0FBS0ksYUFBYTtRQUN2QyxJQUFJLENBQUNULGFBQWEsR0FBR0ssS0FBS0gsYUFBYTtRQUN2QyxJQUFJLENBQUNELFdBQVcsQ0FBQ0MsYUFBYSxHQUFHRyxLQUFLSCxhQUFhO1FBQ25ELElBQUksQ0FBQ1UsY0FBYyxHQUFHUCxLQUFLUSxnQkFBZ0I7UUFDM0MsSUFBSSxDQUFDQyxjQUFjLEdBQUdULEtBQUtVLGVBQWUsSUFBSSxJQUFJLENBQUNELGNBQWM7SUFDckU7SUFDQUUsV0FBV0MsV0FBVyxFQUFFQyxRQUFRLEVBQUU7UUFDOUIsSUFBSUEsVUFBVTtZQUNWLElBQUksQ0FBQ0MsZUFBZSxDQUFDRixhQUFhRyxJQUFJLENBQUMsSUFBTUYsWUFBWUE7UUFDN0QsT0FDSztZQUNELE9BQU8sSUFBSSxDQUFDQyxlQUFlLENBQUNGO1FBQ2hDO0lBQ0o7SUFDQSxNQUFNRSxnQkFBZ0JGLFdBQVcsRUFBRTtRQUMvQixPQUFPLElBQUlJLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekIsSUFBSSxDQUFDTixhQUFhO2dCQUNkLE9BQU9NLE9BQU8sSUFBSWpCLE1BQU07WUFDNUI7WUFDQSxJQUFJa0IsSUFBSTtZQUNSUCxZQUNLUSxXQUFXLENBQUMsUUFDWkMsRUFBRSxDQUFDLFNBQVNILFFBQ1pHLEVBQUUsQ0FBQyxRQUFRQyxDQUFBQSxRQUFVSCxLQUFLRyxPQUMxQkQsRUFBRSxDQUFDLE9BQU87Z0JBQ1gsSUFBSTtvQkFDQSxNQUFNRSxPQUFPQyxLQUFLQyxLQUFLLENBQUNOO29CQUN4QixJQUFJLENBQUNwQixRQUFRLENBQUN3QjtvQkFDZCxPQUFPTjtnQkFDWCxFQUNBLE9BQU9TLEtBQUs7b0JBQ1IsT0FBT1IsT0FBT1E7Z0JBQ2xCO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFDQTlDLHlCQUF5QixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb3RpZnktdG8teW91dHViZS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL3JlZnJlc2hjbGllbnQuanM/YmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE1IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Vc2VyUmVmcmVzaENsaWVudCA9IGV4cG9ydHMuVVNFUl9SRUZSRVNIX0FDQ09VTlRfVFlQRSA9IHZvaWQgMDtcbmNvbnN0IG9hdXRoMmNsaWVudF8xID0gcmVxdWlyZShcIi4vb2F1dGgyY2xpZW50XCIpO1xuZXhwb3J0cy5VU0VSX1JFRlJFU0hfQUNDT1VOVF9UWVBFID0gJ2F1dGhvcml6ZWRfdXNlcic7XG5jbGFzcyBVc2VyUmVmcmVzaENsaWVudCBleHRlbmRzIG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9uc09yQ2xpZW50SWQsIGNsaWVudFNlY3JldCwgcmVmcmVzaFRva2VuLCBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMsIGZvcmNlUmVmcmVzaE9uRmFpbHVyZSkge1xuICAgICAgICBjb25zdCBvcHRzID0gb3B0aW9uc09yQ2xpZW50SWQgJiYgdHlwZW9mIG9wdGlvbnNPckNsaWVudElkID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBvcHRpb25zT3JDbGllbnRJZFxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IG9wdGlvbnNPckNsaWVudElkLFxuICAgICAgICAgICAgICAgIGNsaWVudFNlY3JldCxcbiAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW4sXG4gICAgICAgICAgICAgICAgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzLFxuICAgICAgICAgICAgICAgIGZvcmNlUmVmcmVzaE9uRmFpbHVyZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBvcHRzLnJlZnJlc2hUb2tlbjtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuID0gb3B0cy5yZWZyZXNoVG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gQW4gaWdub3JlZCByZWZyZXNoVG9rZW4uLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW5Ob0NhY2hlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICByZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlZnJlc2hUb2tlbk5vQ2FjaGUodGhpcy5fcmVmcmVzaFRva2VuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgVXNlclJlZnJlc2hDbGllbnQgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGlucHV0XG4gICAgICogb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ganNvbiBUaGUgaW5wdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcGFzcyBpbiBhIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVzZXIgcmVmcmVzaCB0b2tlbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnR5cGUgIT09ICdhdXRob3JpemVkX3VzZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBoYXZlIHRoZSBcImF1dGhvcml6ZWRfdXNlclwiIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uY2xpZW50X2lkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgY2xpZW50X2lkIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLmNsaWVudF9zZWNyZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSBjbGllbnRfc2VjcmV0IGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSByZWZyZXNoX3Rva2VuIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xpZW50SWQgPSBqc29uLmNsaWVudF9pZDtcbiAgICAgICAgdGhpcy5fY2xpZW50U2VjcmV0ID0ganNvbi5jbGllbnRfc2VjcmV0O1xuICAgICAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBqc29uLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbiA9IGpzb24ucmVmcmVzaF90b2tlbjtcbiAgICAgICAgdGhpcy5xdW90YVByb2plY3RJZCA9IGpzb24ucXVvdGFfcHJvamVjdF9pZDtcbiAgICAgICAgdGhpcy51bml2ZXJzZURvbWFpbiA9IGpzb24udW5pdmVyc2VfZG9tYWluIHx8IHRoaXMudW5pdmVyc2VEb21haW47XG4gICAgfVxuICAgIGZyb21TdHJlYW0oaW5wdXRTdHJlYW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5mcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pLnRoZW4oKCkgPT4gY2FsbGJhY2soKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIHVzZXIgcmVmcmVzaCB0b2tlbi4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcyA9ICcnO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW1cbiAgICAgICAgICAgICAgICAuc2V0RW5jb2RpbmcoJ3V0ZjgnKVxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAgICAgLm9uKCdkYXRhJywgY2h1bmsgPT4gKHMgKz0gY2h1bmspKVxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyb21KU09OKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Vc2VyUmVmcmVzaENsaWVudCA9IFVzZXJSZWZyZXNoQ2xpZW50O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVXNlclJlZnJlc2hDbGllbnQiLCJVU0VSX1JFRlJFU0hfQUNDT1VOVF9UWVBFIiwib2F1dGgyY2xpZW50XzEiLCJyZXF1aXJlIiwiT0F1dGgyQ2xpZW50IiwiY29uc3RydWN0b3IiLCJvcHRpb25zT3JDbGllbnRJZCIsImNsaWVudFNlY3JldCIsInJlZnJlc2hUb2tlbiIsImVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyIsImZvcmNlUmVmcmVzaE9uRmFpbHVyZSIsIm9wdHMiLCJjbGllbnRJZCIsIl9yZWZyZXNoVG9rZW4iLCJjcmVkZW50aWFscyIsInJlZnJlc2hfdG9rZW4iLCJyZWZyZXNoVG9rZW5Ob0NhY2hlIiwiZnJvbUpTT04iLCJqc29uIiwiRXJyb3IiLCJ0eXBlIiwiY2xpZW50X2lkIiwiY2xpZW50X3NlY3JldCIsIl9jbGllbnRJZCIsIl9jbGllbnRTZWNyZXQiLCJxdW90YVByb2plY3RJZCIsInF1b3RhX3Byb2plY3RfaWQiLCJ1bml2ZXJzZURvbWFpbiIsInVuaXZlcnNlX2RvbWFpbiIsImZyb21TdHJlYW0iLCJpbnB1dFN0cmVhbSIsImNhbGxiYWNrIiwiZnJvbVN0cmVhbUFzeW5jIiwidGhlbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicyIsInNldEVuY29kaW5nIiwib24iLCJjaHVuayIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJlcnIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/auth/stscredentials.js":
/*!***************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/stscredentials.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StsCredentials = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(action-browser)/./node_modules/gaxios/build/src/index.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(action-browser)/./node_modules/google-auth-library/build/src/transporters.js\");\nconst oauth2common_1 = __webpack_require__(/*! ./oauth2common */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\");\n/**\n * Implements the OAuth 2.0 token exchange based on\n * https://tools.ietf.org/html/rfc8693\n */ class StsCredentials extends oauth2common_1.OAuthClientAuthHandler {\n    /**\n     * Initializes an STS credentials instance.\n     * @param tokenExchangeEndpoint The token exchange endpoint.\n     * @param clientAuthentication The client authentication credentials if\n     *   available.\n     */ constructor(tokenExchangeEndpoint, clientAuthentication){\n        super(clientAuthentication);\n        this.tokenExchangeEndpoint = tokenExchangeEndpoint;\n        this.transporter = new transporters_1.DefaultTransporter();\n    }\n    /**\n     * Exchanges the provided token for another type of token based on the\n     * rfc8693 spec.\n     * @param stsCredentialsOptions The token exchange options used to populate\n     *   the token exchange request.\n     * @param additionalHeaders Optional additional headers to pass along the\n     *   request.\n     * @param options Optional additional GCP-specific non-spec defined options\n     *   to send with the request.\n     *   Example: `&options=${encodeUriComponent(JSON.stringified(options))}`\n     * @return A promise that resolves with the token exchange response containing\n     *   the requested token and its expiration time.\n     */ async exchangeToken(stsCredentialsOptions, additionalHeaders, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    options) {\n        var _a, _b, _c;\n        const values = {\n            grant_type: stsCredentialsOptions.grantType,\n            resource: stsCredentialsOptions.resource,\n            audience: stsCredentialsOptions.audience,\n            scope: (_a = stsCredentialsOptions.scope) === null || _a === void 0 ? void 0 : _a.join(\" \"),\n            requested_token_type: stsCredentialsOptions.requestedTokenType,\n            subject_token: stsCredentialsOptions.subjectToken,\n            subject_token_type: stsCredentialsOptions.subjectTokenType,\n            actor_token: (_b = stsCredentialsOptions.actingParty) === null || _b === void 0 ? void 0 : _b.actorToken,\n            actor_token_type: (_c = stsCredentialsOptions.actingParty) === null || _c === void 0 ? void 0 : _c.actorTokenType,\n            // Non-standard GCP-specific options.\n            options: options && JSON.stringify(options)\n        };\n        // Remove undefined fields.\n        Object.keys(values).forEach((key)=>{\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (typeof values[key] === \"undefined\") {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                delete values[key];\n            }\n        });\n        const headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        };\n        // Inject additional STS headers if available.\n        Object.assign(headers, additionalHeaders || {});\n        const opts = {\n            url: this.tokenExchangeEndpoint.toString(),\n            method: \"POST\",\n            headers,\n            data: querystring.stringify(values),\n            responseType: \"json\"\n        };\n        // Apply OAuth client authentication.\n        this.applyClientAuthenticationOptions(opts);\n        try {\n            const response = await this.transporter.request(opts);\n            // Successful response.\n            const stsSuccessfulResponse = response.data;\n            stsSuccessfulResponse.res = response;\n            return stsSuccessfulResponse;\n        } catch (error) {\n            // Translate error to OAuthError.\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, // Preserve other fields from the original error.\n                error);\n            }\n            // Request could fail before the server responds.\n            throw error;\n        }\n    }\n}\nexports.StsCredentials = StsCredentials;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL3N0c2NyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUcsS0FBSztBQUM5QixNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyx5RUFBUTtBQUNqQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUN6QyxNQUFNRSxpQkFBaUJGLG1CQUFPQSxDQUFDLHNHQUFpQjtBQUNoRCxNQUFNRyxpQkFBaUJILG1CQUFPQSxDQUFDLDBHQUFnQjtBQUMvQzs7O0NBR0MsR0FDRCxNQUFNRix1QkFBdUJLLGVBQWVDLHNCQUFzQjtJQUM5RDs7Ozs7S0FLQyxHQUNEQyxZQUFZQyxxQkFBcUIsRUFBRUMsb0JBQW9CLENBQUU7UUFDckQsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0QscUJBQXFCLEdBQUdBO1FBQzdCLElBQUksQ0FBQ0UsV0FBVyxHQUFHLElBQUlOLGVBQWVPLGtCQUFrQjtJQUM1RDtJQUNBOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNELE1BQU1DLGNBQWNDLHFCQUFxQixFQUFFQyxpQkFBaUIsRUFDNUQsOERBQThEO0lBQzlEQyxPQUFPLEVBQUU7UUFDTCxJQUFJQyxJQUFJQyxJQUFJQztRQUNaLE1BQU1DLFNBQVM7WUFDWEMsWUFBWVAsc0JBQXNCUSxTQUFTO1lBQzNDQyxVQUFVVCxzQkFBc0JTLFFBQVE7WUFDeENDLFVBQVVWLHNCQUFzQlUsUUFBUTtZQUN4Q0MsT0FBTyxDQUFDUixLQUFLSCxzQkFBc0JXLEtBQUssTUFBTSxRQUFRUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdTLElBQUksQ0FBQztZQUN2RkMsc0JBQXNCYixzQkFBc0JjLGtCQUFrQjtZQUM5REMsZUFBZWYsc0JBQXNCZ0IsWUFBWTtZQUNqREMsb0JBQW9CakIsc0JBQXNCa0IsZ0JBQWdCO1lBQzFEQyxhQUFhLENBQUNmLEtBQUtKLHNCQUFzQm9CLFdBQVcsTUFBTSxRQUFRaEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaUIsVUFBVTtZQUN4R0Msa0JBQWtCLENBQUNqQixLQUFLTCxzQkFBc0JvQixXQUFXLE1BQU0sUUFBUWYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa0IsY0FBYztZQUNqSCxxQ0FBcUM7WUFDckNyQixTQUFTQSxXQUFXc0IsS0FBS0MsU0FBUyxDQUFDdkI7UUFDdkM7UUFDQSwyQkFBMkI7UUFDM0JuQixPQUFPMkMsSUFBSSxDQUFDcEIsUUFBUXFCLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDeEIsOERBQThEO1lBQzlELElBQUksT0FBT3RCLE1BQU0sQ0FBQ3NCLElBQUksS0FBSyxhQUFhO2dCQUNwQyw4REFBOEQ7Z0JBQzlELE9BQU90QixNQUFNLENBQUNzQixJQUFJO1lBQ3RCO1FBQ0o7UUFDQSxNQUFNQyxVQUFVO1lBQ1osZ0JBQWdCO1FBQ3BCO1FBQ0EsOENBQThDO1FBQzlDOUMsT0FBTytDLE1BQU0sQ0FBQ0QsU0FBUzVCLHFCQUFxQixDQUFDO1FBQzdDLE1BQU04QixPQUFPO1lBQ1RDLEtBQUssSUFBSSxDQUFDckMscUJBQXFCLENBQUNzQyxRQUFRO1lBQ3hDQyxRQUFRO1lBQ1JMO1lBQ0FNLE1BQU03QyxZQUFZbUMsU0FBUyxDQUFDbkI7WUFDNUI4QixjQUFjO1FBQ2xCO1FBQ0EscUNBQXFDO1FBQ3JDLElBQUksQ0FBQ0MsZ0NBQWdDLENBQUNOO1FBQ3RDLElBQUk7WUFDQSxNQUFNTyxXQUFXLE1BQU0sSUFBSSxDQUFDekMsV0FBVyxDQUFDMEMsT0FBTyxDQUFDUjtZQUNoRCx1QkFBdUI7WUFDdkIsTUFBTVMsd0JBQXdCRixTQUFTSCxJQUFJO1lBQzNDSyxzQkFBc0JDLEdBQUcsR0FBR0g7WUFDNUIsT0FBT0U7UUFDWCxFQUNBLE9BQU9FLE9BQU87WUFDVixpQ0FBaUM7WUFDakMsSUFBSUEsaUJBQWlCdEQsU0FBU3VELFdBQVcsSUFBSUQsTUFBTUosUUFBUSxFQUFFO2dCQUN6RCxNQUFNLENBQUMsR0FBRzlDLGVBQWVvRCw4QkFBOEIsRUFBRUYsTUFBTUosUUFBUSxDQUFDSCxJQUFJLEVBQzVFLGlEQUFpRDtnQkFDakRPO1lBQ0o7WUFDQSxpREFBaUQ7WUFDakQsTUFBTUE7UUFDVjtJQUNKO0FBQ0o7QUFDQXpELHNCQUFzQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb3RpZnktdG8teW91dHViZS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL3N0c2NyZWRlbnRpYWxzLmpzP2I3ZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RzQ3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IHRyYW5zcG9ydGVyc18xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydGVyc1wiKTtcbmNvbnN0IG9hdXRoMmNvbW1vbl8xID0gcmVxdWlyZShcIi4vb2F1dGgyY29tbW9uXCIpO1xuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBPQXV0aCAyLjAgdG9rZW4gZXhjaGFuZ2UgYmFzZWQgb25cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4NjkzXG4gKi9cbmNsYXNzIFN0c0NyZWRlbnRpYWxzIGV4dGVuZHMgb2F1dGgyY29tbW9uXzEuT0F1dGhDbGllbnRBdXRoSGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gU1RTIGNyZWRlbnRpYWxzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB0b2tlbkV4Y2hhbmdlRW5kcG9pbnQgVGhlIHRva2VuIGV4Y2hhbmdlIGVuZHBvaW50LlxuICAgICAqIEBwYXJhbSBjbGllbnRBdXRoZW50aWNhdGlvbiBUaGUgY2xpZW50IGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGlmXG4gICAgICogICBhdmFpbGFibGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9rZW5FeGNoYW5nZUVuZHBvaW50LCBjbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICBzdXBlcihjbGllbnRBdXRoZW50aWNhdGlvbik7XG4gICAgICAgIHRoaXMudG9rZW5FeGNoYW5nZUVuZHBvaW50ID0gdG9rZW5FeGNoYW5nZUVuZHBvaW50O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydGVyID0gbmV3IHRyYW5zcG9ydGVyc18xLkRlZmF1bHRUcmFuc3BvcnRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNoYW5nZXMgdGhlIHByb3ZpZGVkIHRva2VuIGZvciBhbm90aGVyIHR5cGUgb2YgdG9rZW4gYmFzZWQgb24gdGhlXG4gICAgICogcmZjODY5MyBzcGVjLlxuICAgICAqIEBwYXJhbSBzdHNDcmVkZW50aWFsc09wdGlvbnMgVGhlIHRva2VuIGV4Y2hhbmdlIG9wdGlvbnMgdXNlZCB0byBwb3B1bGF0ZVxuICAgICAqICAgdGhlIHRva2VuIGV4Y2hhbmdlIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxIZWFkZXJzIE9wdGlvbmFsIGFkZGl0aW9uYWwgaGVhZGVycyB0byBwYXNzIGFsb25nIHRoZVxuICAgICAqICAgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIEdDUC1zcGVjaWZpYyBub24tc3BlYyBkZWZpbmVkIG9wdGlvbnNcbiAgICAgKiAgIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdC5cbiAgICAgKiAgIEV4YW1wbGU6IGAmb3B0aW9ucz0ke2VuY29kZVVyaUNvbXBvbmVudChKU09OLnN0cmluZ2lmaWVkKG9wdGlvbnMpKX1gXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0b2tlbiBleGNoYW5nZSByZXNwb25zZSBjb250YWluaW5nXG4gICAgICogICB0aGUgcmVxdWVzdGVkIHRva2VuIGFuZCBpdHMgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAqL1xuICAgIGFzeW5jIGV4Y2hhbmdlVG9rZW4oc3RzQ3JlZGVudGlhbHNPcHRpb25zLCBhZGRpdGlvbmFsSGVhZGVycywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICAgICAgICBncmFudF90eXBlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMuZ3JhbnRUeXBlLFxuICAgICAgICAgICAgcmVzb3VyY2U6IHN0c0NyZWRlbnRpYWxzT3B0aW9ucy5yZXNvdXJjZSxcbiAgICAgICAgICAgIGF1ZGllbmNlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMuYXVkaWVuY2UsXG4gICAgICAgICAgICBzY29wZTogKF9hID0gc3RzQ3JlZGVudGlhbHNPcHRpb25zLnNjb3BlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euam9pbignICcpLFxuICAgICAgICAgICAgcmVxdWVzdGVkX3Rva2VuX3R5cGU6IHN0c0NyZWRlbnRpYWxzT3B0aW9ucy5yZXF1ZXN0ZWRUb2tlblR5cGUsXG4gICAgICAgICAgICBzdWJqZWN0X3Rva2VuOiBzdHNDcmVkZW50aWFsc09wdGlvbnMuc3ViamVjdFRva2VuLFxuICAgICAgICAgICAgc3ViamVjdF90b2tlbl90eXBlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMuc3ViamVjdFRva2VuVHlwZSxcbiAgICAgICAgICAgIGFjdG9yX3Rva2VuOiAoX2IgPSBzdHNDcmVkZW50aWFsc09wdGlvbnMuYWN0aW5nUGFydHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY3RvclRva2VuLFxuICAgICAgICAgICAgYWN0b3JfdG9rZW5fdHlwZTogKF9jID0gc3RzQ3JlZGVudGlhbHNPcHRpb25zLmFjdGluZ1BhcnR5KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWN0b3JUb2tlblR5cGUsXG4gICAgICAgICAgICAvLyBOb24tc3RhbmRhcmQgR0NQLXNwZWNpZmljIG9wdGlvbnMuXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zICYmIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBSZW1vdmUgdW5kZWZpbmVkIGZpZWxkcy5cbiAgICAgICAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEluamVjdCBhZGRpdGlvbmFsIFNUUyBoZWFkZXJzIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBhZGRpdGlvbmFsSGVhZGVycyB8fCB7fSk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICB1cmw6IHRoaXMudG9rZW5FeGNoYW5nZUVuZHBvaW50LnRvU3RyaW5nKCksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhOiBxdWVyeXN0cmluZy5zdHJpbmdpZnkodmFsdWVzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICAvLyBBcHBseSBPQXV0aCBjbGllbnQgYXV0aGVudGljYXRpb24uXG4gICAgICAgIHRoaXMuYXBwbHlDbGllbnRBdXRoZW50aWNhdGlvbk9wdGlvbnMob3B0cyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAgICAgICAgICBjb25zdCBzdHNTdWNjZXNzZnVsUmVzcG9uc2UgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgc3RzU3VjY2Vzc2Z1bFJlc3BvbnNlLnJlcyA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIHN0c1N1Y2Nlc3NmdWxSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBlcnJvciB0byBPQXV0aEVycm9yLlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZ2F4aW9zXzEuR2F4aW9zRXJyb3IgJiYgZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgb2F1dGgyY29tbW9uXzEuZ2V0RXJyb3JGcm9tT0F1dGhFcnJvclJlc3BvbnNlKShlcnJvci5yZXNwb25zZS5kYXRhLCBcbiAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBvdGhlciBmaWVsZHMgZnJvbSB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gICAgICAgICAgICAgICAgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVxdWVzdCBjb3VsZCBmYWlsIGJlZm9yZSB0aGUgc2VydmVyIHJlc3BvbmRzLlxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlN0c0NyZWRlbnRpYWxzID0gU3RzQ3JlZGVudGlhbHM7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdHNDcmVkZW50aWFscyIsImdheGlvc18xIiwicmVxdWlyZSIsInF1ZXJ5c3RyaW5nIiwidHJhbnNwb3J0ZXJzXzEiLCJvYXV0aDJjb21tb25fMSIsIk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsInRva2VuRXhjaGFuZ2VFbmRwb2ludCIsImNsaWVudEF1dGhlbnRpY2F0aW9uIiwidHJhbnNwb3J0ZXIiLCJEZWZhdWx0VHJhbnNwb3J0ZXIiLCJleGNoYW5nZVRva2VuIiwic3RzQ3JlZGVudGlhbHNPcHRpb25zIiwiYWRkaXRpb25hbEhlYWRlcnMiLCJvcHRpb25zIiwiX2EiLCJfYiIsIl9jIiwidmFsdWVzIiwiZ3JhbnRfdHlwZSIsImdyYW50VHlwZSIsInJlc291cmNlIiwiYXVkaWVuY2UiLCJzY29wZSIsImpvaW4iLCJyZXF1ZXN0ZWRfdG9rZW5fdHlwZSIsInJlcXVlc3RlZFRva2VuVHlwZSIsInN1YmplY3RfdG9rZW4iLCJzdWJqZWN0VG9rZW4iLCJzdWJqZWN0X3Rva2VuX3R5cGUiLCJzdWJqZWN0VG9rZW5UeXBlIiwiYWN0b3JfdG9rZW4iLCJhY3RpbmdQYXJ0eSIsImFjdG9yVG9rZW4iLCJhY3Rvcl90b2tlbl90eXBlIiwiYWN0b3JUb2tlblR5cGUiLCJKU09OIiwic3RyaW5naWZ5Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJoZWFkZXJzIiwiYXNzaWduIiwib3B0cyIsInVybCIsInRvU3RyaW5nIiwibWV0aG9kIiwiZGF0YSIsInJlc3BvbnNlVHlwZSIsImFwcGx5Q2xpZW50QXV0aGVudGljYXRpb25PcHRpb25zIiwicmVzcG9uc2UiLCJyZXF1ZXN0Iiwic3RzU3VjY2Vzc2Z1bFJlc3BvbnNlIiwicmVzIiwiZXJyb3IiLCJHYXhpb3NFcnJvciIsImdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/browser/crypto.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global window */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BrowserCrypto = void 0;\n// This file implements crypto functions we need using in-browser\n// SubtleCrypto interface `window.crypto.subtle`.\nconst base64js = __webpack_require__(/*! base64-js */ \"(action-browser)/./node_modules/base64-js/index.js\");\nconst crypto_1 = __webpack_require__(/*! ../crypto */ \"(action-browser)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nclass BrowserCrypto {\n    constructor(){\n        if (true) {\n            throw new Error(\"SubtleCrypto not found. Make sure it's an https:// website.\");\n        }\n    }\n    async sha256DigestBase64(str) {\n        // SubtleCrypto digest() method is async, so we must make\n        // this method async as well.\n        // To calculate SHA256 digest using SubtleCrypto, we first\n        // need to convert an input string to an ArrayBuffer:\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const inputBuffer = new TextEncoder().encode(str);\n        // Result is ArrayBuffer as well.\n        const outputBuffer = await window.crypto.subtle.digest(\"SHA-256\", inputBuffer);\n        return base64js.fromByteArray(new Uint8Array(outputBuffer));\n    }\n    randomBytesBase64(count) {\n        const array = new Uint8Array(count);\n        window.crypto.getRandomValues(array);\n        return base64js.fromByteArray(array);\n    }\n    static padBase64(base64) {\n        // base64js requires padding, so let's add some '='\n        while(base64.length % 4 !== 0){\n            base64 += \"=\";\n        }\n        return base64;\n    }\n    async verify(pubkey, data, signature) {\n        const algo = {\n            name: \"RSASSA-PKCS1-v1_5\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        };\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const dataArray = new TextEncoder().encode(data);\n        const signatureArray = base64js.toByteArray(BrowserCrypto.padBase64(signature));\n        const cryptoKey = await window.crypto.subtle.importKey(\"jwk\", pubkey, algo, true, [\n            \"verify\"\n        ]);\n        // SubtleCrypto's verify method is async so we must make\n        // this method async as well.\n        const result = await window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);\n        return result;\n    }\n    async sign(privateKey, data) {\n        const algo = {\n            name: \"RSASSA-PKCS1-v1_5\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        };\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const dataArray = new TextEncoder().encode(data);\n        const cryptoKey = await window.crypto.subtle.importKey(\"jwk\", privateKey, algo, true, [\n            \"sign\"\n        ]);\n        // SubtleCrypto's sign method is async so we must make\n        // this method async as well.\n        const result = await window.crypto.subtle.sign(algo, cryptoKey, dataArray);\n        return base64js.fromByteArray(new Uint8Array(result));\n    }\n    decodeBase64StringUtf8(base64) {\n        const uint8array = base64js.toByteArray(BrowserCrypto.padBase64(base64));\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const result = new TextDecoder().decode(uint8array);\n        return result;\n    }\n    encodeBase64StringUtf8(text) {\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const uint8array = new TextEncoder().encode(text);\n        const result = base64js.fromByteArray(uint8array);\n        return result;\n    }\n    /**\n     * Computes the SHA-256 hash of the provided string.\n     * @param str The plain text string to hash.\n     * @return A promise that resolves with the SHA-256 hash of the provided\n     *   string in hexadecimal encoding.\n     */ async sha256DigestHex(str) {\n        // SubtleCrypto digest() method is async, so we must make\n        // this method async as well.\n        // To calculate SHA256 digest using SubtleCrypto, we first\n        // need to convert an input string to an ArrayBuffer:\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const inputBuffer = new TextEncoder().encode(str);\n        // Result is ArrayBuffer as well.\n        const outputBuffer = await window.crypto.subtle.digest(\"SHA-256\", inputBuffer);\n        return (0, crypto_1.fromArrayBufferToHex)(outputBuffer);\n    }\n    /**\n     * Computes the HMAC hash of a message using the provided crypto key and the\n     * SHA-256 algorithm.\n     * @param key The secret crypto key in utf-8 or ArrayBuffer format.\n     * @param msg The plain text message.\n     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer\n     *   format.\n     */ async signWithHmacSha256(key, msg) {\n        // Convert key, if provided in ArrayBuffer format, to string.\n        const rawKey = typeof key === \"string\" ? key : String.fromCharCode(...new Uint16Array(key));\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const enc = new TextEncoder();\n        const cryptoKey = await window.crypto.subtle.importKey(\"raw\", enc.encode(rawKey), {\n            name: \"HMAC\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        }, false, [\n            \"sign\"\n        ]);\n        return window.crypto.subtle.sign(\"HMAC\", cryptoKey, enc.encode(msg));\n    }\n}\nexports.BrowserCrypto = BrowserCrypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9jcnlwdG8vYnJvd3Nlci9jcnlwdG8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsaUJBQWlCLEdBQ2pCQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUcsS0FBSztBQUM3QixpRUFBaUU7QUFDakUsaURBQWlEO0FBQ2pELE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLHFFQUFXO0FBQ3BDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLGlHQUFXO0FBQ3BDLE1BQU1GO0lBQ0ZJLGFBQWM7UUFDVixJQUFJLElBRWtDRyxFQUFFO1lBQ3BDLE1BQU0sSUFBSUUsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsTUFBTUMsbUJBQW1CQyxHQUFHLEVBQUU7UUFDMUIseURBQXlEO1FBQ3pELDZCQUE2QjtRQUM3QiwwREFBMEQ7UUFDMUQscURBQXFEO1FBQ3JELHNFQUFzRTtRQUN0RSxNQUFNQyxjQUFjLElBQUlDLGNBQWNDLE1BQU0sQ0FBQ0g7UUFDN0MsaUNBQWlDO1FBQ2pDLE1BQU1JLGVBQWUsTUFBTVYsT0FBT0MsTUFBTSxDQUFDRSxNQUFNLENBQUNRLE1BQU0sQ0FBQyxXQUFXSjtRQUNsRSxPQUFPWCxTQUFTZ0IsYUFBYSxDQUFDLElBQUlDLFdBQVdIO0lBQ2pEO0lBQ0FJLGtCQUFrQkMsS0FBSyxFQUFFO1FBQ3JCLE1BQU1DLFFBQVEsSUFBSUgsV0FBV0U7UUFDN0JmLE9BQU9DLE1BQU0sQ0FBQ2dCLGVBQWUsQ0FBQ0Q7UUFDOUIsT0FBT3BC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TSxDQUFDc0MsU0FBUztZQUM5RXJCLE1BQU07WUFDTkMsTUFBTTtnQkFDRkQsTUFBTTtZQUNWO1FBQ0osR0FBRyxPQUFPO1lBQUM7U0FBTztRQUNsQixPQUFPMUIsT0FBT0MsTUFBTSxDQUFDRSxNQUFNLENBQUMrQixJQUFJLENBQUMsUUFBUUgsV0FBV29CLElBQUkxQyxNQUFNLENBQUNxQztJQUNuRTtBQUNKO0FBQ0FyRCxxQkFBcUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL2Jyb3dzZXIvY3J5cHRvLmpzP2ZkNjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJvd3NlckNyeXB0byA9IHZvaWQgMDtcbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGNyeXB0byBmdW5jdGlvbnMgd2UgbmVlZCB1c2luZyBpbi1icm93c2VyXG4vLyBTdWJ0bGVDcnlwdG8gaW50ZXJmYWNlIGB3aW5kb3cuY3J5cHRvLnN1YnRsZWAuXG5jb25zdCBiYXNlNjRqcyA9IHJlcXVpcmUoXCJiYXNlNjQtanNcIik7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG9cIik7XG5jbGFzcyBCcm93c2VyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICB3aW5kb3cuY3J5cHRvID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHdpbmRvdy5jcnlwdG8uc3VidGxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1YnRsZUNyeXB0byBub3QgZm91bmQuIE1ha2Ugc3VyZSBpdCdzIGFuIGh0dHBzOi8vIHdlYnNpdGUuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEJhc2U2NChzdHIpIHtcbiAgICAgICAgLy8gU3VidGxlQ3J5cHRvIGRpZ2VzdCgpIG1ldGhvZCBpcyBhc3luYywgc28gd2UgbXVzdCBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jIGFzIHdlbGwuXG4gICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBTSEEyNTYgZGlnZXN0IHVzaW5nIFN1YnRsZUNyeXB0bywgd2UgZmlyc3RcbiAgICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IGFuIGlucHV0IHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlcjpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICAgICAgICAvLyBSZXN1bHQgaXMgQXJyYXlCdWZmZXIgYXMgd2VsbC5cbiAgICAgICAgY29uc3Qgb3V0cHV0QnVmZmVyID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgaW5wdXRCdWZmZXIpO1xuICAgICAgICByZXR1cm4gYmFzZTY0anMuZnJvbUJ5dGVBcnJheShuZXcgVWludDhBcnJheShvdXRwdXRCdWZmZXIpKTtcbiAgICB9XG4gICAgcmFuZG9tQnl0ZXNCYXNlNjQoY291bnQpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShjb3VudCk7XG4gICAgICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGJhc2U2NGpzLmZyb21CeXRlQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFkQmFzZTY0KGJhc2U2NCkge1xuICAgICAgICAvLyBiYXNlNjRqcyByZXF1aXJlcyBwYWRkaW5nLCBzbyBsZXQncyBhZGQgc29tZSAnPSdcbiAgICAgICAgd2hpbGUgKGJhc2U2NC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICBiYXNlNjQgKz0gJz0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeShwdWJrZXksIGRhdGEsIHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBhbGdvID0ge1xuICAgICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0sXG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGEpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmVBcnJheSA9IGJhc2U2NGpzLnRvQnl0ZUFycmF5KEJyb3dzZXJDcnlwdG8ucGFkQmFzZTY0KHNpZ25hdHVyZSkpO1xuICAgICAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIHB1YmtleSwgYWxnbywgdHJ1ZSwgWyd2ZXJpZnknXSk7XG4gICAgICAgIC8vIFN1YnRsZUNyeXB0bydzIHZlcmlmeSBtZXRob2QgaXMgYXN5bmMgc28gd2UgbXVzdCBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jIGFzIHdlbGwuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLnZlcmlmeShhbGdvLCBjcnlwdG9LZXksIHNpZ25hdHVyZUFycmF5LCBkYXRhQXJyYXkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBzaWduKHByaXZhdGVLZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgYWxnbyA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgICAgICBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdqd2snLCBwcml2YXRlS2V5LCBhbGdvLCB0cnVlLCBbJ3NpZ24nXSk7XG4gICAgICAgIC8vIFN1YnRsZUNyeXB0bydzIHNpZ24gbWV0aG9kIGlzIGFzeW5jIHNvIHdlIG11c3QgbWFrZVxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBhc3luYyBhcyB3ZWxsLlxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5zaWduKGFsZ28sIGNyeXB0b0tleSwgZGF0YUFycmF5KTtcbiAgICAgICAgcmV0dXJuIGJhc2U2NGpzLmZyb21CeXRlQXJyYXkobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGRlY29kZUJhc2U2NFN0cmluZ1V0ZjgoYmFzZTY0KSB7XG4gICAgICAgIGNvbnN0IHVpbnQ4YXJyYXkgPSBiYXNlNjRqcy50b0J5dGVBcnJheShCcm93c2VyQ3J5cHRvLnBhZEJhc2U2NChiYXNlNjQpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodWludDhhcnJheSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZUJhc2U2NFN0cmluZ1V0ZjgodGV4dCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgIGNvbnN0IHVpbnQ4YXJyYXkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGJhc2U2NGpzLmZyb21CeXRlQXJyYXkodWludDhhcnJheSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBTSEEtMjU2IGhhc2ggb2YgdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gc3RyIFRoZSBwbGFpbiB0ZXh0IHN0cmluZyB0byBoYXNoLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgU0hBLTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZFxuICAgICAqICAgc3RyaW5nIGluIGhleGFkZWNpbWFsIGVuY29kaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEhleChzdHIpIHtcbiAgICAgICAgLy8gU3VidGxlQ3J5cHRvIGRpZ2VzdCgpIG1ldGhvZCBpcyBhc3luYywgc28gd2UgbXVzdCBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jIGFzIHdlbGwuXG4gICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBTSEEyNTYgZGlnZXN0IHVzaW5nIFN1YnRsZUNyeXB0bywgd2UgZmlyc3RcbiAgICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IGFuIGlucHV0IHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlcjpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICAgICAgICAvLyBSZXN1bHQgaXMgQXJyYXlCdWZmZXIgYXMgd2VsbC5cbiAgICAgICAgY29uc3Qgb3V0cHV0QnVmZmVyID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgaW5wdXRCdWZmZXIpO1xuICAgICAgICByZXR1cm4gKDAsIGNyeXB0b18xLmZyb21BcnJheUJ1ZmZlclRvSGV4KShvdXRwdXRCdWZmZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgSE1BQyBoYXNoIG9mIGEgbWVzc2FnZSB1c2luZyB0aGUgcHJvdmlkZWQgY3J5cHRvIGtleSBhbmQgdGhlXG4gICAgICogU0hBLTI1NiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIGtleSBUaGUgc2VjcmV0IGNyeXB0byBrZXkgaW4gdXRmLTggb3IgQXJyYXlCdWZmZXIgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBtc2cgVGhlIHBsYWluIHRleHQgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEhNQUMtU0hBMjU2IGhhc2ggaW4gQXJyYXlCdWZmZXJcbiAgICAgKiAgIGZvcm1hdC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduV2l0aEhtYWNTaGEyNTYoa2V5LCBtc2cpIHtcbiAgICAgICAgLy8gQ29udmVydCBrZXksIGlmIHByb3ZpZGVkIGluIEFycmF5QnVmZmVyIGZvcm1hdCwgdG8gc3RyaW5nLlxuICAgICAgICBjb25zdCByYXdLZXkgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDE2QXJyYXkoa2V5KSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgZW5jLmVuY29kZShyYXdLZXkpLCB7XG4gICAgICAgICAgICBuYW1lOiAnSE1BQycsXG4gICAgICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NIQS0yNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgZmFsc2UsIFsnc2lnbiddKTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uc3VidGxlLnNpZ24oJ0hNQUMnLCBjcnlwdG9LZXksIGVuYy5lbmNvZGUobXNnKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyQ3J5cHRvID0gQnJvd3NlckNyeXB0bztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJyb3dzZXJDcnlwdG8iLCJiYXNlNjRqcyIsInJlcXVpcmUiLCJjcnlwdG9fMSIsImNvbnN0cnVjdG9yIiwid2luZG93IiwiY3J5cHRvIiwidW5kZWZpbmVkIiwic3VidGxlIiwiRXJyb3IiLCJzaGEyNTZEaWdlc3RCYXNlNjQiLCJzdHIiLCJpbnB1dEJ1ZmZlciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwib3V0cHV0QnVmZmVyIiwiZGlnZXN0IiwiZnJvbUJ5dGVBcnJheSIsIlVpbnQ4QXJyYXkiLCJyYW5kb21CeXRlc0Jhc2U2NCIsImNvdW50IiwiYXJyYXkiLCJnZXRSYW5kb21WYWx1ZXMiLCJwYWRCYXNlNjQiLCJiYXNlNjQiLCJsZW5ndGgiLCJ2ZXJpZnkiLCJwdWJrZXkiLCJkYXRhIiwic2lnbmF0dXJlIiwiYWxnbyIsIm5hbWUiLCJoYXNoIiwiZGF0YUFycmF5Iiwic2lnbmF0dXJlQXJyYXkiLCJ0b0J5dGVBcnJheSIsImNyeXB0b0tleSIsImltcG9ydEtleSIsInJlc3VsdCIsInNpZ24iLCJwcml2YXRlS2V5IiwiZGVjb2RlQmFzZTY0U3RyaW5nVXRmOCIsInVpbnQ4YXJyYXkiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsImVuY29kZUJhc2U2NFN0cmluZ1V0ZjgiLCJ0ZXh0Iiwic2hhMjU2RGlnZXN0SGV4IiwiZnJvbUFycmF5QnVmZmVyVG9IZXgiLCJzaWduV2l0aEhtYWNTaGEyNTYiLCJrZXkiLCJtc2ciLCJyYXdLZXkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJVaW50MTZBcnJheSIsImVuYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/crypto/crypto.js":
/*!*********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/crypto.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global window */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fromArrayBufferToHex = exports.hasBrowserCrypto = exports.createCrypto = void 0;\nconst crypto_1 = __webpack_require__(/*! ./browser/crypto */ \"(action-browser)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js\");\nconst crypto_2 = __webpack_require__(/*! ./node/crypto */ \"(action-browser)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js\");\nfunction createCrypto() {\n    if (hasBrowserCrypto()) {\n        return new crypto_1.BrowserCrypto();\n    }\n    return new crypto_2.NodeCrypto();\n}\nexports.createCrypto = createCrypto;\nfunction hasBrowserCrypto() {\n    return  false && 0;\n}\nexports.hasBrowserCrypto = hasBrowserCrypto;\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param arrayBuffer The ArrayBuffer to convert to hexadecimal string.\n * @return The hexadecimal encoding of the ArrayBuffer.\n */ function fromArrayBufferToHex(arrayBuffer) {\n    // Convert buffer to byte array.\n    const byteArray = Array.from(new Uint8Array(arrayBuffer));\n    // Convert bytes to hex string.\n    return byteArray.map((byte)=>{\n        return byte.toString(16).padStart(2, \"0\");\n    }).join(\"\");\n}\nexports.fromArrayBufferToHex = fromArrayBufferToHex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9jcnlwdG8vY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLGlCQUFpQixHQUNqQkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDRCQUE0QixHQUFHQSx3QkFBd0IsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUN0RixNQUFNSyxXQUFXQyxtQkFBT0EsQ0FBQyxnSEFBa0I7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsMEdBQWU7QUFDeEMsU0FBU0Y7SUFDTCxJQUFJRCxvQkFBb0I7UUFDcEIsT0FBTyxJQUFJRSxTQUFTRyxhQUFhO0lBQ3JDO0lBQ0EsT0FBTyxJQUFJRCxTQUFTRSxVQUFVO0FBQ2xDO0FBQ0FULG9CQUFvQixHQUFHSTtBQUN2QixTQUFTRDtJQUNMLE9BQVEsTUFDcUIsSUFDekIsQ0FBZ0M7QUFDeEM7QUFDQUgsd0JBQXdCLEdBQUdHO0FBQzNCOzs7O0NBSUMsR0FDRCxTQUFTRCxxQkFBcUJXLFdBQVc7SUFDckMsZ0NBQWdDO0lBQ2hDLE1BQU1DLFlBQVlDLE1BQU1DLElBQUksQ0FBQyxJQUFJQyxXQUFXSjtJQUM1QywrQkFBK0I7SUFDL0IsT0FBT0MsVUFDRkksR0FBRyxDQUFDQyxDQUFBQTtRQUNMLE9BQU9BLEtBQUtDLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRztJQUN6QyxHQUNLQyxJQUFJLENBQUM7QUFDZDtBQUNBdEIsNEJBQTRCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvdGlmeS10by15b3V0dWJlLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2NyeXB0by9jcnlwdG8uanM/NDA4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcm9tQXJyYXlCdWZmZXJUb0hleCA9IGV4cG9ydHMuaGFzQnJvd3NlckNyeXB0byA9IGV4cG9ydHMuY3JlYXRlQ3J5cHRvID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi9icm93c2VyL2NyeXB0b1wiKTtcbmNvbnN0IGNyeXB0b18yID0gcmVxdWlyZShcIi4vbm9kZS9jcnlwdG9cIik7XG5mdW5jdGlvbiBjcmVhdGVDcnlwdG8oKSB7XG4gICAgaWYgKGhhc0Jyb3dzZXJDcnlwdG8oKSkge1xuICAgICAgICByZXR1cm4gbmV3IGNyeXB0b18xLkJyb3dzZXJDcnlwdG8oKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBjcnlwdG9fMi5Ob2RlQ3J5cHRvKCk7XG59XG5leHBvcnRzLmNyZWF0ZUNyeXB0byA9IGNyZWF0ZUNyeXB0bztcbmZ1bmN0aW9uIGhhc0Jyb3dzZXJDcnlwdG8oKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93LmNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5jcnlwdG8uc3VidGxlICE9PSAndW5kZWZpbmVkJyk7XG59XG5leHBvcnRzLmhhc0Jyb3dzZXJDcnlwdG8gPSBoYXNCcm93c2VyQ3J5cHRvO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBBcnJheUJ1ZmZlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEBwYXJhbSBhcnJheUJ1ZmZlciBUaGUgQXJyYXlCdWZmZXIgdG8gY29udmVydCB0byBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJuIFRoZSBoZXhhZGVjaW1hbCBlbmNvZGluZyBvZiB0aGUgQXJyYXlCdWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlclRvSGV4KGFycmF5QnVmZmVyKSB7XG4gICAgLy8gQ29udmVydCBidWZmZXIgdG8gYnl0ZSBhcnJheS5cbiAgICBjb25zdCBieXRlQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgLy8gQ29udmVydCBieXRlcyB0byBoZXggc3RyaW5nLlxuICAgIHJldHVybiBieXRlQXJyYXlcbiAgICAgICAgLm1hcChieXRlID0+IHtcbiAgICAgICAgcmV0dXJuIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuZXhwb3J0cy5mcm9tQXJyYXlCdWZmZXJUb0hleCA9IGZyb21BcnJheUJ1ZmZlclRvSGV4O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZnJvbUFycmF5QnVmZmVyVG9IZXgiLCJoYXNCcm93c2VyQ3J5cHRvIiwiY3JlYXRlQ3J5cHRvIiwiY3J5cHRvXzEiLCJyZXF1aXJlIiwiY3J5cHRvXzIiLCJCcm93c2VyQ3J5cHRvIiwiTm9kZUNyeXB0byIsIndpbmRvdyIsImNyeXB0byIsInN1YnRsZSIsImFycmF5QnVmZmVyIiwiYnl0ZUFycmF5IiwiQXJyYXkiLCJmcm9tIiwiVWludDhBcnJheSIsIm1hcCIsImJ5dGUiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/crypto/crypto.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/node/crypto.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.NodeCrypto = void 0;\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nclass NodeCrypto {\n    async sha256DigestBase64(str) {\n        return crypto.createHash(\"sha256\").update(str).digest(\"base64\");\n    }\n    randomBytesBase64(count) {\n        return crypto.randomBytes(count).toString(\"base64\");\n    }\n    async verify(pubkey, data, signature) {\n        const verifier = crypto.createVerify(\"RSA-SHA256\");\n        verifier.update(data);\n        verifier.end();\n        return verifier.verify(pubkey, signature, \"base64\");\n    }\n    async sign(privateKey, data) {\n        const signer = crypto.createSign(\"RSA-SHA256\");\n        signer.update(data);\n        signer.end();\n        return signer.sign(privateKey, \"base64\");\n    }\n    decodeBase64StringUtf8(base64) {\n        return Buffer.from(base64, \"base64\").toString(\"utf-8\");\n    }\n    encodeBase64StringUtf8(text) {\n        return Buffer.from(text, \"utf-8\").toString(\"base64\");\n    }\n    /**\n     * Computes the SHA-256 hash of the provided string.\n     * @param str The plain text string to hash.\n     * @return A promise that resolves with the SHA-256 hash of the provided\n     *   string in hexadecimal encoding.\n     */ async sha256DigestHex(str) {\n        return crypto.createHash(\"sha256\").update(str).digest(\"hex\");\n    }\n    /**\n     * Computes the HMAC hash of a message using the provided crypto key and the\n     * SHA-256 algorithm.\n     * @param key The secret crypto key in utf-8 or ArrayBuffer format.\n     * @param msg The plain text message.\n     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer\n     *   format.\n     */ async signWithHmacSha256(key, msg) {\n        const cryptoKey = typeof key === \"string\" ? key : toBuffer(key);\n        return toArrayBuffer(crypto.createHmac(\"sha256\", cryptoKey).update(msg).digest());\n    }\n}\nexports.NodeCrypto = NodeCrypto;\n/**\n * Converts a Node.js Buffer to an ArrayBuffer.\n * https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer\n * @param buffer The Buffer input to covert.\n * @return The ArrayBuffer representation of the input.\n */ function toArrayBuffer(buffer) {\n    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n}\n/**\n * Converts an ArrayBuffer to a Node.js Buffer.\n * @param arrayBuffer The ArrayBuffer input to covert.\n * @return The Buffer representation of the input.\n */ function toBuffer(arrayBuffer) {\n    return Buffer.from(arrayBuffer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9jcnlwdG8vbm9kZS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBRyxLQUFLO0FBQzFCLE1BQU1HLFNBQVNDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQy9CLE1BQU1GO0lBQ0YsTUFBTUcsbUJBQW1CQyxHQUFHLEVBQUU7UUFDMUIsT0FBT0gsT0FBT0ksVUFBVSxDQUFDLFVBQVVDLE1BQU0sQ0FBQ0YsS0FBS0csTUFBTSxDQUFDO0lBQzFEO0lBQ0FDLGtCQUFrQkMsS0FBSyxFQUFFO1FBQ3JCLE9BQU9SLE9BQU9TLFdBQVcsQ0FBQ0QsT0FBT0UsUUFBUSxDQUFDO0lBQzlDO0lBQ0EsTUFBTUMsT0FBT0MsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFNBQVMsRUFBRTtRQUNsQyxNQUFNQyxXQUFXZixPQUFPZ0IsWUFBWSxDQUFDO1FBQ3JDRCxTQUFTVixNQUFNLENBQUNRO1FBQ2hCRSxTQUFTRSxHQUFHO1FBQ1osT0FBT0YsU0FBU0osTUFBTSxDQUFDQyxRQUFRRSxXQUFXO0lBQzlDO0lBQ0EsTUFBTUksS0FBS0MsVUFBVSxFQUFFTixJQUFJLEVBQUU7UUFDekIsTUFBTU8sU0FBU3BCLE9BQU9xQixVQUFVLENBQUM7UUFDakNELE9BQU9mLE1BQU0sQ0FBQ1E7UUFDZE8sT0FBT0gsR0FBRztRQUNWLE9BQU9HLE9BQU9GLElBQUksQ0FBQ0MsWUFBWTtJQUNuQztJQUNBRyx1QkFBdUJDLE1BQU0sRUFBRTtRQUMzQixPQUFPQyxPQUFPQyxJQUFJLENBQUNGLFFBQVEsVUFBVWIsUUFBUSxDQUFDO0lBQ2xEO0lBQ0FnQix1QkFBdUJDLElBQUksRUFBRTtRQUN6QixPQUFPSCxPQUFPQyxJQUFJLENBQUNFLE1BQU0sU0FBU2pCLFFBQVEsQ0FBQztJQUMvQztJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTWtCLGdCQUFnQnpCLEdBQUcsRUFBRTtRQUN2QixPQUFPSCxPQUFPSSxVQUFVLENBQUMsVUFBVUMsTUFBTSxDQUFDRixLQUFLRyxNQUFNLENBQUM7SUFDMUQ7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsTUFBTXVCLG1CQUFtQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUU7UUFDL0IsTUFBTUMsWUFBWSxPQUFPRixRQUFRLFdBQVdBLE1BQU1HLFNBQVNIO1FBQzNELE9BQU9JLGNBQWNsQyxPQUFPbUMsVUFBVSxDQUFDLFVBQVVILFdBQVczQixNQUFNLENBQUMwQixLQUFLekIsTUFBTTtJQUNsRjtBQUNKO0FBQ0FULGtCQUFrQixHQUFHRTtBQUNyQjs7Ozs7Q0FLQyxHQUNELFNBQVNtQyxjQUFjRSxNQUFNO0lBQ3pCLE9BQU9BLE9BQU9BLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDRCxPQUFPRSxVQUFVLEVBQUVGLE9BQU9FLFVBQVUsR0FBR0YsT0FBT0csVUFBVTtBQUN2RjtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTTixTQUFTTyxXQUFXO0lBQ3pCLE9BQU9oQixPQUFPQyxJQUFJLENBQUNlO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvdGlmeS10by15b3V0dWJlLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2NyeXB0by9ub2RlL2NyeXB0by5qcz9lMmUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vZGVDcnlwdG8gPSB2b2lkIDA7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY2xhc3MgTm9kZUNyeXB0byB7XG4gICAgYXN5bmMgc2hhMjU2RGlnZXN0QmFzZTY0KHN0cikge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShzdHIpLmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgfVxuICAgIHJhbmRvbUJ5dGVzQmFzZTY0KGNvdW50KSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoY291bnQpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5KHB1YmtleSwgZGF0YSwgc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHZlcmlmaWVyID0gY3J5cHRvLmNyZWF0ZVZlcmlmeSgnUlNBLVNIQTI1NicpO1xuICAgICAgICB2ZXJpZmllci51cGRhdGUoZGF0YSk7XG4gICAgICAgIHZlcmlmaWVyLmVuZCgpO1xuICAgICAgICByZXR1cm4gdmVyaWZpZXIudmVyaWZ5KHB1YmtleSwgc2lnbmF0dXJlLCAnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ24ocHJpdmF0ZUtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbignUlNBLVNIQTI1NicpO1xuICAgICAgICBzaWduZXIudXBkYXRlKGRhdGEpO1xuICAgICAgICBzaWduZXIuZW5kKCk7XG4gICAgICAgIHJldHVybiBzaWduZXIuc2lnbihwcml2YXRlS2V5LCAnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGRlY29kZUJhc2U2NFN0cmluZ1V0ZjgoYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShiYXNlNjQsICdiYXNlNjQnKS50b1N0cmluZygndXRmLTgnKTtcbiAgICB9XG4gICAgZW5jb2RlQmFzZTY0U3RyaW5nVXRmOCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0ZXh0LCAndXRmLTgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBTSEEtMjU2IGhhc2ggb2YgdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gc3RyIFRoZSBwbGFpbiB0ZXh0IHN0cmluZyB0byBoYXNoLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgU0hBLTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZFxuICAgICAqICAgc3RyaW5nIGluIGhleGFkZWNpbWFsIGVuY29kaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEhleChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc3RyKS5kaWdlc3QoJ2hleCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgSE1BQyBoYXNoIG9mIGEgbWVzc2FnZSB1c2luZyB0aGUgcHJvdmlkZWQgY3J5cHRvIGtleSBhbmQgdGhlXG4gICAgICogU0hBLTI1NiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIGtleSBUaGUgc2VjcmV0IGNyeXB0byBrZXkgaW4gdXRmLTggb3IgQXJyYXlCdWZmZXIgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBtc2cgVGhlIHBsYWluIHRleHQgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEhNQUMtU0hBMjU2IGhhc2ggaW4gQXJyYXlCdWZmZXJcbiAgICAgKiAgIGZvcm1hdC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduV2l0aEhtYWNTaGEyNTYoa2V5LCBtc2cpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyBrZXkgOiB0b0J1ZmZlcihrZXkpO1xuICAgICAgICByZXR1cm4gdG9BcnJheUJ1ZmZlcihjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2JywgY3J5cHRvS2V5KS51cGRhdGUobXNnKS5kaWdlc3QoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob2RlQ3J5cHRvID0gTm9kZUNyeXB0bztcbi8qKlxuICogQ29udmVydHMgYSBOb2RlLmpzIEJ1ZmZlciB0byBhbiBBcnJheUJ1ZmZlci5cbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg2MDkyODkvY29udmVydC1hLWJpbmFyeS1ub2RlanMtYnVmZmVyLXRvLWphdmFzY3JpcHQtYXJyYXlidWZmZXJcbiAqIEBwYXJhbSBidWZmZXIgVGhlIEJ1ZmZlciBpbnB1dCB0byBjb3ZlcnQuXG4gKiBAcmV0dXJuIFRoZSBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXIuc2xpY2UoYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlT2Zmc2V0ICsgYnVmZmVyLmJ5dGVMZW5ndGgpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBcnJheUJ1ZmZlciB0byBhIE5vZGUuanMgQnVmZmVyLlxuICogQHBhcmFtIGFycmF5QnVmZmVyIFRoZSBBcnJheUJ1ZmZlciBpbnB1dCB0byBjb3ZlcnQuXG4gKiBAcmV0dXJuIFRoZSBCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlucHV0LlxuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcik7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJOb2RlQ3J5cHRvIiwiY3J5cHRvIiwicmVxdWlyZSIsInNoYTI1NkRpZ2VzdEJhc2U2NCIsInN0ciIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJkaWdlc3QiLCJyYW5kb21CeXRlc0Jhc2U2NCIsImNvdW50IiwicmFuZG9tQnl0ZXMiLCJ0b1N0cmluZyIsInZlcmlmeSIsInB1YmtleSIsImRhdGEiLCJzaWduYXR1cmUiLCJ2ZXJpZmllciIsImNyZWF0ZVZlcmlmeSIsImVuZCIsInNpZ24iLCJwcml2YXRlS2V5Iiwic2lnbmVyIiwiY3JlYXRlU2lnbiIsImRlY29kZUJhc2U2NFN0cmluZ1V0ZjgiLCJiYXNlNjQiLCJCdWZmZXIiLCJmcm9tIiwiZW5jb2RlQmFzZTY0U3RyaW5nVXRmOCIsInRleHQiLCJzaGEyNTZEaWdlc3RIZXgiLCJzaWduV2l0aEhtYWNTaGEyNTYiLCJrZXkiLCJtc2ciLCJjcnlwdG9LZXkiLCJ0b0J1ZmZlciIsInRvQXJyYXlCdWZmZXIiLCJjcmVhdGVIbWFjIiwiYnVmZmVyIiwic2xpY2UiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImFycmF5QnVmZmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GoogleAuth = exports.auth = exports.DefaultTransporter = exports.PluggableAuthClient = exports.DownscopedClient = exports.BaseExternalAccountClient = exports.ExternalAccountClient = exports.IdentityPoolClient = exports.AwsClient = exports.UserRefreshClient = exports.LoginTicket = exports.OAuth2Client = exports.CodeChallengeMethod = exports.Impersonated = exports.JWT = exports.JWTAccess = exports.IdTokenClient = exports.IAMAuth = exports.GCPEnv = exports.Compute = exports.DEFAULT_UNIVERSE = exports.AuthClient = exports.gcpMetadata = void 0;\n// Copyright 2017 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst googleauth_1 = __webpack_require__(/*! ./auth/googleauth */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/googleauth.js\");\nObject.defineProperty(exports, \"GoogleAuth\", ({\n    enumerable: true,\n    get: function() {\n        return googleauth_1.GoogleAuth;\n    }\n}));\nexports.gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(action-browser)/./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/index.js\");\nvar authclient_1 = __webpack_require__(/*! ./auth/authclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nObject.defineProperty(exports, \"AuthClient\", ({\n    enumerable: true,\n    get: function() {\n        return authclient_1.AuthClient;\n    }\n}));\nObject.defineProperty(exports, \"DEFAULT_UNIVERSE\", ({\n    enumerable: true,\n    get: function() {\n        return authclient_1.DEFAULT_UNIVERSE;\n    }\n}));\nvar computeclient_1 = __webpack_require__(/*! ./auth/computeclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/computeclient.js\");\nObject.defineProperty(exports, \"Compute\", ({\n    enumerable: true,\n    get: function() {\n        return computeclient_1.Compute;\n    }\n}));\nvar envDetect_1 = __webpack_require__(/*! ./auth/envDetect */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/envDetect.js\");\nObject.defineProperty(exports, \"GCPEnv\", ({\n    enumerable: true,\n    get: function() {\n        return envDetect_1.GCPEnv;\n    }\n}));\nvar iam_1 = __webpack_require__(/*! ./auth/iam */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/iam.js\");\nObject.defineProperty(exports, \"IAMAuth\", ({\n    enumerable: true,\n    get: function() {\n        return iam_1.IAMAuth;\n    }\n}));\nvar idtokenclient_1 = __webpack_require__(/*! ./auth/idtokenclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\");\nObject.defineProperty(exports, \"IdTokenClient\", ({\n    enumerable: true,\n    get: function() {\n        return idtokenclient_1.IdTokenClient;\n    }\n}));\nvar jwtaccess_1 = __webpack_require__(/*! ./auth/jwtaccess */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\");\nObject.defineProperty(exports, \"JWTAccess\", ({\n    enumerable: true,\n    get: function() {\n        return jwtaccess_1.JWTAccess;\n    }\n}));\nvar jwtclient_1 = __webpack_require__(/*! ./auth/jwtclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\");\nObject.defineProperty(exports, \"JWT\", ({\n    enumerable: true,\n    get: function() {\n        return jwtclient_1.JWT;\n    }\n}));\nvar impersonated_1 = __webpack_require__(/*! ./auth/impersonated */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/impersonated.js\");\nObject.defineProperty(exports, \"Impersonated\", ({\n    enumerable: true,\n    get: function() {\n        return impersonated_1.Impersonated;\n    }\n}));\nvar oauth2client_1 = __webpack_require__(/*! ./auth/oauth2client */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nObject.defineProperty(exports, \"CodeChallengeMethod\", ({\n    enumerable: true,\n    get: function() {\n        return oauth2client_1.CodeChallengeMethod;\n    }\n}));\nObject.defineProperty(exports, \"OAuth2Client\", ({\n    enumerable: true,\n    get: function() {\n        return oauth2client_1.OAuth2Client;\n    }\n}));\nvar loginticket_1 = __webpack_require__(/*! ./auth/loginticket */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/loginticket.js\");\nObject.defineProperty(exports, \"LoginTicket\", ({\n    enumerable: true,\n    get: function() {\n        return loginticket_1.LoginTicket;\n    }\n}));\nvar refreshclient_1 = __webpack_require__(/*! ./auth/refreshclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\");\nObject.defineProperty(exports, \"UserRefreshClient\", ({\n    enumerable: true,\n    get: function() {\n        return refreshclient_1.UserRefreshClient;\n    }\n}));\nvar awsclient_1 = __webpack_require__(/*! ./auth/awsclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/awsclient.js\");\nObject.defineProperty(exports, \"AwsClient\", ({\n    enumerable: true,\n    get: function() {\n        return awsclient_1.AwsClient;\n    }\n}));\nvar identitypoolclient_1 = __webpack_require__(/*! ./auth/identitypoolclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\");\nObject.defineProperty(exports, \"IdentityPoolClient\", ({\n    enumerable: true,\n    get: function() {\n        return identitypoolclient_1.IdentityPoolClient;\n    }\n}));\nvar externalclient_1 = __webpack_require__(/*! ./auth/externalclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/externalclient.js\");\nObject.defineProperty(exports, \"ExternalAccountClient\", ({\n    enumerable: true,\n    get: function() {\n        return externalclient_1.ExternalAccountClient;\n    }\n}));\nvar baseexternalclient_1 = __webpack_require__(/*! ./auth/baseexternalclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nObject.defineProperty(exports, \"BaseExternalAccountClient\", ({\n    enumerable: true,\n    get: function() {\n        return baseexternalclient_1.BaseExternalAccountClient;\n    }\n}));\nvar downscopedclient_1 = __webpack_require__(/*! ./auth/downscopedclient */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js\");\nObject.defineProperty(exports, \"DownscopedClient\", ({\n    enumerable: true,\n    get: function() {\n        return downscopedclient_1.DownscopedClient;\n    }\n}));\nvar pluggable_auth_client_1 = __webpack_require__(/*! ./auth/pluggable-auth-client */ \"(action-browser)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\nObject.defineProperty(exports, \"PluggableAuthClient\", ({\n    enumerable: true,\n    get: function() {\n        return pluggable_auth_client_1.PluggableAuthClient;\n    }\n}));\nvar transporters_1 = __webpack_require__(/*! ./transporters */ \"(action-browser)/./node_modules/google-auth-library/build/src/transporters.js\");\nObject.defineProperty(exports, \"DefaultTransporter\", ({\n    enumerable: true,\n    get: function() {\n        return transporters_1.DefaultTransporter;\n    }\n}));\nconst auth = new googleauth_1.GoogleAuth();\nexports.auth = auth;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUdBLFlBQVksR0FBR0EsMEJBQTBCLEdBQUdBLDJCQUEyQixHQUFHQSx3QkFBd0IsR0FBR0EsaUNBQWlDLEdBQUdBLDZCQUE2QixHQUFHQSwwQkFBMEIsR0FBR0EsaUJBQWlCLEdBQUdBLHlCQUF5QixHQUFHQSxtQkFBbUIsR0FBR0Esb0JBQW9CLEdBQUdBLDJCQUEyQixHQUFHQSxvQkFBb0IsR0FBR0EsV0FBVyxHQUFHQSxpQkFBaUIsR0FBR0EscUJBQXFCLEdBQUdBLGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxlQUFlLEdBQUdBLHdCQUF3QixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUN2aUIsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLE1BQU15QixlQUFlQyxtQkFBT0EsQ0FBQywyR0FBbUI7QUFDaEQ1Qiw4Q0FBNkM7SUFBRTZCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILGFBQWF2QixVQUFVO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDeEhGLGlLQUE2QztBQUM3QyxJQUFJNkIsZUFBZUgsbUJBQU9BLENBQUMsMkdBQW1CO0FBQzlDNUIsOENBQTZDO0lBQUU2QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxhQUFhTixVQUFVO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDeEh6QixvREFBbUQ7SUFBRTZCLFlBQVk7SUFBTUMsS0FBSztR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eUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM5SixJQUFJcUMscUJBQXFCbEIsbUJBQU9BLENBQUMsdUhBQXlCO0FBQzFENUIsb0RBQW1EO0lBQUU2QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPZ0IsbUJBQW1CdEMsZ0JBQWdCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDMUksSUFBSXVDLDBCQUEwQm5CLG1CQUFPQSxDQUFDLGlJQUE4QjtBQUNwRTVCLHVEQUFzRDtJQUFFNkIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2lCLHdCQUF3QnhDLG1CQUFtQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JKLElBQUl5QyxpQkFBaUJwQixtQkFBT0EsQ0FBQyxxR0FBZ0I7QUFDN0M1QixzREFBcUQ7SUFBRTZCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9rQixlQUFlMUMsa0JBQWtCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDMUksTUFBTUQsT0FBTyxJQUFJc0IsYUFBYXZCLFVBQVU7QUFDeENGLFlBQVksR0FBR0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvaW5kZXguanM/MDk2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR29vZ2xlQXV0aCA9IGV4cG9ydHMuYXV0aCA9IGV4cG9ydHMuRGVmYXVsdFRyYW5zcG9ydGVyID0gZXhwb3J0cy5QbHVnZ2FibGVBdXRoQ2xpZW50ID0gZXhwb3J0cy5Eb3duc2NvcGVkQ2xpZW50ID0gZXhwb3J0cy5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50ID0gZXhwb3J0cy5FeHRlcm5hbEFjY291bnRDbGllbnQgPSBleHBvcnRzLklkZW50aXR5UG9vbENsaWVudCA9IGV4cG9ydHMuQXdzQ2xpZW50ID0gZXhwb3J0cy5Vc2VyUmVmcmVzaENsaWVudCA9IGV4cG9ydHMuTG9naW5UaWNrZXQgPSBleHBvcnRzLk9BdXRoMkNsaWVudCA9IGV4cG9ydHMuQ29kZUNoYWxsZW5nZU1ldGhvZCA9IGV4cG9ydHMuSW1wZXJzb25hdGVkID0gZXhwb3J0cy5KV1QgPSBleHBvcnRzLkpXVEFjY2VzcyA9IGV4cG9ydHMuSWRUb2tlbkNsaWVudCA9IGV4cG9ydHMuSUFNQXV0aCA9IGV4cG9ydHMuR0NQRW52ID0gZXhwb3J0cy5Db21wdXRlID0gZXhwb3J0cy5ERUZBVUxUX1VOSVZFUlNFID0gZXhwb3J0cy5BdXRoQ2xpZW50ID0gZXhwb3J0cy5nY3BNZXRhZGF0YSA9IHZvaWQgMDtcbi8vIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY29uc3QgZ29vZ2xlYXV0aF8xID0gcmVxdWlyZShcIi4vYXV0aC9nb29nbGVhdXRoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR29vZ2xlQXV0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ29vZ2xlYXV0aF8xLkdvb2dsZUF1dGg7IH0gfSk7XG5leHBvcnRzLmdjcE1ldGFkYXRhID0gcmVxdWlyZShcImdjcC1tZXRhZGF0YVwiKTtcbnZhciBhdXRoY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2F1dGhjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBdXRoQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhdXRoY2xpZW50XzEuQXV0aENsaWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRFRkFVTFRfVU5JVkVSU0VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF1dGhjbGllbnRfMS5ERUZBVUxUX1VOSVZFUlNFOyB9IH0pO1xudmFyIGNvbXB1dGVjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvY29tcHV0ZWNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbXB1dGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXB1dGVjbGllbnRfMS5Db21wdXRlOyB9IH0pO1xudmFyIGVudkRldGVjdF8xID0gcmVxdWlyZShcIi4vYXV0aC9lbnZEZXRlY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHQ1BFbnZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudkRldGVjdF8xLkdDUEVudjsgfSB9KTtcbnZhciBpYW1fMSA9IHJlcXVpcmUoXCIuL2F1dGgvaWFtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSUFNQXV0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWFtXzEuSUFNQXV0aDsgfSB9KTtcbnZhciBpZHRva2VuY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2lkdG9rZW5jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJZFRva2VuQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpZHRva2VuY2xpZW50XzEuSWRUb2tlbkNsaWVudDsgfSB9KTtcbnZhciBqd3RhY2Nlc3NfMSA9IHJlcXVpcmUoXCIuL2F1dGgvand0YWNjZXNzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSldUQWNjZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqd3RhY2Nlc3NfMS5KV1RBY2Nlc3M7IH0gfSk7XG52YXIgand0Y2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2p3dGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpXVFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gand0Y2xpZW50XzEuSldUOyB9IH0pO1xudmFyIGltcGVyc29uYXRlZF8xID0gcmVxdWlyZShcIi4vYXV0aC9pbXBlcnNvbmF0ZWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbXBlcnNvbmF0ZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGltcGVyc29uYXRlZF8xLkltcGVyc29uYXRlZDsgfSB9KTtcbnZhciBvYXV0aDJjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvb2F1dGgyY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUNoYWxsZW5nZU1ldGhvZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2F1dGgyY2xpZW50XzEuQ29kZUNoYWxsZW5nZU1ldGhvZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9BdXRoMkNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2F1dGgyY2xpZW50XzEuT0F1dGgyQ2xpZW50OyB9IH0pO1xudmFyIGxvZ2ludGlja2V0XzEgPSByZXF1aXJlKFwiLi9hdXRoL2xvZ2ludGlja2V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9naW5UaWNrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZ2ludGlja2V0XzEuTG9naW5UaWNrZXQ7IH0gfSk7XG52YXIgcmVmcmVzaGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9yZWZyZXNoY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXNlclJlZnJlc2hDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZnJlc2hjbGllbnRfMS5Vc2VyUmVmcmVzaENsaWVudDsgfSB9KTtcbnZhciBhd3NjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvYXdzY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXdzQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhd3NjbGllbnRfMS5Bd3NDbGllbnQ7IH0gfSk7XG52YXIgaWRlbnRpdHlwb29sY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2lkZW50aXR5cG9vbGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklkZW50aXR5UG9vbENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWRlbnRpdHlwb29sY2xpZW50XzEuSWRlbnRpdHlQb29sQ2xpZW50OyB9IH0pO1xudmFyIGV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2V4dGVybmFsY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXh0ZXJuYWxBY2NvdW50Q2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleHRlcm5hbGNsaWVudF8xLkV4dGVybmFsQWNjb3VudENsaWVudDsgfSB9KTtcbnZhciBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZUV4dGVybmFsQWNjb3VudENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudDsgfSB9KTtcbnZhciBkb3duc2NvcGVkY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2Rvd25zY29wZWRjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb3duc2NvcGVkQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb3duc2NvcGVkY2xpZW50XzEuRG93bnNjb3BlZENsaWVudDsgfSB9KTtcbnZhciBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvcGx1Z2dhYmxlLWF1dGgtY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGx1Z2dhYmxlQXV0aENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGx1Z2dhYmxlX2F1dGhfY2xpZW50XzEuUGx1Z2dhYmxlQXV0aENsaWVudDsgfSB9KTtcbnZhciB0cmFuc3BvcnRlcnNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydGVyc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlZmF1bHRUcmFuc3BvcnRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNwb3J0ZXJzXzEuRGVmYXVsdFRyYW5zcG9ydGVyOyB9IH0pO1xuY29uc3QgYXV0aCA9IG5ldyBnb29nbGVhdXRoXzEuR29vZ2xlQXV0aCgpO1xuZXhwb3J0cy5hdXRoID0gYXV0aDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkdvb2dsZUF1dGgiLCJhdXRoIiwiRGVmYXVsdFRyYW5zcG9ydGVyIiwiUGx1Z2dhYmxlQXV0aENsaWVudCIsIkRvd25zY29wZWRDbGllbnQiLCJCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IiwiRXh0ZXJuYWxBY2NvdW50Q2xpZW50IiwiSWRlbnRpdHlQb29sQ2xpZW50IiwiQXdzQ2xpZW50IiwiVXNlclJlZnJlc2hDbGllbnQiLCJMb2dpblRpY2tldCIsIk9BdXRoMkNsaWVudCIsIkNvZGVDaGFsbGVuZ2VNZXRob2QiLCJJbXBlcnNvbmF0ZWQiLCJKV1QiLCJKV1RBY2Nlc3MiLCJJZFRva2VuQ2xpZW50IiwiSUFNQXV0aCIsIkdDUEVudiIsIkNvbXB1dGUiLCJERUZBVUxUX1VOSVZFUlNFIiwiQXV0aENsaWVudCIsImdjcE1ldGFkYXRhIiwiZ29vZ2xlYXV0aF8xIiwicmVxdWlyZSIsImVudW1lcmFibGUiLCJnZXQiLCJhdXRoY2xpZW50XzEiLCJjb21wdXRlY2xpZW50XzEiLCJlbnZEZXRlY3RfMSIsImlhbV8xIiwiaWR0b2tlbmNsaWVudF8xIiwiand0YWNjZXNzXzEiLCJqd3RjbGllbnRfMSIsImltcGVyc29uYXRlZF8xIiwib2F1dGgyY2xpZW50XzEiLCJsb2dpbnRpY2tldF8xIiwicmVmcmVzaGNsaWVudF8xIiwiYXdzY2xpZW50XzEiLCJpZGVudGl0eXBvb2xjbGllbnRfMSIsImV4dGVybmFsY2xpZW50XzEiLCJiYXNlZXh0ZXJuYWxjbGllbnRfMSIsImRvd25zY29wZWRjbGllbnRfMSIsInBsdWdnYWJsZV9hdXRoX2NsaWVudF8xIiwidHJhbnNwb3J0ZXJzXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/options.js":
/*!***************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/options.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2017 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validate = void 0;\n// Accepts an options object passed from the user to the API.  In the\n// previous version of the API, it referred to a `Request` options object.\n// Now it refers to an Axiox Request Config object.  This is here to help\n// ensure users don't pass invalid options when they upgrade from 0.x to 1.x.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validate(options) {\n    const vpairs = [\n        {\n            invalid: \"uri\",\n            expected: \"url\"\n        },\n        {\n            invalid: \"json\",\n            expected: \"data\"\n        },\n        {\n            invalid: \"qs\",\n            expected: \"params\"\n        }\n    ];\n    for (const pair of vpairs){\n        if (options[pair.invalid]) {\n            const e = `'${pair.invalid}' is not a valid configuration option. Please use '${pair.expected}' instead. This library is using Axios for requests. Please see https://github.com/axios/axios to learn more about the valid request options.`;\n            throw new Error(e);\n        }\n    }\n}\nexports.validate = validate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUcsS0FBSztBQUN4QixxRUFBcUU7QUFDckUsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSw2RUFBNkU7QUFDN0UsOERBQThEO0FBQzlELFNBQVNFLFNBQVNDLE9BQU87SUFDckIsTUFBTUMsU0FBUztRQUNYO1lBQUVDLFNBQVM7WUFBT0MsVUFBVTtRQUFNO1FBQ2xDO1lBQUVELFNBQVM7WUFBUUMsVUFBVTtRQUFPO1FBQ3BDO1lBQUVELFNBQVM7WUFBTUMsVUFBVTtRQUFTO0tBQ3ZDO0lBQ0QsS0FBSyxNQUFNQyxRQUFRSCxPQUFRO1FBQ3ZCLElBQUlELE9BQU8sQ0FBQ0ksS0FBS0YsT0FBTyxDQUFDLEVBQUU7WUFDdkIsTUFBTUcsSUFBSSxDQUFDLENBQUMsRUFBRUQsS0FBS0YsT0FBTyxDQUFDLG1EQUFtRCxFQUFFRSxLQUFLRCxRQUFRLENBQUMsNklBQTZJLENBQUM7WUFDNU8sTUFBTSxJQUFJRyxNQUFNRDtRQUNwQjtJQUNKO0FBQ0o7QUFDQVIsZ0JBQWdCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvdGlmeS10by15b3V0dWJlLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL29wdGlvbnMuanM/NTM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZvaWQgMDtcbi8vIEFjY2VwdHMgYW4gb3B0aW9ucyBvYmplY3QgcGFzc2VkIGZyb20gdGhlIHVzZXIgdG8gdGhlIEFQSS4gIEluIHRoZVxuLy8gcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgQVBJLCBpdCByZWZlcnJlZCB0byBhIGBSZXF1ZXN0YCBvcHRpb25zIG9iamVjdC5cbi8vIE5vdyBpdCByZWZlcnMgdG8gYW4gQXhpb3ggUmVxdWVzdCBDb25maWcgb2JqZWN0LiAgVGhpcyBpcyBoZXJlIHRvIGhlbHBcbi8vIGVuc3VyZSB1c2VycyBkb24ndCBwYXNzIGludmFsaWQgb3B0aW9ucyB3aGVuIHRoZXkgdXBncmFkZSBmcm9tIDAueCB0byAxLnguXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHZwYWlycyA9IFtcbiAgICAgICAgeyBpbnZhbGlkOiAndXJpJywgZXhwZWN0ZWQ6ICd1cmwnIH0sXG4gICAgICAgIHsgaW52YWxpZDogJ2pzb24nLCBleHBlY3RlZDogJ2RhdGEnIH0sXG4gICAgICAgIHsgaW52YWxpZDogJ3FzJywgZXhwZWN0ZWQ6ICdwYXJhbXMnIH0sXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IHBhaXIgb2YgdnBhaXJzKSB7XG4gICAgICAgIGlmIChvcHRpb25zW3BhaXIuaW52YWxpZF0pIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBgJyR7cGFpci5pbnZhbGlkfScgaXMgbm90IGEgdmFsaWQgY29uZmlndXJhdGlvbiBvcHRpb24uIFBsZWFzZSB1c2UgJyR7cGFpci5leHBlY3RlZH0nIGluc3RlYWQuIFRoaXMgbGlicmFyeSBpcyB1c2luZyBBeGlvcyBmb3IgcmVxdWVzdHMuIFBsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zIHRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlIHZhbGlkIHJlcXVlc3Qgb3B0aW9ucy5gO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidmFsaWRhdGUiLCJvcHRpb25zIiwidnBhaXJzIiwiaW52YWxpZCIsImV4cGVjdGVkIiwicGFpciIsImUiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/options.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/transporters.js":
/*!********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/transporters.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DefaultTransporter = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(action-browser)/./node_modules/gaxios/build/src/index.js\");\nconst options_1 = __webpack_require__(/*! ./options */ \"(action-browser)/./node_modules/google-auth-library/build/src/options.js\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst pkg = __webpack_require__(/*! ../../package.json */ \"(action-browser)/./node_modules/google-auth-library/package.json\");\nconst PRODUCT_NAME = \"google-api-nodejs-client\";\nclass DefaultTransporter {\n    constructor(){\n        /**\n         * A configurable, replacable `Gaxios` instance.\n         */ this.instance = new gaxios_1.Gaxios();\n    }\n    /**\n     * Configures request options before making a request.\n     * @param opts GaxiosOptions options.\n     * @return Configured options.\n     */ configure(opts = {}) {\n        opts.headers = opts.headers || {};\n        if (true) {\n            // set transporter user agent if not in browser\n            const uaValue = opts.headers[\"User-Agent\"];\n            if (!uaValue) {\n                opts.headers[\"User-Agent\"] = DefaultTransporter.USER_AGENT;\n            } else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {\n                opts.headers[\"User-Agent\"] = `${uaValue} ${DefaultTransporter.USER_AGENT}`;\n            }\n            // track google-auth-library-nodejs version:\n            if (!opts.headers[\"x-goog-api-client\"]) {\n                const nodeVersion = process.version.replace(/^v/, \"\");\n                opts.headers[\"x-goog-api-client\"] = `gl-node/${nodeVersion}`;\n            }\n        }\n        return opts;\n    }\n    /**\n     * Makes a request using Gaxios with given options.\n     * @param opts GaxiosOptions options.\n     * @param callback optional callback that contains GaxiosResponse object.\n     * @return GaxiosPromise, assuming no callback is passed.\n     */ request(opts) {\n        // ensure the user isn't passing in request-style options\n        opts = this.configure(opts);\n        (0, options_1.validate)(opts);\n        return this.instance.request(opts).catch((e)=>{\n            throw this.processError(e);\n        });\n    }\n    get defaults() {\n        return this.instance.defaults;\n    }\n    set defaults(opts) {\n        this.instance.defaults = opts;\n    }\n    /**\n     * Changes the error to include details from the body.\n     */ processError(e) {\n        const res = e.response;\n        const err = e;\n        const body = res ? res.data : null;\n        if (res && body && body.error && res.status !== 200) {\n            if (typeof body.error === \"string\") {\n                err.message = body.error;\n                err.status = res.status;\n            } else if (Array.isArray(body.error.errors)) {\n                err.message = body.error.errors.map((err2)=>err2.message).join(\"\\n\");\n                err.code = body.error.code;\n                err.errors = body.error.errors;\n            } else {\n                err.message = body.error.message;\n                err.code = body.error.code;\n            }\n        } else if (res && res.status >= 400) {\n            // Consider all 4xx and 5xx responses errors.\n            err.message = body;\n            err.status = res.status;\n        }\n        return err;\n    }\n}\nexports.DefaultTransporter = DefaultTransporter;\n/**\n * Default user agent.\n */ DefaultTransporter.USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy90cmFuc3BvcnRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBRyxLQUFLO0FBQ2xDLE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLHlFQUFRO0FBQ2pDLE1BQU1DLFlBQVlELG1CQUFPQSxDQUFDLDJGQUFXO0FBQ3JDLDhEQUE4RDtBQUM5RCxNQUFNRSxNQUFNRixtQkFBT0EsQ0FBQztBQUNwQixNQUFNRyxlQUFlO0FBQ3JCLE1BQU1MO0lBQ0ZNLGFBQWM7UUFDVjs7U0FFQyxHQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUlOLFNBQVNPLE1BQU07SUFDdkM7SUFDQTs7OztLQUlDLEdBQ0RDLFVBQVVDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDakJBLEtBQUtDLE9BQU8sR0FBR0QsS0FBS0MsT0FBTyxJQUFJLENBQUM7UUFDaEMsSUFBSSxJQUFrQixFQUFhO1lBQy9CLCtDQUErQztZQUMvQyxNQUFNQyxVQUFVRixLQUFLQyxPQUFPLENBQUMsYUFBYTtZQUMxQyxJQUFJLENBQUNDLFNBQVM7Z0JBQ1ZGLEtBQUtDLE9BQU8sQ0FBQyxhQUFhLEdBQUdYLG1CQUFtQmEsVUFBVTtZQUM5RCxPQUNLLElBQUksQ0FBQ0QsUUFBUUUsUUFBUSxDQUFDLENBQUMsRUFBRVQsYUFBYSxDQUFDLENBQUMsR0FBRztnQkFDNUNLLEtBQUtDLE9BQU8sQ0FBQyxhQUFhLEdBQUcsQ0FBQyxFQUFFQyxRQUFRLENBQUMsRUFBRVosbUJBQW1CYSxVQUFVLENBQUMsQ0FBQztZQUM5RTtZQUNBLDRDQUE0QztZQUM1QyxJQUFJLENBQUNILEtBQUtDLE9BQU8sQ0FBQyxvQkFBb0IsRUFBRTtnQkFDcEMsTUFBTUksY0FBY0MsUUFBUUMsT0FBTyxDQUFDQyxPQUFPLENBQUMsTUFBTTtnQkFDbERSLEtBQUtDLE9BQU8sQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLFFBQVEsRUFBRUksWUFBWSxDQUFDO1lBQ2hFO1FBQ0o7UUFDQSxPQUFPTDtJQUNYO0lBQ0E7Ozs7O0tBS0MsR0FDRFMsUUFBUVQsSUFBSSxFQUFFO1FBQ1YseURBQXlEO1FBQ3pEQSxPQUFPLElBQUksQ0FBQ0QsU0FBUyxDQUFDQztRQUNyQixJQUFHUCxVQUFVaUIsUUFBUSxFQUFFVjtRQUN4QixPQUFPLElBQUksQ0FBQ0gsUUFBUSxDQUFDWSxPQUFPLENBQUNULE1BQU1XLEtBQUssQ0FBQ0MsQ0FBQUE7WUFDckMsTUFBTSxJQUFJLENBQUNDLFlBQVksQ0FBQ0Q7UUFDNUI7SUFDSjtJQUNBLElBQUlFLFdBQVc7UUFDWCxPQUFPLElBQUksQ0FBQ2pCLFFBQVEsQ0FBQ2lCLFFBQVE7SUFDakM7SUFDQSxJQUFJQSxTQUFTZCxJQUFJLEVBQUU7UUFDZixJQUFJLENBQUNILFFBQVEsQ0FBQ2lCLFFBQVEsR0FBR2Q7SUFDN0I7SUFDQTs7S0FFQyxHQUNEYSxhQUFhRCxDQUFDLEVBQUU7UUFDWixNQUFNRyxNQUFNSCxFQUFFSSxRQUFRO1FBQ3RCLE1BQU1DLE1BQU1MO1FBQ1osTUFBTU0sT0FBT0gsTUFBTUEsSUFBSUksSUFBSSxHQUFHO1FBQzlCLElBQUlKLE9BQU9HLFFBQVFBLEtBQUtFLEtBQUssSUFBSUwsSUFBSU0sTUFBTSxLQUFLLEtBQUs7WUFDakQsSUFBSSxPQUFPSCxLQUFLRSxLQUFLLEtBQUssVUFBVTtnQkFDaENILElBQUlLLE9BQU8sR0FBR0osS0FBS0UsS0FBSztnQkFDeEJILElBQUlJLE1BQU0sR0FBR04sSUFBSU0sTUFBTTtZQUMzQixPQUNLLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ04sS0FBS0UsS0FBSyxDQUFDSyxNQUFNLEdBQUc7Z0JBQ3ZDUixJQUFJSyxPQUFPLEdBQUdKLEtBQUtFLEtBQUssQ0FBQ0ssTUFBTSxDQUMxQkMsR0FBRyxDQUFDLENBQUNDLE9BQVNBLEtBQUtMLE9BQU8sRUFDMUJNLElBQUksQ0FBQztnQkFDVlgsSUFBSVksSUFBSSxHQUFHWCxLQUFLRSxLQUFLLENBQUNTLElBQUk7Z0JBQzFCWixJQUFJUSxNQUFNLEdBQUdQLEtBQUtFLEtBQUssQ0FBQ0ssTUFBTTtZQUNsQyxPQUNLO2dCQUNEUixJQUFJSyxPQUFPLEdBQUdKLEtBQUtFLEtBQUssQ0FBQ0UsT0FBTztnQkFDaENMLElBQUlZLElBQUksR0FBR1gsS0FBS0UsS0FBSyxDQUFDUyxJQUFJO1lBQzlCO1FBQ0osT0FDSyxJQUFJZCxPQUFPQSxJQUFJTSxNQUFNLElBQUksS0FBSztZQUMvQiw2Q0FBNkM7WUFDN0NKLElBQUlLLE9BQU8sR0FBR0o7WUFDZEQsSUFBSUksTUFBTSxHQUFHTixJQUFJTSxNQUFNO1FBQzNCO1FBQ0EsT0FBT0o7SUFDWDtBQUNKO0FBQ0E3QiwwQkFBMEIsR0FBR0U7QUFDN0I7O0NBRUMsR0FDREEsbUJBQW1CYSxVQUFVLEdBQUcsQ0FBQyxFQUFFUixhQUFhLENBQUMsRUFBRUQsSUFBSWEsT0FBTyxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvdHJhbnNwb3J0ZXJzLmpzPzc3OTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVmYXVsdFRyYW5zcG9ydGVyID0gdm9pZCAwO1xuY29uc3QgZ2F4aW9zXzEgPSByZXF1aXJlKFwiZ2F4aW9zXCIpO1xuY29uc3Qgb3B0aW9uc18xID0gcmVxdWlyZShcIi4vb3B0aW9uc1wiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG5jb25zdCBwa2cgPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKTtcbmNvbnN0IFBST0RVQ1RfTkFNRSA9ICdnb29nbGUtYXBpLW5vZGVqcy1jbGllbnQnO1xuY2xhc3MgRGVmYXVsdFRyYW5zcG9ydGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY29uZmlndXJhYmxlLCByZXBsYWNhYmxlIGBHYXhpb3NgIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBnYXhpb3NfMS5HYXhpb3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyByZXF1ZXN0IG9wdGlvbnMgYmVmb3JlIG1ha2luZyBhIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdHMgR2F4aW9zT3B0aW9ucyBvcHRpb25zLlxuICAgICAqIEByZXR1cm4gQ29uZmlndXJlZCBvcHRpb25zLlxuICAgICAqL1xuICAgIGNvbmZpZ3VyZShvcHRzID0ge30pIHtcbiAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIHNldCB0cmFuc3BvcnRlciB1c2VyIGFnZW50IGlmIG5vdCBpbiBicm93c2VyXG4gICAgICAgICAgICBjb25zdCB1YVZhbHVlID0gb3B0cy5oZWFkZXJzWydVc2VyLUFnZW50J107XG4gICAgICAgICAgICBpZiAoIXVhVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ1VzZXItQWdlbnQnXSA9IERlZmF1bHRUcmFuc3BvcnRlci5VU0VSX0FHRU5UO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXVhVmFsdWUuaW5jbHVkZXMoYCR7UFJPRFVDVF9OQU1FfS9gKSkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1snVXNlci1BZ2VudCddID0gYCR7dWFWYWx1ZX0gJHtEZWZhdWx0VHJhbnNwb3J0ZXIuVVNFUl9BR0VOVH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJhY2sgZ29vZ2xlLWF1dGgtbGlicmFyeS1ub2RlanMgdmVyc2lvbjpcbiAgICAgICAgICAgIGlmICghb3B0cy5oZWFkZXJzWyd4LWdvb2ctYXBpLWNsaWVudCddKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb24ucmVwbGFjZSgvXnYvLCAnJyk7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWyd4LWdvb2ctYXBpLWNsaWVudCddID0gYGdsLW5vZGUvJHtub2RlVmVyc2lvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIHJlcXVlc3QgdXNpbmcgR2F4aW9zIHdpdGggZ2l2ZW4gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0cyBHYXhpb3NPcHRpb25zIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgY29udGFpbnMgR2F4aW9zUmVzcG9uc2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm4gR2F4aW9zUHJvbWlzZSwgYXNzdW1pbmcgbm8gY2FsbGJhY2sgaXMgcGFzc2VkLlxuICAgICAqL1xuICAgIHJlcXVlc3Qob3B0cykge1xuICAgICAgICAvLyBlbnN1cmUgdGhlIHVzZXIgaXNuJ3QgcGFzc2luZyBpbiByZXF1ZXN0LXN0eWxlIG9wdGlvbnNcbiAgICAgICAgb3B0cyA9IHRoaXMuY29uZmlndXJlKG9wdHMpO1xuICAgICAgICAoMCwgb3B0aW9uc18xLnZhbGlkYXRlKShvcHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UucmVxdWVzdChvcHRzKS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucHJvY2Vzc0Vycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5kZWZhdWx0cztcbiAgICB9XG4gICAgc2V0IGRlZmF1bHRzKG9wdHMpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5kZWZhdWx0cyA9IG9wdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGVycm9yIHRvIGluY2x1ZGUgZGV0YWlscyBmcm9tIHRoZSBib2R5LlxuICAgICAqL1xuICAgIHByb2Nlc3NFcnJvcihlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGUucmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IGVyciA9IGU7XG4gICAgICAgIGNvbnN0IGJvZHkgPSByZXMgPyByZXMuZGF0YSA6IG51bGw7XG4gICAgICAgIGlmIChyZXMgJiYgYm9keSAmJiBib2R5LmVycm9yICYmIHJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5LmVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYm9keS5lcnJvcjtcbiAgICAgICAgICAgICAgICBlcnIuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYm9keS5lcnJvci5lcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBib2R5LmVycm9yLmVycm9yc1xuICAgICAgICAgICAgICAgICAgICAubWFwKChlcnIyKSA9PiBlcnIyLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9IGJvZHkuZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICBlcnIuZXJyb3JzID0gYm9keS5lcnJvci5lcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGJvZHkuZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9IGJvZHkuZXJyb3IuY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXMgJiYgcmVzLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIGFsbCA0eHggYW5kIDV4eCByZXNwb25zZXMgZXJyb3JzLlxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBib2R5O1xuICAgICAgICAgICAgZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG59XG5leHBvcnRzLkRlZmF1bHRUcmFuc3BvcnRlciA9IERlZmF1bHRUcmFuc3BvcnRlcjtcbi8qKlxuICogRGVmYXVsdCB1c2VyIGFnZW50LlxuICovXG5EZWZhdWx0VHJhbnNwb3J0ZXIuVVNFUl9BR0VOVCA9IGAke1BST0RVQ1RfTkFNRX0vJHtwa2cudmVyc2lvbn1gO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRGVmYXVsdFRyYW5zcG9ydGVyIiwiZ2F4aW9zXzEiLCJyZXF1aXJlIiwib3B0aW9uc18xIiwicGtnIiwiUFJPRFVDVF9OQU1FIiwiY29uc3RydWN0b3IiLCJpbnN0YW5jZSIsIkdheGlvcyIsImNvbmZpZ3VyZSIsIm9wdHMiLCJoZWFkZXJzIiwidWFWYWx1ZSIsIlVTRVJfQUdFTlQiLCJpbmNsdWRlcyIsIm5vZGVWZXJzaW9uIiwicHJvY2VzcyIsInZlcnNpb24iLCJyZXBsYWNlIiwicmVxdWVzdCIsInZhbGlkYXRlIiwiY2F0Y2giLCJlIiwicHJvY2Vzc0Vycm9yIiwiZGVmYXVsdHMiLCJyZXMiLCJyZXNwb25zZSIsImVyciIsImJvZHkiLCJkYXRhIiwiZXJyb3IiLCJzdGF0dXMiLCJtZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwiZXJyb3JzIiwibWFwIiwiZXJyMiIsImpvaW4iLCJjb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/transporters.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/build/src/util.js":
/*!************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/util.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __classPrivateFieldGet = (void 0) && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _LRUCache_instances, _LRUCache_cache, _LRUCache_moveToEnd, _LRUCache_evict;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LRUCache = exports.originalOrCamelOptions = exports.snakeToCamel = void 0;\n/**\n * Returns the camel case of a provided string.\n *\n * @remarks\n *\n * Match any `_` and not `_` pair, then return the uppercase of the not `_`\n * character.\n *\n * @internal\n *\n * @param str the string to convert\n * @returns the camelCase'd string\n */ function snakeToCamel(str) {\n    return str.replace(/([_][^_])/g, (match)=>match.slice(1).toUpperCase());\n}\nexports.snakeToCamel = snakeToCamel;\n/**\n * Get the value of `obj[key]` or `obj[camelCaseKey]`, with a preference\n * for original, non-camelCase key.\n *\n * @param obj object to lookup a value in\n * @returns a `get` function for getting `obj[key || snakeKey]`, if available\n */ function originalOrCamelOptions(obj) {\n    /**\n     *\n     * @param key an index of object, preferably snake_case\n     * @returns the value `obj[key || snakeKey]`, if available\n     */ function get(key) {\n        var _a;\n        const o = obj || {};\n        return (_a = o[key]) !== null && _a !== void 0 ? _a : o[snakeToCamel(key)];\n    }\n    return {\n        get\n    };\n}\nexports.originalOrCamelOptions = originalOrCamelOptions;\n/**\n * A simple LRU cache utility.\n * Not meant for external usage.\n *\n * @experimental\n * @internal\n */ class LRUCache {\n    constructor(options){\n        _LRUCache_instances.add(this);\n        /**\n         * Maps are in order. Thus, the older item is the first item.\n         *\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}\n         */ _LRUCache_cache.set(this, new Map());\n        this.capacity = options.capacity;\n        this.maxAge = options.maxAge;\n    }\n    /**\n     * Add an item to the cache.\n     *\n     * @param key the key to upsert\n     * @param value the value of the key\n     */ set(key, value) {\n        __classPrivateFieldGet(this, _LRUCache_instances, \"m\", _LRUCache_moveToEnd).call(this, key, value);\n        __classPrivateFieldGet(this, _LRUCache_instances, \"m\", _LRUCache_evict).call(this);\n    }\n    /**\n     * Get an item from the cache.\n     *\n     * @param key the key to retrieve\n     */ get(key) {\n        const item = __classPrivateFieldGet(this, _LRUCache_cache, \"f\").get(key);\n        if (!item) return;\n        __classPrivateFieldGet(this, _LRUCache_instances, \"m\", _LRUCache_moveToEnd).call(this, key, item.value);\n        __classPrivateFieldGet(this, _LRUCache_instances, \"m\", _LRUCache_evict).call(this);\n        return item.value;\n    }\n}\nexports.LRUCache = LRUCache;\n_LRUCache_cache = new WeakMap(), _LRUCache_instances = new WeakSet(), _LRUCache_moveToEnd = function _LRUCache_moveToEnd(key, value) {\n    __classPrivateFieldGet(this, _LRUCache_cache, \"f\").delete(key);\n    __classPrivateFieldGet(this, _LRUCache_cache, \"f\").set(key, {\n        value,\n        lastAccessed: Date.now()\n    });\n}, _LRUCache_evict = function _LRUCache_evict() {\n    const cutoffDate = this.maxAge ? Date.now() - this.maxAge : 0;\n    /**\n     * Because we know Maps are in order, this item is both the\n     * last item in the list (capacity) and oldest (maxAge).\n     */ let oldestItem = __classPrivateFieldGet(this, _LRUCache_cache, \"f\").entries().next();\n    while(!oldestItem.done && (__classPrivateFieldGet(this, _LRUCache_cache, \"f\").size > this.capacity || // too many\n    oldestItem.value[1].lastAccessed < cutoffDate // too old\n    )){\n        __classPrivateFieldGet(this, _LRUCache_cache, \"f\").delete(oldestItem.value[0]);\n        oldestItem = __classPrivateFieldGet(this, _LRUCache_cache, \"f\").entries().next();\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLElBQUlBLHlCQUF5QixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0gsVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNFLElBQUksQ0FBQ0YsTUFBTUksR0FBRyxDQUFDTCxXQUFXLE1BQU0sSUFBSUksVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDTixZQUFZRyxJQUFJQSxFQUFFSSxLQUFLLEdBQUdOLE1BQU1PLEdBQUcsQ0FBQ1I7QUFDeEY7QUFDQSxJQUFJUyxxQkFBcUJDLGlCQUFpQkMscUJBQXFCQztBQUMvREMsOENBQTZDO0lBQUVOLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RRLGdCQUFnQixHQUFHQSw4QkFBOEIsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUNoRjs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTRyxhQUFhQyxHQUFHO0lBQ3JCLE9BQU9BLElBQUlDLE9BQU8sQ0FBQyxjQUFjQyxDQUFBQSxRQUFTQSxNQUFNQyxLQUFLLENBQUMsR0FBR0MsV0FBVztBQUN4RTtBQUNBUixvQkFBb0IsR0FBR0c7QUFDdkI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsdUJBQXVCTyxHQUFHO0lBQy9COzs7O0tBSUMsR0FDRCxTQUFTaEIsSUFBSWlCLEdBQUc7UUFDWixJQUFJQztRQUNKLE1BQU1DLElBQUtILE9BQU8sQ0FBQztRQUNuQixPQUFPLENBQUNFLEtBQUtDLENBQUMsQ0FBQ0YsSUFBSSxNQUFNLFFBQVFDLE9BQU8sS0FBSyxJQUFJQSxLQUFLQyxDQUFDLENBQUNULGFBQWFPLEtBQUs7SUFDOUU7SUFDQSxPQUFPO1FBQUVqQjtJQUFJO0FBQ2pCO0FBQ0FPLDhCQUE4QixHQUFHRTtBQUNqQzs7Ozs7O0NBTUMsR0FDRCxNQUFNRDtJQUNGWSxZQUFZQyxPQUFPLENBQUU7UUFDakJwQixvQkFBb0JxQixHQUFHLENBQUMsSUFBSTtRQUM1Qjs7OztTQUlDLEdBQ0RwQixnQkFBZ0JxQixHQUFHLENBQUMsSUFBSSxFQUFFLElBQUlDO1FBQzlCLElBQUksQ0FBQ0MsUUFBUSxHQUFHSixRQUFRSSxRQUFRO1FBQ2hDLElBQUksQ0FBQ0MsTUFBTSxHQUFHTCxRQUFRSyxNQUFNO0lBQ2hDO0lBQ0E7Ozs7O0tBS0MsR0FDREgsSUFBSU4sR0FBRyxFQUFFbEIsS0FBSyxFQUFFO1FBQ1pSLHVCQUF1QixJQUFJLEVBQUVVLHFCQUFxQixLQUFLRSxxQkFBcUJMLElBQUksQ0FBQyxJQUFJLEVBQUVtQixLQUFLbEI7UUFDNUZSLHVCQUF1QixJQUFJLEVBQUVVLHFCQUFxQixLQUFLRyxpQkFBaUJOLElBQUksQ0FBQyxJQUFJO0lBQ3JGO0lBQ0E7Ozs7S0FJQyxHQUNERSxJQUFJaUIsR0FBRyxFQUFFO1FBQ0wsTUFBTVUsT0FBT3BDLHVCQUF1QixJQUFJLEVBQUVXLGlCQUFpQixLQUFLRixHQUFHLENBQUNpQjtRQUNwRSxJQUFJLENBQUNVLE1BQ0Q7UUFDSnBDLHVCQUF1QixJQUFJLEVBQUVVLHFCQUFxQixLQUFLRSxxQkFBcUJMLElBQUksQ0FBQyxJQUFJLEVBQUVtQixLQUFLVSxLQUFLNUIsS0FBSztRQUN0R1IsdUJBQXVCLElBQUksRUFBRVUscUJBQXFCLEtBQUtHLGlCQUFpQk4sSUFBSSxDQUFDLElBQUk7UUFDakYsT0FBTzZCLEtBQUs1QixLQUFLO0lBQ3JCO0FBQ0o7QUFDQVEsZ0JBQWdCLEdBQUdDO0FBQ25CTixrQkFBa0IsSUFBSTBCLFdBQVczQixzQkFBc0IsSUFBSTRCLFdBQVcxQixzQkFBc0IsU0FBU0Esb0JBQW9CYyxHQUFHLEVBQUVsQixLQUFLO0lBQy9IUix1QkFBdUIsSUFBSSxFQUFFVyxpQkFBaUIsS0FBSzRCLE1BQU0sQ0FBQ2I7SUFDMUQxQix1QkFBdUIsSUFBSSxFQUFFVyxpQkFBaUIsS0FBS3FCLEdBQUcsQ0FBQ04sS0FBSztRQUN4RGxCO1FBQ0FnQyxjQUFjQyxLQUFLQyxHQUFHO0lBQzFCO0FBQ0osR0FBRzdCLGtCQUFrQixTQUFTQTtJQUMxQixNQUFNOEIsYUFBYSxJQUFJLENBQUNSLE1BQU0sR0FBR00sS0FBS0MsR0FBRyxLQUFLLElBQUksQ0FBQ1AsTUFBTSxHQUFHO0lBQzVEOzs7S0FHQyxHQUNELElBQUlTLGFBQWE1Qyx1QkFBdUIsSUFBSSxFQUFFVyxpQkFBaUIsS0FBS2tDLE9BQU8sR0FBR0MsSUFBSTtJQUNsRixNQUFPLENBQUNGLFdBQVdHLElBQUksSUFDbEIvQyxDQUFBQSx1QkFBdUIsSUFBSSxFQUFFVyxpQkFBaUIsS0FBS3FDLElBQUksR0FBRyxJQUFJLENBQUNkLFFBQVEsSUFBSSxXQUFXO0lBQ25GVSxXQUFXcEMsS0FBSyxDQUFDLEVBQUUsQ0FBQ2dDLFlBQVksR0FBR0csV0FBWSxVQUFVO0lBQWIsRUFDbEQ7UUFDRTNDLHVCQUF1QixJQUFJLEVBQUVXLGlCQUFpQixLQUFLNEIsTUFBTSxDQUFDSyxXQUFXcEMsS0FBSyxDQUFDLEVBQUU7UUFDN0VvQyxhQUFhNUMsdUJBQXVCLElBQUksRUFBRVcsaUJBQWlCLEtBQUtrQyxPQUFPLEdBQUdDLElBQUk7SUFDbEY7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb3RpZnktdG8teW91dHViZS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy91dGlsLmpzP2FmMjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9MUlVDYWNoZV9pbnN0YW5jZXMsIF9MUlVDYWNoZV9jYWNoZSwgX0xSVUNhY2hlX21vdmVUb0VuZCwgX0xSVUNhY2hlX2V2aWN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MUlVDYWNoZSA9IGV4cG9ydHMub3JpZ2luYWxPckNhbWVsT3B0aW9ucyA9IGV4cG9ydHMuc25ha2VUb0NhbWVsID0gdm9pZCAwO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlIG9mIGEgcHJvdmlkZWQgc3RyaW5nLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogTWF0Y2ggYW55IGBfYCBhbmQgbm90IGBfYCBwYWlyLCB0aGVuIHJldHVybiB0aGUgdXBwZXJjYXNlIG9mIHRoZSBub3QgYF9gXG4gKiBjaGFyYWN0ZXIuXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHRoZSBjYW1lbENhc2UnZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gc25ha2VUb0NhbWVsKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFtfXVteX10pL2csIG1hdGNoID0+IG1hdGNoLnNsaWNlKDEpLnRvVXBwZXJDYXNlKCkpO1xufVxuZXhwb3J0cy5zbmFrZVRvQ2FtZWwgPSBzbmFrZVRvQ2FtZWw7XG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYG9ialtrZXldYCBvciBgb2JqW2NhbWVsQ2FzZUtleV1gLCB3aXRoIGEgcHJlZmVyZW5jZVxuICogZm9yIG9yaWdpbmFsLCBub24tY2FtZWxDYXNlIGtleS5cbiAqXG4gKiBAcGFyYW0gb2JqIG9iamVjdCB0byBsb29rdXAgYSB2YWx1ZSBpblxuICogQHJldHVybnMgYSBgZ2V0YCBmdW5jdGlvbiBmb3IgZ2V0dGluZyBgb2JqW2tleSB8fCBzbmFrZUtleV1gLCBpZiBhdmFpbGFibGVcbiAqL1xuZnVuY3Rpb24gb3JpZ2luYWxPckNhbWVsT3B0aW9ucyhvYmopIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgYW4gaW5kZXggb2Ygb2JqZWN0LCBwcmVmZXJhYmx5IHNuYWtlX2Nhc2VcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgYG9ialtrZXkgfHwgc25ha2VLZXldYCwgaWYgYXZhaWxhYmxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG8gPSAob2JqIHx8IHt9KTtcbiAgICAgICAgcmV0dXJuIChfYSA9IG9ba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb1tzbmFrZVRvQ2FtZWwoa2V5KV07XG4gICAgfVxuICAgIHJldHVybiB7IGdldCB9O1xufVxuZXhwb3J0cy5vcmlnaW5hbE9yQ2FtZWxPcHRpb25zID0gb3JpZ2luYWxPckNhbWVsT3B0aW9ucztcbi8qKlxuICogQSBzaW1wbGUgTFJVIGNhY2hlIHV0aWxpdHkuXG4gKiBOb3QgbWVhbnQgZm9yIGV4dGVybmFsIHVzYWdlLlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBMUlVDYWNoZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBfTFJVQ2FjaGVfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHMgYXJlIGluIG9yZGVyLiBUaHVzLCB0aGUgb2xkZXIgaXRlbSBpcyB0aGUgZmlyc3QgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcH1cbiAgICAgICAgICovXG4gICAgICAgIF9MUlVDYWNoZV9jYWNoZS5zZXQodGhpcywgbmV3IE1hcCgpKTtcbiAgICAgICAgdGhpcy5jYXBhY2l0eSA9IG9wdGlvbnMuY2FwYWNpdHk7XG4gICAgICAgIHRoaXMubWF4QWdlID0gb3B0aW9ucy5tYXhBZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBpdGVtIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1cHNlcnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIG9mIHRoZSBrZXlcbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9pbnN0YW5jZXMsIFwibVwiLCBfTFJVQ2FjaGVfbW92ZVRvRW5kKS5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9pbnN0YW5jZXMsIFwibVwiLCBfTFJVQ2FjaGVfZXZpY3QpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVtIGZyb20gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHJldHJpZXZlXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBpdGVtID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTFJVQ2FjaGVfY2FjaGUsIFwiZlwiKS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9pbnN0YW5jZXMsIFwibVwiLCBfTFJVQ2FjaGVfbW92ZVRvRW5kKS5jYWxsKHRoaXMsIGtleSwgaXRlbS52YWx1ZSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0xSVUNhY2hlX2luc3RhbmNlcywgXCJtXCIsIF9MUlVDYWNoZV9ldmljdCkuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuX0xSVUNhY2hlX2NhY2hlID0gbmV3IFdlYWtNYXAoKSwgX0xSVUNhY2hlX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9MUlVDYWNoZV9tb3ZlVG9FbmQgPSBmdW5jdGlvbiBfTFJVQ2FjaGVfbW92ZVRvRW5kKGtleSwgdmFsdWUpIHtcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9jYWNoZSwgXCJmXCIpLmRlbGV0ZShrZXkpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0xSVUNhY2hlX2NhY2hlLCBcImZcIikuc2V0KGtleSwge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbGFzdEFjY2Vzc2VkOiBEYXRlLm5vdygpLFxuICAgIH0pO1xufSwgX0xSVUNhY2hlX2V2aWN0ID0gZnVuY3Rpb24gX0xSVUNhY2hlX2V2aWN0KCkge1xuICAgIGNvbnN0IGN1dG9mZkRhdGUgPSB0aGlzLm1heEFnZSA/IERhdGUubm93KCkgLSB0aGlzLm1heEFnZSA6IDA7XG4gICAgLyoqXG4gICAgICogQmVjYXVzZSB3ZSBrbm93IE1hcHMgYXJlIGluIG9yZGVyLCB0aGlzIGl0ZW0gaXMgYm90aCB0aGVcbiAgICAgKiBsYXN0IGl0ZW0gaW4gdGhlIGxpc3QgKGNhcGFjaXR5KSBhbmQgb2xkZXN0IChtYXhBZ2UpLlxuICAgICAqL1xuICAgIGxldCBvbGRlc3RJdGVtID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTFJVQ2FjaGVfY2FjaGUsIFwiZlwiKS5lbnRyaWVzKCkubmV4dCgpO1xuICAgIHdoaWxlICghb2xkZXN0SXRlbS5kb25lICYmXG4gICAgICAgIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9jYWNoZSwgXCJmXCIpLnNpemUgPiB0aGlzLmNhcGFjaXR5IHx8IC8vIHRvbyBtYW55XG4gICAgICAgICAgICBvbGRlc3RJdGVtLnZhbHVlWzFdLmxhc3RBY2Nlc3NlZCA8IGN1dG9mZkRhdGUpIC8vIHRvbyBvbGRcbiAgICApIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTFJVQ2FjaGVfY2FjaGUsIFwiZlwiKS5kZWxldGUob2xkZXN0SXRlbS52YWx1ZVswXSk7XG4gICAgICAgIG9sZGVzdEl0ZW0gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9jYWNoZSwgXCJmXCIpLmVudHJpZXMoKS5uZXh0KCk7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwicmVjZWl2ZXIiLCJzdGF0ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInZhbHVlIiwiZ2V0IiwiX0xSVUNhY2hlX2luc3RhbmNlcyIsIl9MUlVDYWNoZV9jYWNoZSIsIl9MUlVDYWNoZV9tb3ZlVG9FbmQiLCJfTFJVQ2FjaGVfZXZpY3QiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJMUlVDYWNoZSIsIm9yaWdpbmFsT3JDYW1lbE9wdGlvbnMiLCJzbmFrZVRvQ2FtZWwiLCJzdHIiLCJyZXBsYWNlIiwibWF0Y2giLCJzbGljZSIsInRvVXBwZXJDYXNlIiwib2JqIiwia2V5IiwiX2EiLCJvIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiYWRkIiwic2V0IiwiTWFwIiwiY2FwYWNpdHkiLCJtYXhBZ2UiLCJpdGVtIiwiV2Vha01hcCIsIldlYWtTZXQiLCJkZWxldGUiLCJsYXN0QWNjZXNzZWQiLCJEYXRlIiwibm93IiwiY3V0b2ZmRGF0ZSIsIm9sZGVzdEl0ZW0iLCJlbnRyaWVzIiwibmV4dCIsImRvbmUiLCJzaXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/build/src/util.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/gcp-residency.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/gcp-residency.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.detectGCPResidency = exports.isGoogleComputeEngine = exports.isGoogleComputeEngineMACAddress = exports.isGoogleComputeEngineLinux = exports.isGoogleCloudServerless = exports.GCE_LINUX_BIOS_PATHS = void 0;\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst os_1 = __webpack_require__(/*! os */ \"os\");\n/**\n * Known paths unique to Google Compute Engine Linux instances\n */ exports.GCE_LINUX_BIOS_PATHS = {\n    BIOS_DATE: \"/sys/class/dmi/id/bios_date\",\n    BIOS_VENDOR: \"/sys/class/dmi/id/bios_vendor\"\n};\nconst GCE_MAC_ADDRESS_REGEX = /^42:01/;\n/**\n * Determines if the process is running on a Google Cloud Serverless environment (Cloud Run or Cloud Functions instance).\n *\n * Uses the:\n * - {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n * - {@link https://cloud.google.com/functions/docs/env-var Cloud Functions environment variables}.\n *\n * @returns {boolean} `true` if the process is running on GCP serverless, `false` otherwise.\n */ function isGoogleCloudServerless() {\n    /**\n     * `CLOUD_RUN_JOB` is used for Cloud Run Jobs\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n     *\n     * `FUNCTION_NAME` is used in older Cloud Functions environments:\n     * - See {@link https://cloud.google.com/functions/docs/env-var Python 3.7 and Go 1.11}.\n     *\n     * `K_SERVICE` is used in Cloud Run and newer Cloud Functions environments:\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n     * - See {@link https://cloud.google.com/functions/docs/env-var Cloud Functions newer runtimes}.\n     */ const isGFEnvironment = process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE;\n    return !!isGFEnvironment;\n}\nexports.isGoogleCloudServerless = isGoogleCloudServerless;\n/**\n * Determines if the process is running on a Linux Google Compute Engine instance.\n *\n * @returns {boolean} `true` if the process is running on Linux GCE, `false` otherwise.\n */ function isGoogleComputeEngineLinux() {\n    if ((0, os_1.platform)() !== \"linux\") return false;\n    try {\n        // ensure this file exist\n        (0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);\n        // ensure this file exist and matches\n        const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, \"utf8\");\n        return /Google/.test(biosVendor);\n    } catch (_a) {\n        return false;\n    }\n}\nexports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;\n/**\n * Determines if the process is running on a Google Compute Engine instance with a known\n * MAC address.\n *\n * @returns {boolean} `true` if the process is running on GCE (as determined by MAC address), `false` otherwise.\n */ function isGoogleComputeEngineMACAddress() {\n    const interfaces = (0, os_1.networkInterfaces)();\n    for (const item of Object.values(interfaces)){\n        if (!item) continue;\n        for (const { mac } of item){\n            if (GCE_MAC_ADDRESS_REGEX.test(mac)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;\n/**\n * Determines if the process is running on a Google Compute Engine instance.\n *\n * @returns {boolean} `true` if the process is running on GCE, `false` otherwise.\n */ function isGoogleComputeEngine() {\n    return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();\n}\nexports.isGoogleComputeEngine = isGoogleComputeEngine;\n/**\n * Determines if the process is running on Google Cloud Platform.\n *\n * @returns {boolean} `true` if the process is running on GCP, `false` otherwise.\n */ function detectGCPResidency() {\n    return isGoogleCloudServerless() || isGoogleComputeEngine();\n}\nexports.detectGCPResidency = detectGCPResidency; //# sourceMappingURL=gcp-residency.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L25vZGVfbW9kdWxlcy9nY3AtbWV0YWRhdGEvYnVpbGQvc3JjL2djcC1yZXNpZGVuY3kuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMEJBQTBCLEdBQUdBLDZCQUE2QixHQUFHQSx1Q0FBdUMsR0FBR0Esa0NBQWtDLEdBQUdBLCtCQUErQixHQUFHQSw0QkFBNEIsR0FBRyxLQUFLO0FBQ2xOLE1BQU1RLE9BQU9DLG1CQUFPQSxDQUFDLGNBQUk7QUFDekIsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUMsY0FBSTtBQUN6Qjs7Q0FFQyxHQUNEVCw0QkFBNEIsR0FBRztJQUMzQlcsV0FBVztJQUNYQyxhQUFhO0FBQ2pCO0FBQ0EsTUFBTUMsd0JBQXdCO0FBQzlCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU1A7SUFDTDs7Ozs7Ozs7OztLQVVDLEdBQ0QsTUFBTVEsa0JBQWtCQyxRQUFRQyxHQUFHLENBQUNDLGFBQWEsSUFDN0NGLFFBQVFDLEdBQUcsQ0FBQ0UsYUFBYSxJQUN6QkgsUUFBUUMsR0FBRyxDQUFDRyxTQUFTO0lBQ3pCLE9BQU8sQ0FBQyxDQUFDTDtBQUNiO0FBQ0FkLCtCQUErQixHQUFHTTtBQUNsQzs7OztDQUlDLEdBQ0QsU0FBU0Q7SUFDTCxJQUFJLENBQUMsR0FBR0ssS0FBS1UsUUFBUSxRQUFRLFNBQ3pCLE9BQU87SUFDWCxJQUFJO1FBQ0EseUJBQXlCO1FBQ3hCLElBQUdaLEtBQUthLFFBQVEsRUFBRXJCLFFBQVFPLG9CQUFvQixDQUFDSSxTQUFTO1FBQ3pELHFDQUFxQztRQUNyQyxNQUFNVyxhQUFhLENBQUMsR0FBR2QsS0FBS2UsWUFBWSxFQUFFdkIsUUFBUU8sb0JBQW9CLENBQUNLLFdBQVcsRUFBRTtRQUNwRixPQUFPLFNBQVNZLElBQUksQ0FBQ0Y7SUFDekIsRUFDQSxPQUFPRyxJQUFJO1FBQ1AsT0FBTztJQUNYO0FBQ0o7QUFDQXpCLGtDQUFrQyxHQUFHSztBQUNyQzs7Ozs7Q0FLQyxHQUNELFNBQVNEO0lBQ0wsTUFBTXNCLGFBQWEsQ0FBQyxHQUFHaEIsS0FBS2lCLGlCQUFpQjtJQUM3QyxLQUFLLE1BQU1DLFFBQVE5QixPQUFPK0IsTUFBTSxDQUFDSCxZQUFhO1FBQzFDLElBQUksQ0FBQ0UsTUFDRDtRQUNKLEtBQUssTUFBTSxFQUFFRSxHQUFHLEVBQUUsSUFBSUYsS0FBTTtZQUN4QixJQUFJZixzQkFBc0JXLElBQUksQ0FBQ00sTUFBTTtnQkFDakMsT0FBTztZQUNYO1FBQ0o7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBOUIsdUNBQXVDLEdBQUdJO0FBQzFDOzs7O0NBSUMsR0FDRCxTQUFTRDtJQUNMLE9BQU9FLGdDQUFnQ0Q7QUFDM0M7QUFDQUosNkJBQTZCLEdBQUdHO0FBQ2hDOzs7O0NBSUMsR0FDRCxTQUFTRDtJQUNMLE9BQU9JLDZCQUE2Qkg7QUFDeEM7QUFDQUgsMEJBQTBCLEdBQUdFLG9CQUM3Qix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG90aWZ5LXRvLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9ub2RlX21vZHVsZXMvZ2NwLW1ldGFkYXRhL2J1aWxkL3NyYy9nY3AtcmVzaWRlbmN5LmpzPzExM2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRldGVjdEdDUFJlc2lkZW5jeSA9IGV4cG9ydHMuaXNHb29nbGVDb21wdXRlRW5naW5lID0gZXhwb3J0cy5pc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzID0gZXhwb3J0cy5pc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eCA9IGV4cG9ydHMuaXNHb29nbGVDbG91ZFNlcnZlcmxlc3MgPSBleHBvcnRzLkdDRV9MSU5VWF9CSU9TX1BBVEhTID0gdm9pZCAwO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IG9zXzEgPSByZXF1aXJlKFwib3NcIik7XG4vKipcbiAqIEtub3duIHBhdGhzIHVuaXF1ZSB0byBHb29nbGUgQ29tcHV0ZSBFbmdpbmUgTGludXggaW5zdGFuY2VzXG4gKi9cbmV4cG9ydHMuR0NFX0xJTlVYX0JJT1NfUEFUSFMgPSB7XG4gICAgQklPU19EQVRFOiAnL3N5cy9jbGFzcy9kbWkvaWQvYmlvc19kYXRlJyxcbiAgICBCSU9TX1ZFTkRPUjogJy9zeXMvY2xhc3MvZG1pL2lkL2Jpb3NfdmVuZG9yJyxcbn07XG5jb25zdCBHQ0VfTUFDX0FERFJFU1NfUkVHRVggPSAvXjQyOjAxLztcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgR29vZ2xlIENsb3VkIFNlcnZlcmxlc3MgZW52aXJvbm1lbnQgKENsb3VkIFJ1biBvciBDbG91ZCBGdW5jdGlvbnMgaW5zdGFuY2UpLlxuICpcbiAqIFVzZXMgdGhlOlxuICogLSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3J1bi9kb2NzL2NvbnRhaW5lci1jb250cmFjdCNlbnYtdmFycyBDbG91ZCBSdW4gZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cbiAqIC0ge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9mdW5jdGlvbnMvZG9jcy9lbnYtdmFyIENsb3VkIEZ1bmN0aW9ucyBlbnZpcm9ubWVudCB2YXJpYWJsZXN9LlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBHQ1Agc2VydmVybGVzcywgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzR29vZ2xlQ2xvdWRTZXJ2ZXJsZXNzKCkge1xuICAgIC8qKlxuICAgICAqIGBDTE9VRF9SVU5fSk9CYCBpcyB1c2VkIGZvciBDbG91ZCBSdW4gSm9ic1xuICAgICAqIC0gU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vcnVuL2RvY3MvY29udGFpbmVyLWNvbnRyYWN0I2Vudi12YXJzIENsb3VkIFJ1biBlbnZpcm9ubWVudCB2YXJpYWJsZXN9LlxuICAgICAqXG4gICAgICogYEZVTkNUSU9OX05BTUVgIGlzIHVzZWQgaW4gb2xkZXIgQ2xvdWQgRnVuY3Rpb25zIGVudmlyb25tZW50czpcbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Z1bmN0aW9ucy9kb2NzL2Vudi12YXIgUHl0aG9uIDMuNyBhbmQgR28gMS4xMX0uXG4gICAgICpcbiAgICAgKiBgS19TRVJWSUNFYCBpcyB1c2VkIGluIENsb3VkIFJ1biBhbmQgbmV3ZXIgQ2xvdWQgRnVuY3Rpb25zIGVudmlyb25tZW50czpcbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3J1bi9kb2NzL2NvbnRhaW5lci1jb250cmFjdCNlbnYtdmFycyBDbG91ZCBSdW4gZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Z1bmN0aW9ucy9kb2NzL2Vudi12YXIgQ2xvdWQgRnVuY3Rpb25zIG5ld2VyIHJ1bnRpbWVzfS5cbiAgICAgKi9cbiAgICBjb25zdCBpc0dGRW52aXJvbm1lbnQgPSBwcm9jZXNzLmVudi5DTE9VRF9SVU5fSk9CIHx8XG4gICAgICAgIHByb2Nlc3MuZW52LkZVTkNUSU9OX05BTUUgfHxcbiAgICAgICAgcHJvY2Vzcy5lbnYuS19TRVJWSUNFO1xuICAgIHJldHVybiAhIWlzR0ZFbnZpcm9ubWVudDtcbn1cbmV4cG9ydHMuaXNHb29nbGVDbG91ZFNlcnZlcmxlc3MgPSBpc0dvb2dsZUNsb3VkU2VydmVybGVzcztcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgTGludXggR29vZ2xlIENvbXB1dGUgRW5naW5lIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBMaW51eCBHQ0UsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eCgpIHtcbiAgICBpZiAoKDAsIG9zXzEucGxhdGZvcm0pKCkgIT09ICdsaW51eCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBlbnN1cmUgdGhpcyBmaWxlIGV4aXN0XG4gICAgICAgICgwLCBmc18xLnN0YXRTeW5jKShleHBvcnRzLkdDRV9MSU5VWF9CSU9TX1BBVEhTLkJJT1NfREFURSk7XG4gICAgICAgIC8vIGVuc3VyZSB0aGlzIGZpbGUgZXhpc3QgYW5kIG1hdGNoZXNcbiAgICAgICAgY29uc3QgYmlvc1ZlbmRvciA9ICgwLCBmc18xLnJlYWRGaWxlU3luYykoZXhwb3J0cy5HQ0VfTElOVVhfQklPU19QQVRIUy5CSU9TX1ZFTkRPUiwgJ3V0ZjgnKTtcbiAgICAgICAgcmV0dXJuIC9Hb29nbGUvLnRlc3QoYmlvc1ZlbmRvcik7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5pc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eCA9IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZUxpbnV4O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gYSBHb29nbGUgQ29tcHV0ZSBFbmdpbmUgaW5zdGFuY2Ugd2l0aCBhIGtub3duXG4gKiBNQUMgYWRkcmVzcy5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gR0NFIChhcyBkZXRlcm1pbmVkIGJ5IE1BQyBhZGRyZXNzKSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzR29vZ2xlQ29tcHV0ZUVuZ2luZU1BQ0FkZHJlc3MoKSB7XG4gICAgY29uc3QgaW50ZXJmYWNlcyA9ICgwLCBvc18xLm5ldHdvcmtJbnRlcmZhY2VzKSgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBPYmplY3QudmFsdWVzKGludGVyZmFjZXMpKSB7XG4gICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbWFjIH0gb2YgaXRlbSkge1xuICAgICAgICAgICAgaWYgKEdDRV9NQUNfQUREUkVTU19SRUdFWC50ZXN0KG1hYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzR29vZ2xlQ29tcHV0ZUVuZ2luZU1BQ0FkZHJlc3MgPSBpc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzO1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gYSBHb29nbGUgQ29tcHV0ZSBFbmdpbmUgaW5zdGFuY2UuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdDRSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzR29vZ2xlQ29tcHV0ZUVuZ2luZSgpIHtcbiAgICByZXR1cm4gaXNHb29nbGVDb21wdXRlRW5naW5lTGludXgoKSB8fCBpc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzKCk7XG59XG5leHBvcnRzLmlzR29vZ2xlQ29tcHV0ZUVuZ2luZSA9IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdvb2dsZSBDbG91ZCBQbGF0Zm9ybS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gR0NQLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0R0NQUmVzaWRlbmN5KCkge1xuICAgIHJldHVybiBpc0dvb2dsZUNsb3VkU2VydmVybGVzcygpIHx8IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZSgpO1xufVxuZXhwb3J0cy5kZXRlY3RHQ1BSZXNpZGVuY3kgPSBkZXRlY3RHQ1BSZXNpZGVuY3k7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nY3AtcmVzaWRlbmN5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRldGVjdEdDUFJlc2lkZW5jeSIsImlzR29vZ2xlQ29tcHV0ZUVuZ2luZSIsImlzR29vZ2xlQ29tcHV0ZUVuZ2luZU1BQ0FkZHJlc3MiLCJpc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eCIsImlzR29vZ2xlQ2xvdWRTZXJ2ZXJsZXNzIiwiR0NFX0xJTlVYX0JJT1NfUEFUSFMiLCJmc18xIiwicmVxdWlyZSIsIm9zXzEiLCJCSU9TX0RBVEUiLCJCSU9TX1ZFTkRPUiIsIkdDRV9NQUNfQUREUkVTU19SRUdFWCIsImlzR0ZFbnZpcm9ubWVudCIsInByb2Nlc3MiLCJlbnYiLCJDTE9VRF9SVU5fSk9CIiwiRlVOQ1RJT05fTkFNRSIsIktfU0VSVklDRSIsInBsYXRmb3JtIiwic3RhdFN5bmMiLCJiaW9zVmVuZG9yIiwicmVhZEZpbGVTeW5jIiwidGVzdCIsIl9hIiwiaW50ZXJmYWNlcyIsIm5ldHdvcmtJbnRlcmZhY2VzIiwiaXRlbSIsInZhbHVlcyIsIm1hYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/gcp-residency.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */ var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.requestTimeout = exports.setGCPResidency = exports.getGCPResidency = exports.gcpResidencyCache = exports.resetIsAvailableCache = exports.isAvailable = exports.bulk = exports.universe = exports.project = exports.instance = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(action-browser)/./node_modules/gaxios/build/src/index.js\");\nconst jsonBigint = __webpack_require__(/*! json-bigint */ \"(action-browser)/./node_modules/json-bigint/index.js\");\nconst gcp_residency_1 = __webpack_require__(/*! ./gcp-residency */ \"(action-browser)/./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/gcp-residency.js\");\nexports.BASE_PATH = \"/computeMetadata/v1\";\nexports.HOST_ADDRESS = \"http://169.254.169.254\";\nexports.SECONDARY_HOST_ADDRESS = \"http://metadata.google.internal.\";\nexports.HEADER_NAME = \"Metadata-Flavor\";\nexports.HEADER_VALUE = \"Google\";\nexports.HEADERS = Object.freeze({\n    [exports.HEADER_NAME]: exports.HEADER_VALUE\n});\n/**\n * Metadata server detection override options.\n *\n * Available via `process.env.METADATA_SERVER_DETECTION`.\n */ exports.METADATA_SERVER_DETECTION = Object.freeze({\n    \"assume-present\": \"don't try to ping the metadata server, but assume it's present\",\n    none: \"don't try to ping the metadata server, but don't try to use it either\",\n    \"bios-only\": \"treat the result of a BIOS probe as canonical (don't fall back to pinging)\",\n    \"ping-only\": \"skip the BIOS probe, and go straight to pinging\"\n});\n/**\n * Returns the base URL while taking into account the GCE_METADATA_HOST\n * environment variable if it exists.\n *\n * @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.\n */ function getBaseUrl(baseUrl) {\n    if (!baseUrl) {\n        baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;\n    }\n    // If no scheme is provided default to HTTP:\n    if (!/^https?:\\/\\//.test(baseUrl)) {\n        baseUrl = `http://${baseUrl}`;\n    }\n    return new URL(exports.BASE_PATH, baseUrl).href;\n}\n// Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\nfunction validate(options) {\n    Object.keys(options).forEach((key)=>{\n        switch(key){\n            case \"params\":\n            case \"property\":\n            case \"headers\":\n                break;\n            case \"qs\":\n                throw new Error(\"'qs' is not a valid configuration option. Please use 'params' instead.\");\n            default:\n                throw new Error(`'${key}' is not a valid configuration option.`);\n        }\n    });\n}\nasync function metadataAccessor(type, options = {}, noResponseRetries = 3, fastFail = false) {\n    let metadataKey = \"\";\n    let params = {};\n    let headers = {};\n    if (typeof type === \"object\") {\n        const metadataAccessor = type;\n        metadataKey = metadataAccessor.metadataKey;\n        params = metadataAccessor.params || params;\n        headers = metadataAccessor.headers || headers;\n        noResponseRetries = metadataAccessor.noResponseRetries || noResponseRetries;\n        fastFail = metadataAccessor.fastFail || fastFail;\n    } else {\n        metadataKey = type;\n    }\n    if (typeof options === \"string\") {\n        metadataKey += `/${options}`;\n    } else {\n        validate(options);\n        if (options.property) {\n            metadataKey += `/${options.property}`;\n        }\n        headers = options.headers || headers;\n        params = options.params || params;\n    }\n    try {\n        const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\n        const res = await requestMethod({\n            url: `${getBaseUrl()}/${metadataKey}`,\n            headers: {\n                ...exports.HEADERS,\n                ...headers\n            },\n            retryConfig: {\n                noResponseRetries\n            },\n            params,\n            responseType: \"text\",\n            timeout: requestTimeout()\n        });\n        // NOTE: node.js converts all incoming headers to lower case.\n        if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {\n            throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header.`);\n        } else if (!res.data) {\n            throw new Error(\"Invalid response from the metadata service\");\n        }\n        if (typeof res.data === \"string\") {\n            try {\n                return jsonBigint.parse(res.data);\n            } catch (_a) {\n            /* ignore */ }\n        }\n        return res.data;\n    } catch (e) {\n        const err = e;\n        if (err.response && err.response.status !== 200) {\n            err.message = `Unsuccessful response status code. ${err.message}`;\n        }\n        throw e;\n    }\n}\nasync function fastFailMetadataRequest(options) {\n    const secondaryOptions = {\n        ...options,\n        url: options.url.replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS))\n    };\n    // We race a connection between DNS/IP to metadata server. There are a couple\n    // reasons for this:\n    //\n    // 1. the DNS is slow in some GCP environments; by checking both, we might\n    //    detect the runtime environment signficantly faster.\n    // 2. we can't just check the IP, which is tarpitted and slow to respond\n    //    on a user's local machine.\n    //\n    // Additional logic has been added to make sure that we don't create an\n    // unhandled rejection in scenarios where a failure happens sometime\n    // after a success.\n    //\n    // Note, however, if a failure happens prior to a success, a rejection should\n    // occur, this is for folks running locally.\n    //\n    let responded = false;\n    const r1 = (0, gaxios_1.request)(options).then((res)=>{\n        responded = true;\n        return res;\n    }).catch((err)=>{\n        if (responded) {\n            return r2;\n        } else {\n            responded = true;\n            throw err;\n        }\n    });\n    const r2 = (0, gaxios_1.request)(secondaryOptions).then((res)=>{\n        responded = true;\n        return res;\n    }).catch((err)=>{\n        if (responded) {\n            return r1;\n        } else {\n            responded = true;\n            throw err;\n        }\n    });\n    return Promise.race([\n        r1,\n        r2\n    ]);\n}\n/**\n * Obtain metadata for the current GCE instance.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const serviceAccount: {} = await instance('service-accounts/');\n * const serviceAccountEmail: string = await instance('service-accounts/default/email');\n * ```\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction instance(options) {\n    return metadataAccessor(\"instance\", options);\n}\nexports.instance = instance;\n/**\n * Obtain metadata for the current GCP project.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const projectId: string = await project('project-id');\n * const numericProjectId: number = await project('numeric-project-id');\n * ```\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction project(options) {\n    return metadataAccessor(\"project\", options);\n}\nexports.project = project;\n/**\n * Obtain metadata for the current universe.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const universeDomain: string = await universe('universe_domain');\n * ```\n */ function universe(options) {\n    return metadataAccessor(\"universe\", options);\n}\nexports.universe = universe;\n/**\n * Retrieve metadata items in parallel.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const data = await bulk([\n *   {\n *     metadataKey: 'instance',\n *   },\n *   {\n *     metadataKey: 'project/project-id',\n *   },\n * ] as const);\n *\n * // data.instance;\n * // data['project/project-id'];\n * ```\n *\n * @param properties The metadata properties to retrieve\n * @returns The metadata in `metadatakey:value` format\n */ async function bulk(properties) {\n    const r = {};\n    await Promise.all(properties.map((item)=>{\n        return (async ()=>{\n            const res = await metadataAccessor(item);\n            const key = item.metadataKey;\n            r[key] = res;\n        })();\n    }));\n    return r;\n}\nexports.bulk = bulk;\n/*\n * How many times should we retry detecting GCP environment.\n */ function detectGCPAvailableRetries() {\n    return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;\n}\nlet cachedIsAvailableResponse;\n/**\n * Determine if the metadata server is currently available.\n */ async function isAvailable() {\n    if (process.env.METADATA_SERVER_DETECTION) {\n        const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();\n        if (!(value in exports.METADATA_SERVER_DETECTION)) {\n            throw new RangeError(`Unknown \\`METADATA_SERVER_DETECTION\\` env variable. Got \\`${value}\\`, but it should be \\`${Object.keys(exports.METADATA_SERVER_DETECTION).join(\"`, `\")}\\`, or unset`);\n        }\n        switch(value){\n            case \"assume-present\":\n                return true;\n            case \"none\":\n                return false;\n            case \"bios-only\":\n                return getGCPResidency();\n            case \"ping-only\":\n        }\n    }\n    try {\n        // If a user is instantiating several GCP libraries at the same time,\n        // this may result in multiple calls to isAvailable(), to detect the\n        // runtime environment. We use the same promise for each of these calls\n        // to reduce the network load.\n        if (cachedIsAvailableResponse === undefined) {\n            cachedIsAvailableResponse = metadataAccessor(\"instance\", undefined, detectGCPAvailableRetries(), // If the default HOST_ADDRESS has been overridden, we should not\n            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in\n            // a non-GCP environment):\n            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));\n        }\n        await cachedIsAvailableResponse;\n        return true;\n    } catch (e) {\n        const err = e;\n        if (process.env.DEBUG_AUTH) {\n            console.info(err);\n        }\n        if (err.type === \"request-timeout\") {\n            // If running in a GCP environment, metadata endpoint should return\n            // within ms.\n            return false;\n        }\n        if (err.response && err.response.status === 404) {\n            return false;\n        } else {\n            if (!(err.response && err.response.status === 404) && // A warning is emitted if we see an unexpected err.code, or err.code\n            // is not populated:\n            (!err.code || ![\n                \"EHOSTDOWN\",\n                \"EHOSTUNREACH\",\n                \"ENETUNREACH\",\n                \"ENOENT\",\n                \"ENOTFOUND\",\n                \"ECONNREFUSED\"\n            ].includes(err.code))) {\n                let code = \"UNKNOWN\";\n                if (err.code) code = err.code;\n                process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, \"MetadataLookupWarning\");\n            }\n            // Failure to resolve the metadata service means that it is not available.\n            return false;\n        }\n    }\n}\nexports.isAvailable = isAvailable;\n/**\n * reset the memoized isAvailable() lookup.\n */ function resetIsAvailableCache() {\n    cachedIsAvailableResponse = undefined;\n}\nexports.resetIsAvailableCache = resetIsAvailableCache;\n/**\n * A cache for the detected GCP Residency.\n */ exports.gcpResidencyCache = null;\n/**\n * Detects GCP Residency.\n * Caches results to reduce costs for subsequent calls.\n *\n * @see setGCPResidency for setting\n */ function getGCPResidency() {\n    if (exports.gcpResidencyCache === null) {\n        setGCPResidency();\n    }\n    return exports.gcpResidencyCache;\n}\nexports.getGCPResidency = getGCPResidency;\n/**\n * Sets the detected GCP Residency.\n * Useful for forcing metadata server detection behavior.\n *\n * Set `null` to autodetect the environment (default behavior).\n * @see getGCPResidency for getting\n */ function setGCPResidency(value = null) {\n    exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();\n}\nexports.setGCPResidency = setGCPResidency;\n/**\n * Obtain the timeout for requests to the metadata server.\n *\n * In certain environments and conditions requests can take longer than\n * the default timeout to complete. This function will determine the\n * appropriate timeout based on the environment.\n *\n * @returns {number} a request timeout duration in milliseconds.\n */ function requestTimeout() {\n    return getGCPResidency() ? 0 : 3000;\n}\nexports.requestTimeout = requestTimeout;\n__exportStar(__webpack_require__(/*! ./gcp-residency */ \"(action-browser)/./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/gcp-residency.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L25vZGVfbW9kdWxlcy9nY3AtbWV0YWRhdGEvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7O0NBS0MsR0FDRCxJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4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bkIvRCxRQUFRaUUsV0FBVyxDQUFDLENBQUMsNEJBQTRCLEVBQUUvQixJQUFJRyxPQUFPLENBQUMsUUFBUSxFQUFFMEIsS0FBSyxDQUFDLEVBQUU7WUFDckY7WUFDQSwwRUFBMEU7WUFDMUUsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBOUYsbUJBQW1CLEdBQUdXO0FBQ3RCOztDQUVDLEdBQ0QsU0FBU0Q7SUFDTDRFLDRCQUE0QmhHO0FBQ2hDO0FBQ0FVLDZCQUE2QixHQUFHVTtBQUNoQzs7Q0FFQyxHQUNEVix5QkFBeUIsR0FBRztBQUM1Qjs7Ozs7Q0FLQyxHQUNELFNBQVNRO0lBQ0wsSUFBSVIsUUFBUVMsaUJBQWlCLEtBQUssTUFBTTtRQUNwQ0Y7SUFDSjtJQUNBLE9BQU9QLFFBQVFTLGlCQUFpQjtBQUNwQztBQUNBVCx1QkFBdUIsR0FBR1E7QUFDMUI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsZ0JBQWdCRixRQUFRLElBQUk7SUFDakNMLHlCQUF5QixHQUFHSyxVQUFVLE9BQU9BLFFBQVEsQ0FBQyxHQUFHcUIsZ0JBQWdCdUUsa0JBQWtCO0FBQy9GO0FBQ0FqRyx1QkFBdUIsR0FBR087QUFDMUI7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTRDtJQUNMLE9BQU9FLG9CQUFvQixJQUFJO0FBQ25DO0FBQ0FSLHNCQUFzQixHQUFHTTtBQUN6QlAsYUFBYXlCLG1CQUFPQSxDQUFDLGlJQUFpQixHQUFHeEIsVUFDekMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvdGlmeS10by15b3V0dWJlLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvbm9kZV9tb2R1bGVzL2djcC1tZXRhZGF0YS9idWlsZC9zcmMvaW5kZXguanM/YjA1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogU2VlIGZpbGUgTElDRU5TRSBmb3IgZGV0YWlsIG9yIGNvcHkgYXQgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlcXVlc3RUaW1lb3V0ID0gZXhwb3J0cy5zZXRHQ1BSZXNpZGVuY3kgPSBleHBvcnRzLmdldEdDUFJlc2lkZW5jeSA9IGV4cG9ydHMuZ2NwUmVzaWRlbmN5Q2FjaGUgPSBleHBvcnRzLnJlc2V0SXNBdmFpbGFibGVDYWNoZSA9IGV4cG9ydHMuaXNBdmFpbGFibGUgPSBleHBvcnRzLmJ1bGsgPSBleHBvcnRzLnVuaXZlcnNlID0gZXhwb3J0cy5wcm9qZWN0ID0gZXhwb3J0cy5pbnN0YW5jZSA9IGV4cG9ydHMuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTiA9IGV4cG9ydHMuSEVBREVSUyA9IGV4cG9ydHMuSEVBREVSX1ZBTFVFID0gZXhwb3J0cy5IRUFERVJfTkFNRSA9IGV4cG9ydHMuU0VDT05EQVJZX0hPU1RfQUREUkVTUyA9IGV4cG9ydHMuSE9TVF9BRERSRVNTID0gZXhwb3J0cy5CQVNFX1BBVEggPSB2b2lkIDA7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBqc29uQmlnaW50ID0gcmVxdWlyZShcImpzb24tYmlnaW50XCIpO1xuY29uc3QgZ2NwX3Jlc2lkZW5jeV8xID0gcmVxdWlyZShcIi4vZ2NwLXJlc2lkZW5jeVwiKTtcbmV4cG9ydHMuQkFTRV9QQVRIID0gJy9jb21wdXRlTWV0YWRhdGEvdjEnO1xuZXhwb3J0cy5IT1NUX0FERFJFU1MgPSAnaHR0cDovLzE2OS4yNTQuMTY5LjI1NCc7XG5leHBvcnRzLlNFQ09OREFSWV9IT1NUX0FERFJFU1MgPSAnaHR0cDovL21ldGFkYXRhLmdvb2dsZS5pbnRlcm5hbC4nO1xuZXhwb3J0cy5IRUFERVJfTkFNRSA9ICdNZXRhZGF0YS1GbGF2b3InO1xuZXhwb3J0cy5IRUFERVJfVkFMVUUgPSAnR29vZ2xlJztcbmV4cG9ydHMuSEVBREVSUyA9IE9iamVjdC5mcmVlemUoeyBbZXhwb3J0cy5IRUFERVJfTkFNRV06IGV4cG9ydHMuSEVBREVSX1ZBTFVFIH0pO1xuLyoqXG4gKiBNZXRhZGF0YSBzZXJ2ZXIgZGV0ZWN0aW9uIG92ZXJyaWRlIG9wdGlvbnMuXG4gKlxuICogQXZhaWxhYmxlIHZpYSBgcHJvY2Vzcy5lbnYuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTmAuXG4gKi9cbmV4cG9ydHMuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTiA9IE9iamVjdC5mcmVlemUoe1xuICAgICdhc3N1bWUtcHJlc2VudCc6IFwiZG9uJ3QgdHJ5IHRvIHBpbmcgdGhlIG1ldGFkYXRhIHNlcnZlciwgYnV0IGFzc3VtZSBpdCdzIHByZXNlbnRcIixcbiAgICBub25lOiBcImRvbid0IHRyeSB0byBwaW5nIHRoZSBtZXRhZGF0YSBzZXJ2ZXIsIGJ1dCBkb24ndCB0cnkgdG8gdXNlIGl0IGVpdGhlclwiLFxuICAgICdiaW9zLW9ubHknOiBcInRyZWF0IHRoZSByZXN1bHQgb2YgYSBCSU9TIHByb2JlIGFzIGNhbm9uaWNhbCAoZG9uJ3QgZmFsbCBiYWNrIHRvIHBpbmdpbmcpXCIsXG4gICAgJ3Bpbmctb25seSc6ICdza2lwIHRoZSBCSU9TIHByb2JlLCBhbmQgZ28gc3RyYWlnaHQgdG8gcGluZ2luZycsXG59KTtcbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSBVUkwgd2hpbGUgdGFraW5nIGludG8gYWNjb3VudCB0aGUgR0NFX01FVEFEQVRBX0hPU1RcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgYmFzZSBVUkwsIGUuZy4sIGh0dHA6Ly8xNjkuMjU0LjE2OS4yNTQvY29tcHV0ZU1ldGFkYXRhL3YxLlxuICovXG5mdW5jdGlvbiBnZXRCYXNlVXJsKGJhc2VVcmwpIHtcbiAgICBpZiAoIWJhc2VVcmwpIHtcbiAgICAgICAgYmFzZVVybCA9XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5HQ0VfTUVUQURBVEFfSVAgfHxcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5HQ0VfTUVUQURBVEFfSE9TVCB8fFxuICAgICAgICAgICAgICAgIGV4cG9ydHMuSE9TVF9BRERSRVNTO1xuICAgIH1cbiAgICAvLyBJZiBubyBzY2hlbWUgaXMgcHJvdmlkZWQgZGVmYXVsdCB0byBIVFRQOlxuICAgIGlmICghL15odHRwcz86XFwvXFwvLy50ZXN0KGJhc2VVcmwpKSB7XG4gICAgICAgIGJhc2VVcmwgPSBgaHR0cDovLyR7YmFzZVVybH1gO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVSTChleHBvcnRzLkJBU0VfUEFUSCwgYmFzZVVybCkuaHJlZjtcbn1cbi8vIEFjY2VwdHMgYW4gb3B0aW9ucyBvYmplY3QgcGFzc2VkIGZyb20gdGhlIHVzZXIgdG8gdGhlIEFQSS4gSW4gcHJldmlvdXNcbi8vIHZlcnNpb25zIG9mIHRoZSBBUEksIGl0IHJlZmVycmVkIHRvIGEgYFJlcXVlc3RgIG9yIGFuIGBBeGlvc2AgcmVxdWVzdFxuLy8gb3B0aW9ucyBvYmplY3QuICBOb3cgaXQgcmVmZXJzIHRvIGFuIG9iamVjdCB3aXRoIHZlcnkgbGltaXRlZCBwcm9wZXJ0eVxuLy8gbmFtZXMuIFRoaXMgaXMgaGVyZSB0byBoZWxwIGVuc3VyZSB1c2VycyBkb24ndCBwYXNzIGludmFsaWQgb3B0aW9ucyB3aGVuXG4vLyB0aGV5ICB1cGdyYWRlIGZyb20gMC40IHRvIDAuNSB0byAwLjguXG5mdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAncGFyYW1zJzpcbiAgICAgICAgICAgIGNhc2UgJ3Byb3BlcnR5JzpcbiAgICAgICAgICAgIGNhc2UgJ2hlYWRlcnMnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXMnOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidxcycgaXMgbm90IGEgdmFsaWQgY29uZmlndXJhdGlvbiBvcHRpb24uIFBsZWFzZSB1c2UgJ3BhcmFtcycgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7a2V5fScgaXMgbm90IGEgdmFsaWQgY29uZmlndXJhdGlvbiBvcHRpb24uYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1ldGFkYXRhQWNjZXNzb3IodHlwZSwgb3B0aW9ucyA9IHt9LCBub1Jlc3BvbnNlUmV0cmllcyA9IDMsIGZhc3RGYWlsID0gZmFsc2UpIHtcbiAgICBsZXQgbWV0YWRhdGFLZXkgPSAnJztcbiAgICBsZXQgcGFyYW1zID0ge307XG4gICAgbGV0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhQWNjZXNzb3IgPSB0eXBlO1xuICAgICAgICBtZXRhZGF0YUtleSA9IG1ldGFkYXRhQWNjZXNzb3IubWV0YWRhdGFLZXk7XG4gICAgICAgIHBhcmFtcyA9IG1ldGFkYXRhQWNjZXNzb3IucGFyYW1zIHx8IHBhcmFtcztcbiAgICAgICAgaGVhZGVycyA9IG1ldGFkYXRhQWNjZXNzb3IuaGVhZGVycyB8fCBoZWFkZXJzO1xuICAgICAgICBub1Jlc3BvbnNlUmV0cmllcyA9IG1ldGFkYXRhQWNjZXNzb3Iubm9SZXNwb25zZVJldHJpZXMgfHwgbm9SZXNwb25zZVJldHJpZXM7XG4gICAgICAgIGZhc3RGYWlsID0gbWV0YWRhdGFBY2Nlc3Nvci5mYXN0RmFpbCB8fCBmYXN0RmFpbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1ldGFkYXRhS2V5ID0gdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBtZXRhZGF0YUtleSArPSBgLyR7b3B0aW9uc31gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsaWRhdGUob3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLnByb3BlcnR5KSB7XG4gICAgICAgICAgICBtZXRhZGF0YUtleSArPSBgLyR7b3B0aW9ucy5wcm9wZXJ0eX1gO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwgaGVhZGVycztcbiAgICAgICAgcGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwgcGFyYW1zO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXF1ZXN0TWV0aG9kID0gZmFzdEZhaWwgPyBmYXN0RmFpbE1ldGFkYXRhUmVxdWVzdCA6IGdheGlvc18xLnJlcXVlc3Q7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3RNZXRob2Qoe1xuICAgICAgICAgICAgdXJsOiBgJHtnZXRCYXNlVXJsKCl9LyR7bWV0YWRhdGFLZXl9YCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4uZXhwb3J0cy5IRUFERVJTLCAuLi5oZWFkZXJzIH0sXG4gICAgICAgICAgICByZXRyeUNvbmZpZzogeyBub1Jlc3BvbnNlUmV0cmllcyB9LFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICAgICAgICB0aW1lb3V0OiByZXF1ZXN0VGltZW91dCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogbm9kZS5qcyBjb252ZXJ0cyBhbGwgaW5jb21pbmcgaGVhZGVycyB0byBsb3dlciBjYXNlLlxuICAgICAgICBpZiAocmVzLmhlYWRlcnNbZXhwb3J0cy5IRUFERVJfTkFNRS50b0xvd2VyQ2FzZSgpXSAhPT0gZXhwb3J0cy5IRUFERVJfVkFMVUUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZSBmcm9tIG1ldGFkYXRhIHNlcnZpY2U6IGluY29ycmVjdCAke2V4cG9ydHMuSEVBREVSX05BTUV9IGhlYWRlci5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcmVzLmRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmcm9tIHRoZSBtZXRhZGF0YSBzZXJ2aWNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXMuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25CaWdpbnQucGFyc2UocmVzLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgLyogaWdub3JlICovXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnIgPSBlO1xuICAgICAgICBpZiAoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgVW5zdWNjZXNzZnVsIHJlc3BvbnNlIHN0YXR1cyBjb2RlLiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBmYXN0RmFpbE1ldGFkYXRhUmVxdWVzdChvcHRpb25zKSB7XG4gICAgY29uc3Qgc2Vjb25kYXJ5T3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgdXJsOiBvcHRpb25zLnVybC5yZXBsYWNlKGdldEJhc2VVcmwoKSwgZ2V0QmFzZVVybChleHBvcnRzLlNFQ09OREFSWV9IT1NUX0FERFJFU1MpKSxcbiAgICB9O1xuICAgIC8vIFdlIHJhY2UgYSBjb25uZWN0aW9uIGJldHdlZW4gRE5TL0lQIHRvIG1ldGFkYXRhIHNlcnZlci4gVGhlcmUgYXJlIGEgY291cGxlXG4gICAgLy8gcmVhc29ucyBmb3IgdGhpczpcbiAgICAvL1xuICAgIC8vIDEuIHRoZSBETlMgaXMgc2xvdyBpbiBzb21lIEdDUCBlbnZpcm9ubWVudHM7IGJ5IGNoZWNraW5nIGJvdGgsIHdlIG1pZ2h0XG4gICAgLy8gICAgZGV0ZWN0IHRoZSBydW50aW1lIGVudmlyb25tZW50IHNpZ25maWNhbnRseSBmYXN0ZXIuXG4gICAgLy8gMi4gd2UgY2FuJ3QganVzdCBjaGVjayB0aGUgSVAsIHdoaWNoIGlzIHRhcnBpdHRlZCBhbmQgc2xvdyB0byByZXNwb25kXG4gICAgLy8gICAgb24gYSB1c2VyJ3MgbG9jYWwgbWFjaGluZS5cbiAgICAvL1xuICAgIC8vIEFkZGl0aW9uYWwgbG9naWMgaGFzIGJlZW4gYWRkZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgY3JlYXRlIGFuXG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbiBpbiBzY2VuYXJpb3Mgd2hlcmUgYSBmYWlsdXJlIGhhcHBlbnMgc29tZXRpbWVcbiAgICAvLyBhZnRlciBhIHN1Y2Nlc3MuXG4gICAgLy9cbiAgICAvLyBOb3RlLCBob3dldmVyLCBpZiBhIGZhaWx1cmUgaGFwcGVucyBwcmlvciB0byBhIHN1Y2Nlc3MsIGEgcmVqZWN0aW9uIHNob3VsZFxuICAgIC8vIG9jY3VyLCB0aGlzIGlzIGZvciBmb2xrcyBydW5uaW5nIGxvY2FsbHkuXG4gICAgLy9cbiAgICBsZXQgcmVzcG9uZGVkID0gZmFsc2U7XG4gICAgY29uc3QgcjEgPSAoMCwgZ2F4aW9zXzEucmVxdWVzdCkob3B0aW9ucylcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgcmVzcG9uZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHIyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHIyID0gKDAsIGdheGlvc18xLnJlcXVlc3QpKHNlY29uZGFyeU9wdGlvbnMpXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChyZXNwb25kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtyMSwgcjJdKTtcbn1cbi8qKlxuICogT2J0YWluIG1ldGFkYXRhIGZvciB0aGUgY3VycmVudCBHQ0UgaW5zdGFuY2UuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2NvbXB1dGUvZG9jcy9tZXRhZGF0YS9wcmVkZWZpbmVkLW1ldGFkYXRhLWtleXN9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3Qgc2VydmljZUFjY291bnQ6IHt9ID0gYXdhaXQgaW5zdGFuY2UoJ3NlcnZpY2UtYWNjb3VudHMvJyk7XG4gKiBjb25zdCBzZXJ2aWNlQWNjb3VudEVtYWlsOiBzdHJpbmcgPSBhd2FpdCBpbnN0YW5jZSgnc2VydmljZS1hY2NvdW50cy9kZWZhdWx0L2VtYWlsJyk7XG4gKiBgYGBcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGluc3RhbmNlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWV0YWRhdGFBY2Nlc3NvcignaW5zdGFuY2UnLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbi8qKlxuICogT2J0YWluIG1ldGFkYXRhIGZvciB0aGUgY3VycmVudCBHQ1AgcHJvamVjdC5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vY29tcHV0ZS9kb2NzL21ldGFkYXRhL3ByZWRlZmluZWQtbWV0YWRhdGEta2V5c31cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBwcm9qZWN0SWQ6IHN0cmluZyA9IGF3YWl0IHByb2plY3QoJ3Byb2plY3QtaWQnKTtcbiAqIGNvbnN0IG51bWVyaWNQcm9qZWN0SWQ6IG51bWJlciA9IGF3YWl0IHByb2plY3QoJ251bWVyaWMtcHJvamVjdC1pZCcpO1xuICogYGBgXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBwcm9qZWN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWV0YWRhdGFBY2Nlc3NvcigncHJvamVjdCcsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5wcm9qZWN0ID0gcHJvamVjdDtcbi8qKlxuICogT2J0YWluIG1ldGFkYXRhIGZvciB0aGUgY3VycmVudCB1bml2ZXJzZS5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vY29tcHV0ZS9kb2NzL21ldGFkYXRhL3ByZWRlZmluZWQtbWV0YWRhdGEta2V5c31cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCB1bml2ZXJzZURvbWFpbjogc3RyaW5nID0gYXdhaXQgdW5pdmVyc2UoJ3VuaXZlcnNlX2RvbWFpbicpO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVuaXZlcnNlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWV0YWRhdGFBY2Nlc3NvcigndW5pdmVyc2UnLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMudW5pdmVyc2UgPSB1bml2ZXJzZTtcbi8qKlxuICogUmV0cmlldmUgbWV0YWRhdGEgaXRlbXMgaW4gcGFyYWxsZWwuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2NvbXB1dGUvZG9jcy9tZXRhZGF0YS9wcmVkZWZpbmVkLW1ldGFkYXRhLWtleXN9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3QgZGF0YSA9IGF3YWl0IGJ1bGsoW1xuICogICB7XG4gKiAgICAgbWV0YWRhdGFLZXk6ICdpbnN0YW5jZScsXG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBtZXRhZGF0YUtleTogJ3Byb2plY3QvcHJvamVjdC1pZCcsXG4gKiAgIH0sXG4gKiBdIGFzIGNvbnN0KTtcbiAqXG4gKiAvLyBkYXRhLmluc3RhbmNlO1xuICogLy8gZGF0YVsncHJvamVjdC9wcm9qZWN0LWlkJ107XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHJvcGVydGllcyBUaGUgbWV0YWRhdGEgcHJvcGVydGllcyB0byByZXRyaWV2ZVxuICogQHJldHVybnMgVGhlIG1ldGFkYXRhIGluIGBtZXRhZGF0YWtleTp2YWx1ZWAgZm9ybWF0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGJ1bGsocHJvcGVydGllcykge1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9wZXJ0aWVzLm1hcChpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBtZXRhZGF0YUFjY2Vzc29yKGl0ZW0pO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaXRlbS5tZXRhZGF0YUtleTtcbiAgICAgICAgICAgIHJba2V5XSA9IHJlcztcbiAgICAgICAgfSkoKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnRzLmJ1bGsgPSBidWxrO1xuLypcbiAqIEhvdyBtYW55IHRpbWVzIHNob3VsZCB3ZSByZXRyeSBkZXRlY3RpbmcgR0NQIGVudmlyb25tZW50LlxuICovXG5mdW5jdGlvbiBkZXRlY3RHQ1BBdmFpbGFibGVSZXRyaWVzKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ERVRFQ1RfR0NQX1JFVFJJRVNcbiAgICAgICAgPyBOdW1iZXIocHJvY2Vzcy5lbnYuREVURUNUX0dDUF9SRVRSSUVTKVxuICAgICAgICA6IDA7XG59XG5sZXQgY2FjaGVkSXNBdmFpbGFibGVSZXNwb25zZTtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBtZXRhZGF0YSBzZXJ2ZXIgaXMgY3VycmVudGx5IGF2YWlsYWJsZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaXNBdmFpbGFibGUoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9jZXNzLmVudi5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OLnRyaW0oKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoISh2YWx1ZSBpbiBleHBvcnRzLk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5rbm93biBcXGBNRVRBREFUQV9TRVJWRVJfREVURUNUSU9OXFxgIGVudiB2YXJpYWJsZS4gR290IFxcYCR7dmFsdWV9XFxgLCBidXQgaXQgc2hvdWxkIGJlIFxcYCR7T2JqZWN0LmtleXMoZXhwb3J0cy5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OKS5qb2luKCdgLCBgJyl9XFxgLCBvciB1bnNldGApO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Fzc3VtZS1wcmVzZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgJ2Jpb3Mtb25seSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEdDUFJlc2lkZW5jeSgpO1xuICAgICAgICAgICAgY2FzZSAncGluZy1vbmx5JzpcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlLCB3ZSB3YW50IHRvIHBpbmcgdGhlIHNlcnZlclxuICAgICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIElmIGEgdXNlciBpcyBpbnN0YW50aWF0aW5nIHNldmVyYWwgR0NQIGxpYnJhcmllcyBhdCB0aGUgc2FtZSB0aW1lLFxuICAgICAgICAvLyB0aGlzIG1heSByZXN1bHQgaW4gbXVsdGlwbGUgY2FsbHMgdG8gaXNBdmFpbGFibGUoKSwgdG8gZGV0ZWN0IHRoZVxuICAgICAgICAvLyBydW50aW1lIGVudmlyb25tZW50LiBXZSB1c2UgdGhlIHNhbWUgcHJvbWlzZSBmb3IgZWFjaCBvZiB0aGVzZSBjYWxsc1xuICAgICAgICAvLyB0byByZWR1Y2UgdGhlIG5ldHdvcmsgbG9hZC5cbiAgICAgICAgaWYgKGNhY2hlZElzQXZhaWxhYmxlUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FjaGVkSXNBdmFpbGFibGVSZXNwb25zZSA9IG1ldGFkYXRhQWNjZXNzb3IoJ2luc3RhbmNlJywgdW5kZWZpbmVkLCBkZXRlY3RHQ1BBdmFpbGFibGVSZXRyaWVzKCksIFxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlZmF1bHQgSE9TVF9BRERSRVNTIGhhcyBiZWVuIG92ZXJyaWRkZW4sIHdlIHNob3VsZCBub3RcbiAgICAgICAgICAgIC8vIG1ha2UgYW4gZWZmb3J0IHRvIHRyeSBTRUNPTkRBUllfSE9TVF9BRERSRVNTIChhcyB3ZSBhcmUgbGlrZWx5IGluXG4gICAgICAgICAgICAvLyBhIG5vbi1HQ1AgZW52aXJvbm1lbnQpOlxuICAgICAgICAgICAgIShwcm9jZXNzLmVudi5HQ0VfTUVUQURBVEFfSVAgfHwgcHJvY2Vzcy5lbnYuR0NFX01FVEFEQVRBX0hPU1QpKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHX0FVVEgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIudHlwZSA9PT0gJ3JlcXVlc3QtdGltZW91dCcpIHtcbiAgICAgICAgICAgIC8vIElmIHJ1bm5pbmcgaW4gYSBHQ1AgZW52aXJvbm1lbnQsIG1ldGFkYXRhIGVuZHBvaW50IHNob3VsZCByZXR1cm5cbiAgICAgICAgICAgIC8vIHdpdGhpbiBtcy5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXMgPT09IDQwNCkgJiZcbiAgICAgICAgICAgICAgICAvLyBBIHdhcm5pbmcgaXMgZW1pdHRlZCBpZiB3ZSBzZWUgYW4gdW5leHBlY3RlZCBlcnIuY29kZSwgb3IgZXJyLmNvZGVcbiAgICAgICAgICAgICAgICAvLyBpcyBub3QgcG9wdWxhdGVkOlxuICAgICAgICAgICAgICAgICghZXJyLmNvZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgIVtcbiAgICAgICAgICAgICAgICAgICAgICAgICdFSE9TVERPV04nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VIT1NUVU5SRUFDSCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5FVFVOUkVBQ0gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VOT0VOVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5PVEZPVU5EJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFQ09OTlJFRlVTRUQnLFxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKGVyci5jb2RlKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9ICdVTktOT1dOJztcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBlcnIuY29kZTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGByZWNlaXZlZCB1bmV4cGVjdGVkIGVycm9yID0gJHtlcnIubWVzc2FnZX0gY29kZSA9ICR7Y29kZX1gLCAnTWV0YWRhdGFMb29rdXBXYXJuaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWlsdXJlIHRvIHJlc29sdmUgdGhlIG1ldGFkYXRhIHNlcnZpY2UgbWVhbnMgdGhhdCBpdCBpcyBub3QgYXZhaWxhYmxlLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5pc0F2YWlsYWJsZSA9IGlzQXZhaWxhYmxlO1xuLyoqXG4gKiByZXNldCB0aGUgbWVtb2l6ZWQgaXNBdmFpbGFibGUoKSBsb29rdXAuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0SXNBdmFpbGFibGVDYWNoZSgpIHtcbiAgICBjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlID0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5yZXNldElzQXZhaWxhYmxlQ2FjaGUgPSByZXNldElzQXZhaWxhYmxlQ2FjaGU7XG4vKipcbiAqIEEgY2FjaGUgZm9yIHRoZSBkZXRlY3RlZCBHQ1AgUmVzaWRlbmN5LlxuICovXG5leHBvcnRzLmdjcFJlc2lkZW5jeUNhY2hlID0gbnVsbDtcbi8qKlxuICogRGV0ZWN0cyBHQ1AgUmVzaWRlbmN5LlxuICogQ2FjaGVzIHJlc3VsdHMgdG8gcmVkdWNlIGNvc3RzIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuICpcbiAqIEBzZWUgc2V0R0NQUmVzaWRlbmN5IGZvciBzZXR0aW5nXG4gKi9cbmZ1bmN0aW9uIGdldEdDUFJlc2lkZW5jeSgpIHtcbiAgICBpZiAoZXhwb3J0cy5nY3BSZXNpZGVuY3lDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICBzZXRHQ1BSZXNpZGVuY3koKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuZ2NwUmVzaWRlbmN5Q2FjaGU7XG59XG5leHBvcnRzLmdldEdDUFJlc2lkZW5jeSA9IGdldEdDUFJlc2lkZW5jeTtcbi8qKlxuICogU2V0cyB0aGUgZGV0ZWN0ZWQgR0NQIFJlc2lkZW5jeS5cbiAqIFVzZWZ1bCBmb3IgZm9yY2luZyBtZXRhZGF0YSBzZXJ2ZXIgZGV0ZWN0aW9uIGJlaGF2aW9yLlxuICpcbiAqIFNldCBgbnVsbGAgdG8gYXV0b2RldGVjdCB0aGUgZW52aXJvbm1lbnQgKGRlZmF1bHQgYmVoYXZpb3IpLlxuICogQHNlZSBnZXRHQ1BSZXNpZGVuY3kgZm9yIGdldHRpbmdcbiAqL1xuZnVuY3Rpb24gc2V0R0NQUmVzaWRlbmN5KHZhbHVlID0gbnVsbCkge1xuICAgIGV4cG9ydHMuZ2NwUmVzaWRlbmN5Q2FjaGUgPSB2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlIDogKDAsIGdjcF9yZXNpZGVuY3lfMS5kZXRlY3RHQ1BSZXNpZGVuY3kpKCk7XG59XG5leHBvcnRzLnNldEdDUFJlc2lkZW5jeSA9IHNldEdDUFJlc2lkZW5jeTtcbi8qKlxuICogT2J0YWluIHRoZSB0aW1lb3V0IGZvciByZXF1ZXN0cyB0byB0aGUgbWV0YWRhdGEgc2VydmVyLlxuICpcbiAqIEluIGNlcnRhaW4gZW52aXJvbm1lbnRzIGFuZCBjb25kaXRpb25zIHJlcXVlc3RzIGNhbiB0YWtlIGxvbmdlciB0aGFuXG4gKiB0aGUgZGVmYXVsdCB0aW1lb3V0IHRvIGNvbXBsZXRlLiBUaGlzIGZ1bmN0aW9uIHdpbGwgZGV0ZXJtaW5lIHRoZVxuICogYXBwcm9wcmlhdGUgdGltZW91dCBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQuXG4gKlxuICogQHJldHVybnMge251bWJlcn0gYSByZXF1ZXN0IHRpbWVvdXQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiByZXF1ZXN0VGltZW91dCgpIHtcbiAgICByZXR1cm4gZ2V0R0NQUmVzaWRlbmN5KCkgPyAwIDogMzAwMDtcbn1cbmV4cG9ydHMucmVxdWVzdFRpbWVvdXQgPSByZXF1ZXN0VGltZW91dDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9nY3AtcmVzaWRlbmN5XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydFN0YXIiLCJleHBvcnRzIiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwicmVxdWVzdFRpbWVvdXQiLCJzZXRHQ1BSZXNpZGVuY3kiLCJnZXRHQ1BSZXNpZGVuY3kiLCJnY3BSZXNpZGVuY3lDYWNoZSIsInJlc2V0SXNBdmFpbGFibGVDYWNoZSIsImlzQXZhaWxhYmxlIiwiYnVsayIsInVuaXZlcnNlIiwicHJvamVjdCIsImluc3RhbmNlIiwiTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTiIsIkhFQURFUlMiLCJIRUFERVJfVkFMVUUiLCJIRUFERVJfTkFNRSIsIlNFQ09OREFSWV9IT1NUX0FERFJFU1MiLCJIT1NUX0FERFJFU1MiLCJCQVNFX1BBVEgiLCJnYXhpb3NfMSIsInJlcXVpcmUiLCJqc29uQmlnaW50IiwiZ2NwX3Jlc2lkZW5jeV8xIiwiZnJlZXplIiwibm9uZSIsImdldEJhc2VVcmwiLCJiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIkdDRV9NRVRBREFUQV9JUCIsIkdDRV9NRVRBREFUQV9IT1NUIiwidGVzdCIsIlVSTCIsImhyZWYiLCJ2YWxpZGF0ZSIsIm9wdGlvbnMiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsIkVycm9yIiwibWV0YWRhdGFBY2Nlc3NvciIsInR5cGUiLCJub1Jlc3BvbnNlUmV0cmllcyIsImZhc3RGYWlsIiwibWV0YWRhdGFLZXkiLCJwYXJhbXMiLCJoZWFkZXJzIiwicHJvcGVydHkiLCJyZXF1ZXN0TWV0aG9kIiwiZmFzdEZhaWxNZXRhZGF0YVJlcXVlc3QiLCJyZXF1ZXN0IiwicmVzIiwidXJsIiwicmV0cnlDb25maWciLCJyZXNwb25zZVR5cGUiLCJ0aW1lb3V0IiwidG9Mb3dlckNhc2UiLCJkYXRhIiwicGFyc2UiLCJfYSIsImUiLCJlcnIiLCJyZXNwb25zZSIsInN0YXR1cyIsIm1lc3NhZ2UiLCJzZWNvbmRhcnlPcHRpb25zIiwicmVwbGFjZSIsInJlc3BvbmRlZCIsInIxIiwidGhlbiIsImNhdGNoIiwicjIiLCJQcm9taXNlIiwicmFjZSIsInByb3BlcnRpZXMiLCJyIiwiYWxsIiwibWFwIiwiaXRlbSIsImRldGVjdEdDUEF2YWlsYWJsZVJldHJpZXMiLCJERVRFQ1RfR0NQX1JFVFJJRVMiLCJOdW1iZXIiLCJjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlIiwidHJpbSIsInRvTG9jYWxlTG93ZXJDYXNlIiwiUmFuZ2VFcnJvciIsImpvaW4iLCJERUJVR19BVVRIIiwiY29uc29sZSIsImluZm8iLCJjb2RlIiwiaW5jbHVkZXMiLCJlbWl0V2FybmluZyIsImRldGVjdEdDUFJlc2lkZW5jeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/google-auth-library/node_modules/gcp-metadata/build/src/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/google-auth-library/package.json":
/*!*******************************************************!*\
  !*** ./node_modules/google-auth-library/package.json ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"google-auth-library","version":"9.6.3","author":"Google Inc.","description":"Google APIs Authentication Client Library for Node.js","engines":{"node":">=14"},"main":"./build/src/index.js","types":"./build/src/index.d.ts","repository":"googleapis/google-auth-library-nodejs.git","keywords":["google","api","google apis","client","client library"],"dependencies":{"base64-js":"^1.3.0","ecdsa-sig-formatter":"^1.0.11","gaxios":"^6.1.1","gcp-metadata":"^6.1.0","gtoken":"^7.0.0","jws":"^4.0.0"},"devDependencies":{"@compodoc/compodoc":"^1.1.7","@types/base64-js":"^1.2.5","@types/chai":"^4.1.7","@types/jws":"^3.1.0","@types/mocha":"^9.0.0","@types/mv":"^2.1.0","@types/ncp":"^2.0.1","@types/node":"^20.4.2","@types/sinon":"^10.0.0","assert-rejects":"^1.0.0","c8":"^8.0.0","chai":"^4.2.0","codecov":"^3.0.2","execa":"^5.0.0","gts":"^5.0.0","is-docker":"^2.0.0","karma":"^6.0.0","karma-chrome-launcher":"^3.0.0","karma-coverage":"^2.0.0","karma-firefox-launcher":"^2.0.0","karma-mocha":"^2.0.0","karma-sourcemap-loader":"^0.4.0","karma-webpack":"5.0.0","keypair":"^1.0.4","linkinator":"^4.0.0","mocha":"^9.2.2","mv":"^2.1.1","ncp":"^2.0.0","nock":"^13.0.0","null-loader":"^4.0.0","puppeteer":"^21.0.0","sinon":"^15.0.0","ts-loader":"^8.0.0","typescript":"^5.1.6","webpack":"^5.21.2","webpack-cli":"^4.0.0"},"files":["build/src","!build/src/**/*.map"],"scripts":{"test":"c8 mocha build/test","clean":"gts clean","prepare":"npm run compile","lint":"gts check","compile":"tsc -p .","fix":"gts fix","pretest":"npm run compile -- --sourceMap","docs":"compodoc src/","samples-setup":"cd samples/ && npm link ../ && npm run setup && cd ../","samples-test":"cd samples/ && npm link ../ && npm test && cd ../","system-test":"mocha build/system-test --timeout 60000","presystem-test":"npm run compile -- --sourceMap","webpack":"webpack","browser-test":"karma start","docs-test":"linkinator docs","predocs-test":"npm run docs","prelint":"cd samples; npm link ../; npm install","precompile":"gts clean"},"license":"Apache-2.0"}');

/***/ })

};
;
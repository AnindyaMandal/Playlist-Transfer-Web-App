"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bignumber.js";
exports.ids = ["vendor-chunks/bignumber.js"];
exports.modules = {

/***/ "(action-browser)/./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n(function(globalObject) {\n    \"use strict\";\n    /*\r\n *      bignumber.js v9.1.2\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */ var BigNumber, isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = \"[BigNumber Error] \", tooManyDigits = bignumberError + \"Number primitive has more than 15 significant digits: \", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 0x1fffffffffffff, // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\n    POWS_TEN = [\n        1,\n        10,\n        100,\n        1e3,\n        1e4,\n        1e5,\n        1e6,\n        1e7,\n        1e8,\n        1e9,\n        1e10,\n        1e11,\n        1e12,\n        1e13\n    ], SQRT_BASE = 1e7, // EDITABLE\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\n    MAX = 1E9; // 0 to MAX_INT32\n    /*\r\n   * Create and return a BigNumber constructor.\r\n   */ function clone(configObject) {\n        var div, convertBase, parseNumeric, P = BigNumber.prototype = {\n            constructor: BigNumber,\n            toString: null,\n            valueOf: null\n        }, ONE = new BigNumber(1), //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\n        // The default values below must be integers within the inclusive ranges stated.\n        // The values can also be changed at run-time using BigNumber.set.\n        // The maximum number of decimal places for operations involving division.\n        DECIMAL_PLACES = 20, // The rounding mode used when rounding to the above decimal places, and when using\n        // toExponential, toFixed, toFormat and toPrecision, and round (default value).\n        // UP         0 Away from zero.\n        // DOWN       1 Towards zero.\n        // CEIL       2 Towards +Infinity.\n        // FLOOR      3 Towards -Infinity.\n        // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n        // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n        // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n        // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n        // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n        ROUNDING_MODE = 4, // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\n        // The exponent value at and beneath which toString returns exponential notation.\n        // Number type: -7\n        TO_EXP_NEG = -7, // The exponent value at and above which toString returns exponential notation.\n        // Number type: 21\n        TO_EXP_POS = 21, // RANGE : [MIN_EXP, MAX_EXP]\n        // The minimum exponent value, beneath which underflow to zero occurs.\n        // Number type: -324  (5e-324)\n        MIN_EXP = -1e7, // The maximum exponent value, above which overflow to Infinity occurs.\n        // Number type:  308  (1.7976931348623157e+308)\n        // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\n        MAX_EXP = 1e7, // Whether to use cryptographically-secure random number generation, if available.\n        CRYPTO = false, // The modulo mode used when calculating the modulus: a mod n.\n        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n        // The remainder (r) is calculated as: r = a - n * q.\n        //\n        // UP        0 The remainder is positive if the dividend is negative, else is negative.\n        // DOWN      1 The remainder has the same sign as the dividend.\n        //             This modulo mode is commonly known as 'truncated division' and is\n        //             equivalent to (a % n) in JavaScript.\n        // FLOOR     3 The remainder has the same sign as the divisor (Python %).\n        // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\n        // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\n        //             The remainder is always positive.\n        //\n        // The truncated division, floored division, Euclidian division and IEEE 754 remainder\n        // modes are commonly used for the modulus operation.\n        // Although the other rounding modes can also be used, they may not give useful results.\n        MODULO_MODE = 1, // The maximum number of significant digits of the result of the exponentiatedBy operation.\n        // If POW_PRECISION is 0, there will be unlimited significant digits.\n        POW_PRECISION = 0, // The format specification used by the BigNumber.prototype.toFormat method.\n        FORMAT = {\n            prefix: \"\",\n            groupSize: 3,\n            secondaryGroupSize: 0,\n            groupSeparator: \",\",\n            decimalSeparator: \".\",\n            fractionGroupSize: 0,\n            fractionGroupSeparator: \"\\xa0\",\n            suffix: \"\"\n        }, // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\n        // '-', '.', whitespace, or repeated character.\n        // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\n        ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\", alphabetHasNormalDecimalDigits = true;\n        //------------------------------------------------------------------------------------------\n        // CONSTRUCTOR\n        /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */ function BigNumber(v, b) {\n            var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;\n            // Enable constructor call without `new`.\n            if (!(x instanceof BigNumber)) return new BigNumber(v, b);\n            if (b == null) {\n                if (v && v._isBigNumber === true) {\n                    x.s = v.s;\n                    if (!v.c || v.e > MAX_EXP) {\n                        x.c = x.e = null;\n                    } else if (v.e < MIN_EXP) {\n                        x.c = [\n                            x.e = 0\n                        ];\n                    } else {\n                        x.e = v.e;\n                        x.c = v.c.slice();\n                    }\n                    return;\n                }\n                if ((isNum = typeof v == \"number\") && v * 0 == 0) {\n                    // Use `1 / n` to handle minus zero also.\n                    x.s = 1 / v < 0 ? (v = -v, -1) : 1;\n                    // Fast path for integers, where n < 2147483648 (2**31).\n                    if (v === ~~v) {\n                        for(e = 0, i = v; i >= 10; i /= 10, e++);\n                        if (e > MAX_EXP) {\n                            x.c = x.e = null;\n                        } else {\n                            x.e = e;\n                            x.c = [\n                                v\n                            ];\n                        }\n                        return;\n                    }\n                    str = String(v);\n                } else {\n                    if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\n                    x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\n                }\n                // Decimal point?\n                if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n                // Exponential form?\n                if ((i = str.search(/e/i)) > 0) {\n                    // Determine exponent.\n                    if (e < 0) e = i;\n                    e += +str.slice(i + 1);\n                    str = str.substring(0, i);\n                } else if (e < 0) {\n                    // Integer.\n                    e = str.length;\n                }\n            } else {\n                // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\n                intCheck(b, 2, ALPHABET.length, \"Base\");\n                // Allow exponential notation to be used with base 10 argument, while\n                // also rounding to DECIMAL_PLACES as with other bases.\n                if (b == 10 && alphabetHasNormalDecimalDigits) {\n                    x = new BigNumber(v);\n                    return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\n                }\n                str = String(v);\n                if (isNum = typeof v == \"number\") {\n                    // Avoid potential interpretation of Infinity and NaN as base 44+ values.\n                    if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\n                    x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\n                    // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n                    if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, \"\").length > 15) {\n                        throw Error(tooManyDigits + v);\n                    }\n                } else {\n                    x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\n                }\n                alphabet = ALPHABET.slice(0, b);\n                e = i = 0;\n                // Check that str is a valid base b number.\n                // Don't use RegExp, so alphabet can contain special characters.\n                for(len = str.length; i < len; i++){\n                    if (alphabet.indexOf(c = str.charAt(i)) < 0) {\n                        if (c == \".\") {\n                            // If '.' is not the first character and it has not be found before.\n                            if (i > e) {\n                                e = len;\n                                continue;\n                            }\n                        } else if (!caseChanged) {\n                            // Allow e.g. hexadecimal 'FF' as well as 'ff'.\n                            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {\n                                caseChanged = true;\n                                i = -1;\n                                e = 0;\n                                continue;\n                            }\n                        }\n                        return parseNumeric(x, String(v), isNum, b);\n                    }\n                }\n                // Prevent later check for length on converted number.\n                isNum = false;\n                str = convertBase(str, b, 10, x.s);\n                // Decimal point?\n                if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n                else e = str.length;\n            }\n            // Determine leading zeros.\n            for(i = 0; str.charCodeAt(i) === 48; i++);\n            // Determine trailing zeros.\n            for(len = str.length; str.charCodeAt(--len) === 48;);\n            if (str = str.slice(i, ++len)) {\n                len -= i;\n                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n                if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\n                    throw Error(tooManyDigits + x.s * v);\n                }\n                // Overflow?\n                if ((e = e - i - 1) > MAX_EXP) {\n                    // Infinity.\n                    x.c = x.e = null;\n                // Underflow?\n                } else if (e < MIN_EXP) {\n                    // Zero.\n                    x.c = [\n                        x.e = 0\n                    ];\n                } else {\n                    x.e = e;\n                    x.c = [];\n                    // Transform base\n                    // e is the base 10 exponent.\n                    // i is where to slice str to get the first element of the coefficient array.\n                    i = (e + 1) % LOG_BASE;\n                    if (e < 0) i += LOG_BASE; // i < 1\n                    if (i < len) {\n                        if (i) x.c.push(+str.slice(0, i));\n                        for(len -= LOG_BASE; i < len;){\n                            x.c.push(+str.slice(i, i += LOG_BASE));\n                        }\n                        i = LOG_BASE - (str = str.slice(i)).length;\n                    } else {\n                        i -= len;\n                    }\n                    for(; i--; str += \"0\");\n                    x.c.push(+str);\n                }\n            } else {\n                // Zero.\n                x.c = [\n                    x.e = 0\n                ];\n            }\n        }\n        // CONSTRUCTOR PROPERTIES\n        BigNumber.clone = clone;\n        BigNumber.ROUND_UP = 0;\n        BigNumber.ROUND_DOWN = 1;\n        BigNumber.ROUND_CEIL = 2;\n        BigNumber.ROUND_FLOOR = 3;\n        BigNumber.ROUND_HALF_UP = 4;\n        BigNumber.ROUND_HALF_DOWN = 5;\n        BigNumber.ROUND_HALF_EVEN = 6;\n        BigNumber.ROUND_HALF_CEIL = 7;\n        BigNumber.ROUND_HALF_FLOOR = 8;\n        BigNumber.EUCLID = 9;\n        /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */ BigNumber.config = BigNumber.set = function(obj) {\n            var p, v;\n            if (obj != null) {\n                if (typeof obj == \"object\") {\n                    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\n                    // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = \"DECIMAL_PLACES\")) {\n                        v = obj[p];\n                        intCheck(v, 0, MAX, p);\n                        DECIMAL_PLACES = v;\n                    }\n                    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\n                    // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = \"ROUNDING_MODE\")) {\n                        v = obj[p];\n                        intCheck(v, 0, 8, p);\n                        ROUNDING_MODE = v;\n                    }\n                    // EXPONENTIAL_AT {number|number[]}\n                    // Integer, -MAX to MAX inclusive or\n                    // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\n                    // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = \"EXPONENTIAL_AT\")) {\n                        v = obj[p];\n                        if (v && v.pop) {\n                            intCheck(v[0], -MAX, 0, p);\n                            intCheck(v[1], 0, MAX, p);\n                            TO_EXP_NEG = v[0];\n                            TO_EXP_POS = v[1];\n                        } else {\n                            intCheck(v, -MAX, MAX, p);\n                            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\n                        }\n                    }\n                    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\n                    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\n                    // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\n                    if (obj.hasOwnProperty(p = \"RANGE\")) {\n                        v = obj[p];\n                        if (v && v.pop) {\n                            intCheck(v[0], -MAX, -1, p);\n                            intCheck(v[1], 1, MAX, p);\n                            MIN_EXP = v[0];\n                            MAX_EXP = v[1];\n                        } else {\n                            intCheck(v, -MAX, MAX, p);\n                            if (v) {\n                                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\n                            } else {\n                                throw Error(bignumberError + p + \" cannot be zero: \" + v);\n                            }\n                        }\n                    }\n                    // CRYPTO {boolean} true or false.\n                    // '[BigNumber Error] CRYPTO not true or false: {v}'\n                    // '[BigNumber Error] crypto unavailable'\n                    if (obj.hasOwnProperty(p = \"CRYPTO\")) {\n                        v = obj[p];\n                        if (v === !!v) {\n                            if (v) {\n                                if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n                                    CRYPTO = v;\n                                } else {\n                                    CRYPTO = !v;\n                                    throw Error(bignumberError + \"crypto unavailable\");\n                                }\n                            } else {\n                                CRYPTO = v;\n                            }\n                        } else {\n                            throw Error(bignumberError + p + \" not true or false: \" + v);\n                        }\n                    }\n                    // MODULO_MODE {number} Integer, 0 to 9 inclusive.\n                    // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = \"MODULO_MODE\")) {\n                        v = obj[p];\n                        intCheck(v, 0, 9, p);\n                        MODULO_MODE = v;\n                    }\n                    // POW_PRECISION {number} Integer, 0 to MAX inclusive.\n                    // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = \"POW_PRECISION\")) {\n                        v = obj[p];\n                        intCheck(v, 0, MAX, p);\n                        POW_PRECISION = v;\n                    }\n                    // FORMAT {object}\n                    // '[BigNumber Error] FORMAT not an object: {v}'\n                    if (obj.hasOwnProperty(p = \"FORMAT\")) {\n                        v = obj[p];\n                        if (typeof v == \"object\") FORMAT = v;\n                        else throw Error(bignumberError + p + \" not an object: \" + v);\n                    }\n                    // ALPHABET {string}\n                    // '[BigNumber Error] ALPHABET invalid: {v}'\n                    if (obj.hasOwnProperty(p = \"ALPHABET\")) {\n                        v = obj[p];\n                        // Disallow if less than two characters,\n                        // or if it contains '+', '-', '.', whitespace, or a repeated character.\n                        if (typeof v == \"string\" && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\n                            alphabetHasNormalDecimalDigits = v.slice(0, 10) == \"0123456789\";\n                            ALPHABET = v;\n                        } else {\n                            throw Error(bignumberError + p + \" invalid: \" + v);\n                        }\n                    }\n                } else {\n                    // '[BigNumber Error] Object expected: {v}'\n                    throw Error(bignumberError + \"Object expected: \" + obj);\n                }\n            }\n            return {\n                DECIMAL_PLACES: DECIMAL_PLACES,\n                ROUNDING_MODE: ROUNDING_MODE,\n                EXPONENTIAL_AT: [\n                    TO_EXP_NEG,\n                    TO_EXP_POS\n                ],\n                RANGE: [\n                    MIN_EXP,\n                    MAX_EXP\n                ],\n                CRYPTO: CRYPTO,\n                MODULO_MODE: MODULO_MODE,\n                POW_PRECISION: POW_PRECISION,\n                FORMAT: FORMAT,\n                ALPHABET: ALPHABET\n            };\n        };\n        /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */ BigNumber.isBigNumber = function(v) {\n            if (!v || v._isBigNumber !== true) return false;\n            if (!BigNumber.DEBUG) return true;\n            var i, n, c = v.c, e = v.e, s = v.s;\n            out: if (({}).toString.call(c) == \"[object Array]\") {\n                if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\n                    // If the first element is zero, the BigNumber value must be zero.\n                    if (c[0] === 0) {\n                        if (e === 0 && c.length === 1) return true;\n                        break out;\n                    }\n                    // Calculate number of digits that c[0] should have, based on the exponent.\n                    i = (e + 1) % LOG_BASE;\n                    if (i < 1) i += LOG_BASE;\n                    // Calculate number of digits of c[0].\n                    //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\n                    if (String(c[0]).length == i) {\n                        for(i = 0; i < c.length; i++){\n                            n = c[i];\n                            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\n                        }\n                        // Last element cannot be zero, unless it is the only element.\n                        if (n !== 0) return true;\n                    }\n                }\n            // Infinity/NaN\n            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\n                return true;\n            }\n            throw Error(bignumberError + \"Invalid BigNumber: \" + v);\n        };\n        /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */ BigNumber.maximum = BigNumber.max = function() {\n            return maxOrMin(arguments, -1);\n        };\n        /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */ BigNumber.minimum = BigNumber.min = function() {\n            return maxOrMin(arguments, 1);\n        };\n        /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */ BigNumber.random = function() {\n            var pow2_53 = 0x20000000000000;\n            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\n            // Check if Math.random() produces more than 32 bits of randomness.\n            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\n            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\n            var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function() {\n                return mathfloor(Math.random() * pow2_53);\n            } : function() {\n                return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);\n            };\n            return function(dp) {\n                var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);\n                if (dp == null) dp = DECIMAL_PLACES;\n                else intCheck(dp, 0, MAX);\n                k = mathceil(dp / LOG_BASE);\n                if (CRYPTO) {\n                    // Browsers supporting crypto.getRandomValues.\n                    if (crypto.getRandomValues) {\n                        a = crypto.getRandomValues(new Uint32Array(k *= 2));\n                        for(; i < k;){\n                            // 53 bits:\n                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\n                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000\n                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\n                            //                                     11111 11111111 11111111\n                            // 0x20000 is 2^21.\n                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);\n                            // Rejection sampling:\n                            // 0 <= v < 9007199254740992\n                            // Probability that v >= 9e15, is\n                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\n                            if (v >= 9e15) {\n                                b = crypto.getRandomValues(new Uint32Array(2));\n                                a[i] = b[0];\n                                a[i + 1] = b[1];\n                            } else {\n                                // 0 <= v <= 8999999999999999\n                                // 0 <= (v % 1e14) <= 99999999999999\n                                c.push(v % 1e14);\n                                i += 2;\n                            }\n                        }\n                        i = k / 2;\n                    // Node.js supporting crypto.randomBytes.\n                    } else if (crypto.randomBytes) {\n                        // buffer\n                        a = crypto.randomBytes(k *= 7);\n                        for(; i < k;){\n                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\n                            // 0x100000000 is 2^32, 0x1000000 is 2^24\n                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111\n                            // 0 <= v < 9007199254740992\n                            v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\n                            if (v >= 9e15) {\n                                crypto.randomBytes(7).copy(a, i);\n                            } else {\n                                // 0 <= (v % 1e14) <= 99999999999999\n                                c.push(v % 1e14);\n                                i += 7;\n                            }\n                        }\n                        i = k / 7;\n                    } else {\n                        CRYPTO = false;\n                        throw Error(bignumberError + \"crypto unavailable\");\n                    }\n                }\n                // Use Math.random.\n                if (!CRYPTO) {\n                    for(; i < k;){\n                        v = random53bitInt();\n                        if (v < 9e15) c[i++] = v % 1e14;\n                    }\n                }\n                k = c[--i];\n                dp %= LOG_BASE;\n                // Convert trailing digits to zeros according to dp.\n                if (k && dp) {\n                    v = POWS_TEN[LOG_BASE - dp];\n                    c[i] = mathfloor(k / v) * v;\n                }\n                // Remove trailing elements which are zero.\n                for(; c[i] === 0; c.pop(), i--);\n                // Zero?\n                if (i < 0) {\n                    c = [\n                        e = 0\n                    ];\n                } else {\n                    // Remove leading elements which are zero and adjust exponent accordingly.\n                    for(e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\n                    // Count the digits of the first element of c to determine leading zeros, and...\n                    for(i = 1, v = c[0]; v >= 10; v /= 10, i++);\n                    // adjust the exponent accordingly.\n                    if (i < LOG_BASE) e -= LOG_BASE - i;\n                }\n                rand.e = e;\n                rand.c = c;\n                return rand;\n            };\n        }();\n        /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */ BigNumber.sum = function() {\n            var i = 1, args = arguments, sum = new BigNumber(args[0]);\n            for(; i < args.length;)sum = sum.plus(args[i++]);\n            return sum;\n        };\n        // PRIVATE FUNCTIONS\n        // Called by BigNumber and BigNumber.prototype.toString.\n        convertBase = function() {\n            var decimal = \"0123456789\";\n            /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */ function toBaseOut(str, baseIn, baseOut, alphabet) {\n                var j, arr = [\n                    0\n                ], arrL, i = 0, len = str.length;\n                for(; i < len;){\n                    for(arrL = arr.length; arrL--; arr[arrL] *= baseIn);\n                    arr[0] += alphabet.indexOf(str.charAt(i++));\n                    for(j = 0; j < arr.length; j++){\n                        if (arr[j] > baseOut - 1) {\n                            if (arr[j + 1] == null) arr[j + 1] = 0;\n                            arr[j + 1] += arr[j] / baseOut | 0;\n                            arr[j] %= baseOut;\n                        }\n                    }\n                }\n                return arr.reverse();\n            }\n            // Convert a numeric string of baseIn to a numeric string of baseOut.\n            // If the caller is toString, we are converting from base 10 to baseOut.\n            // If the caller is BigNumber, we are converting from baseIn to base 10.\n            return function(str, baseIn, baseOut, sign, callerIsToString) {\n                var alphabet, d, e, k, r, x, xc, y, i = str.indexOf(\".\"), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;\n                // Non-integer.\n                if (i >= 0) {\n                    k = POW_PRECISION;\n                    // Unlimited precision.\n                    POW_PRECISION = 0;\n                    str = str.replace(\".\", \"\");\n                    y = new BigNumber(baseIn);\n                    x = y.pow(str.length - i);\n                    POW_PRECISION = k;\n                    // Convert str as if an integer, then restore the fraction part by dividing the\n                    // result by its base raised to a power.\n                    y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, \"0\"), 10, baseOut, decimal);\n                    y.e = y.c.length;\n                }\n                // Convert the number as integer.\n                xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));\n                // xc now represents str as an integer and converted to baseOut. e is the exponent.\n                e = k = xc.length;\n                // Remove trailing zeros.\n                for(; xc[--k] == 0; xc.pop());\n                // Zero?\n                if (!xc[0]) return alphabet.charAt(0);\n                // Does str represent an integer? If so, no need for the division.\n                if (i < 0) {\n                    --e;\n                } else {\n                    x.c = xc;\n                    x.e = e;\n                    // The sign is needed for correct rounding.\n                    x.s = sign;\n                    x = div(x, y, dp, rm, baseOut);\n                    xc = x.c;\n                    r = x.r;\n                    e = x.e;\n                }\n                // xc now represents str converted to baseOut.\n                // THe index of the rounding digit.\n                d = e + dp + 1;\n                // The rounding digit: the digit to the right of the digit that may be rounded up.\n                i = xc[d];\n                // Look at the rounding digits and mode to determine whether to round up.\n                k = baseOut / 2;\n                r = r || d < 0 || xc[d + 1] != null;\n                r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));\n                // If the index of the rounding digit is not greater than zero, or xc represents\n                // zero, then the result of the base conversion is zero or, if rounding up, a value\n                // such as 0.00001.\n                if (d < 1 || !xc[0]) {\n                    // 1^-dp or 0\n                    str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\n                } else {\n                    // Truncate xc to the required number of decimal places.\n                    xc.length = d;\n                    // Round up?\n                    if (r) {\n                        // Rounding up may mean the previous digit has to be rounded up and so on.\n                        for(--baseOut; ++xc[--d] > baseOut;){\n                            xc[d] = 0;\n                            if (!d) {\n                                ++e;\n                                xc = [\n                                    1\n                                ].concat(xc);\n                            }\n                        }\n                    }\n                    // Determine trailing zeros.\n                    for(k = xc.length; !xc[--k];);\n                    // E.g. [4, 11, 15] becomes 4bf.\n                    for(i = 0, str = \"\"; i <= k; str += alphabet.charAt(xc[i++]));\n                    // Add leading zeros, decimal point and trailing zeros as required.\n                    str = toFixedPoint(str, e, alphabet.charAt(0));\n                }\n                // The caller will add the sign.\n                return str;\n            };\n        }();\n        // Perform division in the specified base. Called by div and convertBase.\n        div = function() {\n            // Assume non-zero x and k.\n            function multiply(x, k, base) {\n                var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;\n                for(x = x.slice(); i--;){\n                    xlo = x[i] % SQRT_BASE;\n                    xhi = x[i] / SQRT_BASE | 0;\n                    m = khi * xlo + xhi * klo;\n                    temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;\n                    carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\n                    x[i] = temp % base;\n                }\n                if (carry) x = [\n                    carry\n                ].concat(x);\n                return x;\n            }\n            function compare(a, b, aL, bL) {\n                var i, cmp;\n                if (aL != bL) {\n                    cmp = aL > bL ? 1 : -1;\n                } else {\n                    for(i = cmp = 0; i < aL; i++){\n                        if (a[i] != b[i]) {\n                            cmp = a[i] > b[i] ? 1 : -1;\n                            break;\n                        }\n                    }\n                }\n                return cmp;\n            }\n            function subtract(a, b, aL, base) {\n                var i = 0;\n                // Subtract b from a.\n                for(; aL--;){\n                    a[aL] -= i;\n                    i = a[aL] < b[aL] ? 1 : 0;\n                    a[aL] = i * base + a[aL] - b[aL];\n                }\n                // Remove leading zeros.\n                for(; !a[0] && a.length > 1; a.splice(0, 1));\n            }\n            // x: dividend, y: divisor.\n            return function(x, y, dp, rm, base) {\n                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;\n                // Either NaN, Infinity or 0?\n                if (!xc || !xc[0] || !yc || !yc[0]) {\n                    return new BigNumber(// Return NaN if either NaN, or both Infinity or 0.\n                    !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\n                    xc && xc[0] == 0 || !yc ? s * 0 : s / 0);\n                }\n                q = new BigNumber(s);\n                qc = q.c = [];\n                e = x.e - y.e;\n                s = dp + e + 1;\n                if (!base) {\n                    base = BASE;\n                    e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\n                    s = s / LOG_BASE | 0;\n                }\n                // Result exponent may be one less then the current value of e.\n                // The coefficients of the BigNumbers from convertBase may have trailing zeros.\n                for(i = 0; yc[i] == (xc[i] || 0); i++);\n                if (yc[i] > (xc[i] || 0)) e--;\n                if (s < 0) {\n                    qc.push(1);\n                    more = true;\n                } else {\n                    xL = xc.length;\n                    yL = yc.length;\n                    i = 0;\n                    s += 2;\n                    // Normalise xc and yc so highest order digit of yc is >= base / 2.\n                    n = mathfloor(base / (yc[0] + 1));\n                    // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\n                    // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\n                    if (n > 1) {\n                        yc = multiply(yc, n, base);\n                        xc = multiply(xc, n, base);\n                        yL = yc.length;\n                        xL = xc.length;\n                    }\n                    xi = yL;\n                    rem = xc.slice(0, yL);\n                    remL = rem.length;\n                    // Add zeros to make remainder as long as divisor.\n                    for(; remL < yL; rem[remL++] = 0);\n                    yz = yc.slice();\n                    yz = [\n                        0\n                    ].concat(yz);\n                    yc0 = yc[0];\n                    if (yc[1] >= base / 2) yc0++;\n                    // Not necessary, but to prevent trial digit n > base, when using base 3.\n                    // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\n                    do {\n                        n = 0;\n                        // Compare divisor and remainder.\n                        cmp = compare(yc, rem, yL, remL);\n                        // If divisor < remainder.\n                        if (cmp < 0) {\n                            // Calculate trial digit, n.\n                            rem0 = rem[0];\n                            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n                            // n is how many times the divisor goes into the current remainder.\n                            n = mathfloor(rem0 / yc0);\n                            //  Algorithm:\n                            //  product = divisor multiplied by trial digit (n).\n                            //  Compare product and remainder.\n                            //  If product is greater than remainder:\n                            //    Subtract divisor from product, decrement trial digit.\n                            //  Subtract product from remainder.\n                            //  If product was less than remainder at the last compare:\n                            //    Compare new remainder and divisor.\n                            //    If remainder is greater than divisor:\n                            //      Subtract divisor from remainder, increment trial digit.\n                            if (n > 1) {\n                                // n may be > base only when base is 3.\n                                if (n >= base) n = base - 1;\n                                // product = divisor * trial digit.\n                                prod = multiply(yc, n, base);\n                                prodL = prod.length;\n                                remL = rem.length;\n                                // Compare product and remainder.\n                                // If product > remainder then trial digit n too high.\n                                // n is 1 too high about 5% of the time, and is not known to have\n                                // ever been more than 1 too high.\n                                while(compare(prod, rem, prodL, remL) == 1){\n                                    n--;\n                                    // Subtract divisor from product.\n                                    subtract(prod, yL < prodL ? yz : yc, prodL, base);\n                                    prodL = prod.length;\n                                    cmp = 1;\n                                }\n                            } else {\n                                // n is 0 or 1, cmp is -1.\n                                // If n is 0, there is no need to compare yc and rem again below,\n                                // so change cmp to 1 to avoid it.\n                                // If n is 1, leave cmp as -1, so yc and rem are compared again.\n                                if (n == 0) {\n                                    // divisor < remainder, so n must be at least 1.\n                                    cmp = n = 1;\n                                }\n                                // product = divisor\n                                prod = yc.slice();\n                                prodL = prod.length;\n                            }\n                            if (prodL < remL) prod = [\n                                0\n                            ].concat(prod);\n                            // Subtract product from remainder.\n                            subtract(rem, prod, remL, base);\n                            remL = rem.length;\n                            // If product was < remainder.\n                            if (cmp == -1) {\n                                // Compare divisor and new remainder.\n                                // If divisor < new remainder, subtract divisor from remainder.\n                                // Trial digit n too low.\n                                // n is 1 too low about 5% of the time, and very rarely 2 too low.\n                                while(compare(yc, rem, yL, remL) < 1){\n                                    n++;\n                                    // Subtract divisor from remainder.\n                                    subtract(rem, yL < remL ? yz : yc, remL, base);\n                                    remL = rem.length;\n                                }\n                            }\n                        } else if (cmp === 0) {\n                            n++;\n                            rem = [\n                                0\n                            ];\n                        } // else cmp === 1 and n will be 0\n                        // Add the next digit, n, to the result array.\n                        qc[i++] = n;\n                        // Update the remainder.\n                        if (rem[0]) {\n                            rem[remL++] = xc[xi] || 0;\n                        } else {\n                            rem = [\n                                xc[xi]\n                            ];\n                            remL = 1;\n                        }\n                    }while ((xi++ < xL || rem[0] != null) && s--);\n                    more = rem[0] != null;\n                    // Leading zero?\n                    if (!qc[0]) qc.splice(0, 1);\n                }\n                if (base == BASE) {\n                    // To calculate q.e, first get the number of digits of qc[0].\n                    for(i = 1, s = qc[0]; s >= 10; s /= 10, i++);\n                    round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\n                // Caller is convertBase.\n                } else {\n                    q.e = e;\n                    q.r = +more;\n                }\n                return q;\n            };\n        }();\n        /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */ function format(n, i, rm, id) {\n            var c0, e, ne, len, str;\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n            if (!n.c) return n.toString();\n            c0 = n.c[0];\n            ne = n.e;\n            if (i == null) {\n                str = coeffToString(n.c);\n                str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, \"0\");\n            } else {\n                n = round(new BigNumber(n), i, rm);\n                // n.e may have changed if the value was rounded up.\n                e = n.e;\n                str = coeffToString(n.c);\n                len = str.length;\n                // toPrecision returns exponential notation if the number of significant digits\n                // specified is less than the number of digits necessary to represent the integer\n                // part of the value in fixed-point notation.\n                // Exponential notation.\n                if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\n                    // Append zeros?\n                    for(; len < i; str += \"0\", len++);\n                    str = toExponential(str, e);\n                // Fixed-point notation.\n                } else {\n                    i -= ne;\n                    str = toFixedPoint(str, e, \"0\");\n                    // Append zeros?\n                    if (e + 1 > len) {\n                        if (--i > 0) for(str += \".\"; i--; str += \"0\");\n                    } else {\n                        i += e - len;\n                        if (i > 0) {\n                            if (e + 1 == len) str += \".\";\n                            for(; i--; str += \"0\");\n                        }\n                    }\n                }\n            }\n            return n.s < 0 && c0 ? \"-\" + str : str;\n        }\n        // Handle BigNumber.max and BigNumber.min.\n        // If any number is NaN, return NaN.\n        function maxOrMin(args, n) {\n            var k, y, i = 1, x = new BigNumber(args[0]);\n            for(; i < args.length; i++){\n                y = new BigNumber(args[i]);\n                if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\n                    x = y;\n                }\n            }\n            return x;\n        }\n        /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */ function normalise(n, c, e) {\n            var i = 1, j = c.length;\n            // Remove trailing zeros.\n            for(; !c[--j]; c.pop());\n            // Calculate the base 10 exponent. First get the number of digits of c[0].\n            for(j = c[0]; j >= 10; j /= 10, i++);\n            // Overflow?\n            if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\n                // Infinity.\n                n.c = n.e = null;\n            // Underflow?\n            } else if (e < MIN_EXP) {\n                // Zero.\n                n.c = [\n                    n.e = 0\n                ];\n            } else {\n                n.e = e;\n                n.c = c;\n            }\n            return n;\n        }\n        // Handle values that fail the validity test in BigNumber.\n        parseNumeric = function() {\n            var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i, dotAfter = /^([^.]+)\\.$/, dotBefore = /^\\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\n            return function(x, str, isNum, b) {\n                var base, s = isNum ? str : str.replace(whitespaceOrPlus, \"\");\n                // No exception on ±Infinity or NaN.\n                if (isInfinityOrNaN.test(s)) {\n                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\n                } else {\n                    if (!isNum) {\n                        // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\n                        s = s.replace(basePrefix, function(m, p1, p2) {\n                            base = (p2 = p2.toLowerCase()) == \"x\" ? 16 : p2 == \"b\" ? 2 : 8;\n                            return !b || b == base ? p1 : m;\n                        });\n                        if (b) {\n                            base = b;\n                            // E.g. '1.' to '1', '.1' to '0.1'\n                            s = s.replace(dotAfter, \"$1\").replace(dotBefore, \"0.$1\");\n                        }\n                        if (str != s) return new BigNumber(s, base);\n                    }\n                    // '[BigNumber Error] Not a number: {n}'\n                    // '[BigNumber Error] Not a base {b} number: {n}'\n                    if (BigNumber.DEBUG) {\n                        throw Error(bignumberError + \"Not a\" + (b ? \" base \" + b : \"\") + \" number: \" + str);\n                    }\n                    // NaN\n                    x.s = null;\n                }\n                x.c = x.e = null;\n            };\n        }();\n        /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */ function round(x, sd, rm, r) {\n            var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;\n            // if x is not Infinity or NaN...\n            if (xc) {\n                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\n                // n is a base 1e14 number, the value of the element of array x.c containing rd.\n                // ni is the index of n within x.c.\n                // d is the number of digits of n.\n                // i is the index of rd within n including leading zeros.\n                // j is the actual index of rd within n (if < 0, rd is a leading zero).\n                out: {\n                    // Get the number of digits of the first element of xc.\n                    for(d = 1, k = xc[0]; k >= 10; k /= 10, d++);\n                    i = sd - d;\n                    // If the rounding digit is in the first element of xc...\n                    if (i < 0) {\n                        i += LOG_BASE;\n                        j = sd;\n                        n = xc[ni = 0];\n                        // Get the rounding digit at index j of n.\n                        rd = mathfloor(n / pows10[d - j - 1] % 10);\n                    } else {\n                        ni = mathceil((i + 1) / LOG_BASE);\n                        if (ni >= xc.length) {\n                            if (r) {\n                                // Needed by sqrt.\n                                for(; xc.length <= ni; xc.push(0));\n                                n = rd = 0;\n                                d = 1;\n                                i %= LOG_BASE;\n                                j = i - LOG_BASE + 1;\n                            } else {\n                                break out;\n                            }\n                        } else {\n                            n = k = xc[ni];\n                            // Get the number of digits of n.\n                            for(d = 1; k >= 10; k /= 10, d++);\n                            // Get the index of rd within n.\n                            i %= LOG_BASE;\n                            // Get the index of rd within n, adjusted for leading zeros.\n                            // The number of leading zeros of n is given by LOG_BASE - d.\n                            j = i - LOG_BASE + d;\n                            // Get the rounding digit at index j of n.\n                            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\n                        }\n                    }\n                    r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?\n                    // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\n                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\n                    xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\n                    r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n                    if (sd < 1 || !xc[0]) {\n                        xc.length = 0;\n                        if (r) {\n                            // Convert sd to decimal places.\n                            sd -= x.e + 1;\n                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\n                            x.e = -sd || 0;\n                        } else {\n                            // Zero.\n                            xc[0] = x.e = 0;\n                        }\n                        return x;\n                    }\n                    // Remove excess digits.\n                    if (i == 0) {\n                        xc.length = ni;\n                        k = 1;\n                        ni--;\n                    } else {\n                        xc.length = ni + 1;\n                        k = pows10[LOG_BASE - i];\n                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n                        // j > 0 means i > number of leading zeros of n.\n                        xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\n                    }\n                    // Round up?\n                    if (r) {\n                        for(;;){\n                            // If the digit to be rounded up is in the first element of xc...\n                            if (ni == 0) {\n                                // i will be the length of xc[0] before k is added.\n                                for(i = 1, j = xc[0]; j >= 10; j /= 10, i++);\n                                j = xc[0] += k;\n                                for(k = 1; j >= 10; j /= 10, k++);\n                                // if i != k the length has increased.\n                                if (i != k) {\n                                    x.e++;\n                                    if (xc[0] == BASE) xc[0] = 1;\n                                }\n                                break;\n                            } else {\n                                xc[ni] += k;\n                                if (xc[ni] != BASE) break;\n                                xc[ni--] = 0;\n                                k = 1;\n                            }\n                        }\n                    }\n                    // Remove trailing zeros.\n                    for(i = xc.length; xc[--i] === 0; xc.pop());\n                }\n                // Overflow? Infinity.\n                if (x.e > MAX_EXP) {\n                    x.c = x.e = null;\n                // Underflow? Zero.\n                } else if (x.e < MIN_EXP) {\n                    x.c = [\n                        x.e = 0\n                    ];\n                }\n            }\n            return x;\n        }\n        function valueOf(n) {\n            var str, e = n.e;\n            if (e === null) return n.toString();\n            str = coeffToString(n.c);\n            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, \"0\");\n            return n.s < 0 ? \"-\" + str : str;\n        }\n        // PROTOTYPE/INSTANCE METHODS\n        /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */ P.absoluteValue = P.abs = function() {\n            var x = new BigNumber(this);\n            if (x.s < 0) x.s = 1;\n            return x;\n        };\n        /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */ P.comparedTo = function(y, b) {\n            return compare(this, new BigNumber(y, b));\n        };\n        /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */ P.decimalPlaces = P.dp = function(dp, rm) {\n            var c, n, v, x = this;\n            if (dp != null) {\n                intCheck(dp, 0, MAX);\n                if (rm == null) rm = ROUNDING_MODE;\n                else intCheck(rm, 0, 8);\n                return round(new BigNumber(x), dp + x.e + 1, rm);\n            }\n            if (!(c = x.c)) return null;\n            n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\n            // Subtract the number of trailing zeros of the last number.\n            if (v = c[v]) for(; v % 10 == 0; v /= 10, n--);\n            if (n < 0) n = 0;\n            return n;\n        };\n        /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */ P.dividedBy = P.div = function(y, b) {\n            return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\n        };\n        /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */ P.dividedToIntegerBy = P.idiv = function(y, b) {\n            return div(this, new BigNumber(y, b), 0, 1);\n        };\n        /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */ P.exponentiatedBy = P.pow = function(n, m) {\n            var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;\n            n = new BigNumber(n);\n            // Allow NaN and ±Infinity, but not other non-integers.\n            if (n.c && !n.isInteger()) {\n                throw Error(bignumberError + \"Exponent not an integer: \" + valueOf(n));\n            }\n            if (m != null) m = new BigNumber(m);\n            // Exponent of MAX_SAFE_INTEGER is 15.\n            nIsBig = n.e > 14;\n            // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\n            if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\n                // The sign of the result of pow when x is negative depends on the evenness of n.\n                // If +n overflows to ±Infinity, the evenness of n would be not be known.\n                y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\n                return m ? y.mod(m) : y;\n            }\n            nIsNeg = n.s < 0;\n            if (m) {\n                // x % m returns NaN if abs(m) is zero, or m is NaN.\n                if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\n                isModExp = !nIsNeg && x.isInteger() && m.isInteger();\n                if (isModExp) x = x.mod(m);\n            // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\n            // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\n            } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\n                // If x is negative and n is odd, k = -0, else k = 0.\n                k = x.s < 0 && isOdd(n) ? -0 : 0;\n                // If x >= 1, k = ±Infinity.\n                if (x.e > -1) k = 1 / k;\n                // If n is negative return ±0, else return ±Infinity.\n                return new BigNumber(nIsNeg ? 1 / k : k);\n            } else if (POW_PRECISION) {\n                // Truncating each coefficient array to a length of k after each multiplication\n                // equates to truncating significant digits to POW_PRECISION + [28, 41],\n                // i.e. there will be a minimum of 28 guard digits retained.\n                k = mathceil(POW_PRECISION / LOG_BASE + 2);\n            }\n            if (nIsBig) {\n                half = new BigNumber(0.5);\n                if (nIsNeg) n.s = 1;\n                nIsOdd = isOdd(n);\n            } else {\n                i = Math.abs(+valueOf(n));\n                nIsOdd = i % 2;\n            }\n            y = new BigNumber(ONE);\n            // Performs 54 loop iterations for n of 9007199254740991.\n            for(;;){\n                if (nIsOdd) {\n                    y = y.times(x);\n                    if (!y.c) break;\n                    if (k) {\n                        if (y.c.length > k) y.c.length = k;\n                    } else if (isModExp) {\n                        y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\n                    }\n                }\n                if (i) {\n                    i = mathfloor(i / 2);\n                    if (i === 0) break;\n                    nIsOdd = i % 2;\n                } else {\n                    n = n.times(half);\n                    round(n, n.e + 1, 1);\n                    if (n.e > 14) {\n                        nIsOdd = isOdd(n);\n                    } else {\n                        i = +valueOf(n);\n                        if (i === 0) break;\n                        nIsOdd = i % 2;\n                    }\n                }\n                x = x.times(x);\n                if (k) {\n                    if (x.c && x.c.length > k) x.c.length = k;\n                } else if (isModExp) {\n                    x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\n                }\n            }\n            if (isModExp) return y;\n            if (nIsNeg) y = ONE.div(y);\n            return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\n        };\n        /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */ P.integerValue = function(rm) {\n            var n = new BigNumber(this);\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n            return round(n, n.e + 1, rm);\n        };\n        /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */ P.isEqualTo = P.eq = function(y, b) {\n            return compare(this, new BigNumber(y, b)) === 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */ P.isFinite = function() {\n            return !!this.c;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */ P.isGreaterThan = P.gt = function(y, b) {\n            return compare(this, new BigNumber(y, b)) > 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */ P.isGreaterThanOrEqualTo = P.gte = function(y, b) {\n            return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */ P.isInteger = function() {\n            return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */ P.isLessThan = P.lt = function(y, b) {\n            return compare(this, new BigNumber(y, b)) < 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */ P.isLessThanOrEqualTo = P.lte = function(y, b) {\n            return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */ P.isNaN = function() {\n            return !this.s;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */ P.isNegative = function() {\n            return this.s < 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */ P.isPositive = function() {\n            return this.s > 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */ P.isZero = function() {\n            return !!this.c && this.c[0] == 0;\n        };\n        /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */ P.minus = function(y, b) {\n            var i, j, t, xLTy, x = this, a = x.s;\n            y = new BigNumber(y, b);\n            b = y.s;\n            // Either NaN?\n            if (!a || !b) return new BigNumber(NaN);\n            // Signs differ?\n            if (a != b) {\n                y.s = -b;\n                return x.plus(y);\n            }\n            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;\n            if (!xe || !ye) {\n                // Either Infinity?\n                if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\n                // Either zero?\n                if (!xc[0] || !yc[0]) {\n                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n                    return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\n                    ROUNDING_MODE == 3 ? -0 : 0);\n                }\n            }\n            xe = bitFloor(xe);\n            ye = bitFloor(ye);\n            xc = xc.slice();\n            // Determine which is the bigger number.\n            if (a = xe - ye) {\n                if (xLTy = a < 0) {\n                    a = -a;\n                    t = xc;\n                } else {\n                    ye = xe;\n                    t = yc;\n                }\n                t.reverse();\n                // Prepend zeros to equalise exponents.\n                for(b = a; b--; t.push(0));\n                t.reverse();\n            } else {\n                // Exponents equal. Check digit by digit.\n                j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\n                for(a = b = 0; b < j; b++){\n                    if (xc[b] != yc[b]) {\n                        xLTy = xc[b] < yc[b];\n                        break;\n                    }\n                }\n            }\n            // x < y? Point xc to the array of the bigger number.\n            if (xLTy) {\n                t = xc;\n                xc = yc;\n                yc = t;\n                y.s = -y.s;\n            }\n            b = (j = yc.length) - (i = xc.length);\n            // Append zeros to xc if shorter.\n            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\n            if (b > 0) for(; b--; xc[i++] = 0);\n            b = BASE - 1;\n            // Subtract yc from xc.\n            for(; j > a;){\n                if (xc[--j] < yc[j]) {\n                    for(i = j; i && !xc[--i]; xc[i] = b);\n                    --xc[i];\n                    xc[j] += BASE;\n                }\n                xc[j] -= yc[j];\n            }\n            // Remove leading zeros and adjust exponent accordingly.\n            for(; xc[0] == 0; xc.splice(0, 1), --ye);\n            // Zero?\n            if (!xc[0]) {\n                // Following IEEE 754 (2008) 6.3,\n                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\n                y.s = ROUNDING_MODE == 3 ? -1 : 1;\n                y.c = [\n                    y.e = 0\n                ];\n                return y;\n            }\n            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\n            // for finite x and y.\n            return normalise(y, xc, ye);\n        };\n        /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */ P.modulo = P.mod = function(y, b) {\n            var q, s, x = this;\n            y = new BigNumber(y, b);\n            // Return NaN if x is Infinity or NaN, or y is NaN or zero.\n            if (!x.c || !y.s || y.c && !y.c[0]) {\n                return new BigNumber(NaN);\n            // Return x if y is Infinity or x is zero.\n            } else if (!y.c || x.c && !x.c[0]) {\n                return new BigNumber(x);\n            }\n            if (MODULO_MODE == 9) {\n                // Euclidian division: q = sign(y) * floor(x / abs(y))\n                // r = x - qy    where  0 <= r < abs(y)\n                s = y.s;\n                y.s = 1;\n                q = div(x, y, 0, 3);\n                y.s = s;\n                q.s *= s;\n            } else {\n                q = div(x, y, 0, MODULO_MODE);\n            }\n            y = x.minus(q.times(y));\n            // To match JavaScript %, ensure sign of zero is sign of dividend.\n            if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\n            return y;\n        };\n        /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */ P.multipliedBy = P.times = function(y, b) {\n            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber(y, b)).c;\n            // Either NaN, ±Infinity or ±0?\n            if (!xc || !yc || !xc[0] || !yc[0]) {\n                // Return NaN if either is NaN, or one is 0 and the other is Infinity.\n                if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\n                    y.c = y.e = y.s = null;\n                } else {\n                    y.s *= x.s;\n                    // Return ±Infinity if either is ±Infinity.\n                    if (!xc || !yc) {\n                        y.c = y.e = null;\n                    // Return ±0 if either is ±0.\n                    } else {\n                        y.c = [\n                            0\n                        ];\n                        y.e = 0;\n                    }\n                }\n                return y;\n            }\n            e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\n            y.s *= x.s;\n            xcL = xc.length;\n            ycL = yc.length;\n            // Ensure xc points to longer array and xcL to its length.\n            if (xcL < ycL) {\n                zc = xc;\n                xc = yc;\n                yc = zc;\n                i = xcL;\n                xcL = ycL;\n                ycL = i;\n            }\n            // Initialise the result array with zeros.\n            for(i = xcL + ycL, zc = []; i--; zc.push(0));\n            base = BASE;\n            sqrtBase = SQRT_BASE;\n            for(i = ycL; --i >= 0;){\n                c = 0;\n                ylo = yc[i] % sqrtBase;\n                yhi = yc[i] / sqrtBase | 0;\n                for(k = xcL, j = i + k; j > i;){\n                    xlo = xc[--k] % sqrtBase;\n                    xhi = xc[k] / sqrtBase | 0;\n                    m = yhi * xlo + xhi * ylo;\n                    xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;\n                    c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\n                    zc[j--] = xlo % base;\n                }\n                zc[j] = c;\n            }\n            if (c) {\n                ++e;\n            } else {\n                zc.splice(0, 1);\n            }\n            return normalise(y, zc, e);\n        };\n        /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */ P.negated = function() {\n            var x = new BigNumber(this);\n            x.s = -x.s || null;\n            return x;\n        };\n        /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */ P.plus = function(y, b) {\n            var t, x = this, a = x.s;\n            y = new BigNumber(y, b);\n            b = y.s;\n            // Either NaN?\n            if (!a || !b) return new BigNumber(NaN);\n            // Signs differ?\n            if (a != b) {\n                y.s = -b;\n                return x.minus(y);\n            }\n            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;\n            if (!xe || !ye) {\n                // Return ±Infinity if either ±Infinity.\n                if (!xc || !yc) return new BigNumber(a / 0);\n                // Either zero?\n                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n                if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\n            }\n            xe = bitFloor(xe);\n            ye = bitFloor(ye);\n            xc = xc.slice();\n            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\n            if (a = xe - ye) {\n                if (a > 0) {\n                    ye = xe;\n                    t = yc;\n                } else {\n                    a = -a;\n                    t = xc;\n                }\n                t.reverse();\n                for(; a--; t.push(0));\n                t.reverse();\n            }\n            a = xc.length;\n            b = yc.length;\n            // Point xc to the longer array, and b to the shorter length.\n            if (a - b < 0) {\n                t = yc;\n                yc = xc;\n                xc = t;\n                b = a;\n            }\n            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\n            for(a = 0; b;){\n                a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\n                xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\n            }\n            if (a) {\n                xc = [\n                    a\n                ].concat(xc);\n                ++ye;\n            }\n            // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n            // ye = MAX_EXP + 1 possible\n            return normalise(y, xc, ye);\n        };\n        /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */ P.precision = P.sd = function(sd, rm) {\n            var c, n, v, x = this;\n            if (sd != null && sd !== !!sd) {\n                intCheck(sd, 1, MAX);\n                if (rm == null) rm = ROUNDING_MODE;\n                else intCheck(rm, 0, 8);\n                return round(new BigNumber(x), sd, rm);\n            }\n            if (!(c = x.c)) return null;\n            v = c.length - 1;\n            n = v * LOG_BASE + 1;\n            if (v = c[v]) {\n                // Subtract the number of trailing zeros of the last element.\n                for(; v % 10 == 0; v /= 10, n--);\n                // Add the number of digits of the first element.\n                for(v = c[0]; v >= 10; v /= 10, n++);\n            }\n            if (sd && x.e + 1 > n) n = x.e + 1;\n            return n;\n        };\n        /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */ P.shiftedBy = function(k) {\n            intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n            return this.times(\"1e\" + k);\n        };\n        /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */ P.squareRoot = P.sqrt = function() {\n            var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber(\"0.5\");\n            // Negative/NaN/Infinity/zero?\n            if (s !== 1 || !c || !c[0]) {\n                return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\n            }\n            // Initial estimate.\n            s = Math.sqrt(+valueOf(x));\n            // Math.sqrt underflow/overflow?\n            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n            if (s == 0 || s == 1 / 0) {\n                n = coeffToString(c);\n                if ((n.length + e) % 2 == 0) n += \"0\";\n                s = Math.sqrt(+n);\n                e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\n                if (s == 1 / 0) {\n                    n = \"5e\" + e;\n                } else {\n                    n = s.toExponential();\n                    n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n                }\n                r = new BigNumber(n);\n            } else {\n                r = new BigNumber(s + \"\");\n            }\n            // Check for zero.\n            // r could be zero if MIN_EXP is changed after the this value was created.\n            // This would cause a division by zero (x/t) and hence Infinity below, which would cause\n            // coeffToString to throw.\n            if (r.c[0]) {\n                e = r.e;\n                s = e + dp;\n                if (s < 3) s = 0;\n                // Newton-Raphson iteration.\n                for(;;){\n                    t = r;\n                    r = half.times(t.plus(div(x, t, dp, 1)));\n                    if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\n                        // The exponent of r may here be one less than the final result exponent,\n                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\n                        // are indexed correctly.\n                        if (r.e < e) --s;\n                        n = n.slice(s - 3, s + 1);\n                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\n                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\n                        // iteration.\n                        if (n == \"9999\" || !rep && n == \"4999\") {\n                            // On the first iteration only, check to see if rounding up gives the\n                            // exact result as the nines may infinitely repeat.\n                            if (!rep) {\n                                round(t, t.e + DECIMAL_PLACES + 2, 0);\n                                if (t.times(t).eq(x)) {\n                                    r = t;\n                                    break;\n                                }\n                            }\n                            dp += 4;\n                            s += 4;\n                            rep = 1;\n                        } else {\n                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\n                            // result. If not, then there are further digits and m will be truthy.\n                            if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                                // Truncate to the first rounding digit.\n                                round(r, r.e + DECIMAL_PLACES + 2, 1);\n                                m = !r.times(r).eq(x);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\n        };\n        /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */ P.toExponential = function(dp, rm) {\n            if (dp != null) {\n                intCheck(dp, 0, MAX);\n                dp++;\n            }\n            return format(this, dp, rm, 1);\n        };\n        /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */ P.toFixed = function(dp, rm) {\n            if (dp != null) {\n                intCheck(dp, 0, MAX);\n                dp = dp + this.e + 1;\n            }\n            return format(this, dp, rm);\n        };\n        /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */ P.toFormat = function(dp, rm, format) {\n            var str, x = this;\n            if (format == null) {\n                if (dp != null && rm && typeof rm == \"object\") {\n                    format = rm;\n                    rm = null;\n                } else if (dp && typeof dp == \"object\") {\n                    format = dp;\n                    dp = rm = null;\n                } else {\n                    format = FORMAT;\n                }\n            } else if (typeof format != \"object\") {\n                throw Error(bignumberError + \"Argument not an object: \" + format);\n            }\n            str = x.toFixed(dp, rm);\n            if (x.c) {\n                var i, arr = str.split(\".\"), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || \"\", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;\n                if (g2) {\n                    i = g1;\n                    g1 = g2;\n                    g2 = i;\n                    len -= i;\n                }\n                if (g1 > 0 && len > 0) {\n                    i = len % g1 || g1;\n                    intPart = intDigits.substr(0, i);\n                    for(; i < len; i += g1)intPart += groupSeparator + intDigits.substr(i, g1);\n                    if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\n                    if (isNeg) intPart = \"-\" + intPart;\n                }\n                str = fractionPart ? intPart + (format.decimalSeparator || \"\") + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp(\"\\\\d{\" + g2 + \"}\\\\B\", \"g\"), \"$&\" + (format.fractionGroupSeparator || \"\")) : fractionPart) : intPart;\n            }\n            return (format.prefix || \"\") + str + (format.suffix || \"\");\n        };\n        /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */ P.toFraction = function(md) {\n            var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;\n            if (md != null) {\n                n = new BigNumber(md);\n                // Throw if md is less than one or is not an integer, unless it is Infinity.\n                if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\n                    throw Error(bignumberError + \"Argument \" + (n.isInteger() ? \"out of range: \" : \"not an integer: \") + valueOf(n));\n                }\n            }\n            if (!xc) return new BigNumber(x);\n            d = new BigNumber(ONE);\n            n1 = d0 = new BigNumber(ONE);\n            d1 = n0 = new BigNumber(ONE);\n            s = coeffToString(xc);\n            // Determine initial denominator.\n            // d is a power of 10 and the minimum max denominator that specifies the value exactly.\n            e = d.e = s.length - x.e - 1;\n            d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\n            md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;\n            exp = MAX_EXP;\n            MAX_EXP = 1 / 0;\n            n = new BigNumber(s);\n            // n0 = d1 = 0\n            n0.c[0] = 0;\n            for(;;){\n                q = div(n, d, 0, 1);\n                d2 = d0.plus(q.times(d1));\n                if (d2.comparedTo(md) == 1) break;\n                d0 = d1;\n                d1 = d2;\n                n1 = n0.plus(q.times(d2 = n1));\n                n0 = d2;\n                d = n.minus(q.times(d2 = d));\n                n = d2;\n            }\n            d2 = div(md.minus(d0), d1, 0, 1);\n            n0 = n0.plus(d2.times(n1));\n            d0 = d0.plus(d2.times(d1));\n            n0.s = n1.s = x.s;\n            e = e * 2;\n            // Determine which fraction is closer to x, n0/d0 or n1/d1\n            r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [\n                n1,\n                d1\n            ] : [\n                n0,\n                d0\n            ];\n            MAX_EXP = exp;\n            return r;\n        };\n        /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */ P.toNumber = function() {\n            return +valueOf(this);\n        };\n        /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */ P.toPrecision = function(sd, rm) {\n            if (sd != null) intCheck(sd, 1, MAX);\n            return format(this, sd, rm, 2);\n        };\n        /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */ P.toString = function(b) {\n            var str, n = this, s = n.s, e = n.e;\n            // Infinity or NaN?\n            if (e === null) {\n                if (s) {\n                    str = \"Infinity\";\n                    if (s < 0) str = \"-\" + str;\n                } else {\n                    str = \"NaN\";\n                }\n            } else {\n                if (b == null) {\n                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, \"0\");\n                } else if (b === 10 && alphabetHasNormalDecimalDigits) {\n                    n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\n                    str = toFixedPoint(coeffToString(n.c), n.e, \"0\");\n                } else {\n                    intCheck(b, 2, ALPHABET.length, \"Base\");\n                    str = convertBase(toFixedPoint(coeffToString(n.c), e, \"0\"), 10, b, s, true);\n                }\n                if (s < 0 && n.c[0]) str = \"-\" + str;\n            }\n            return str;\n        };\n        /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */ P.valueOf = P.toJSON = function() {\n            return valueOf(this);\n        };\n        P._isBigNumber = true;\n        if (configObject != null) BigNumber.set(configObject);\n        return BigNumber;\n    }\n    // PRIVATE HELPER FUNCTIONS\n    // These functions don't need access to variables,\n    // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\n    function bitFloor(n) {\n        var i = n | 0;\n        return n > 0 || n === i ? i : i - 1;\n    }\n    // Return a coefficient array as a string of base 10 digits.\n    function coeffToString(a) {\n        var s, z, i = 1, j = a.length, r = a[0] + \"\";\n        for(; i < j;){\n            s = a[i++] + \"\";\n            z = LOG_BASE - s.length;\n            for(; z--; s = \"0\" + s);\n            r += s;\n        }\n        // Determine trailing zeros.\n        for(j = r.length; r.charCodeAt(--j) === 48;);\n        return r.slice(0, j + 1 || 1);\n    }\n    // Compare the value of BigNumbers x and y.\n    function compare(x, y) {\n        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;\n        // Either NaN?\n        if (!i || !j) return null;\n        a = xc && !xc[0];\n        b = yc && !yc[0];\n        // Either zero?\n        if (a || b) return a ? b ? 0 : -j : i;\n        // Signs differ?\n        if (i != j) return i;\n        a = i < 0;\n        b = k == l;\n        // Either Infinity?\n        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\n        // Compare exponents.\n        if (!b) return k > l ^ a ? 1 : -1;\n        j = (k = xc.length) < (l = yc.length) ? k : l;\n        // Compare digit by digit.\n        for(i = 0; i < j; i++)if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\n        // Compare lengths.\n        return k == l ? 0 : k > l ^ a ? 1 : -1;\n    }\n    /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */ function intCheck(n, min, max, name) {\n        if (n < min || n > max || n !== mathfloor(n)) {\n            throw Error(bignumberError + (name || \"Argument\") + (typeof n == \"number\" ? n < min || n > max ? \" out of range: \" : \" not an integer: \" : \" not a primitive number: \") + String(n));\n        }\n    }\n    // Assumes finite n.\n    function isOdd(n) {\n        var k = n.c.length - 1;\n        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\n    }\n    function toExponential(str, e) {\n        return (str.length > 1 ? str.charAt(0) + \".\" + str.slice(1) : str) + (e < 0 ? \"e\" : \"e+\") + e;\n    }\n    function toFixedPoint(str, e, z) {\n        var len, zs;\n        // Negative exponent?\n        if (e < 0) {\n            // Prepend zeros.\n            for(zs = z + \".\"; ++e; zs += z);\n            str = zs + str;\n        // Positive exponent\n        } else {\n            len = str.length;\n            // Append zeros.\n            if (++e > len) {\n                for(zs = z, e -= len; --e; zs += z);\n                str += zs;\n            } else if (e < len) {\n                str = str.slice(0, e) + \".\" + str.slice(e);\n            }\n        }\n        return str;\n    }\n    // EXPORT\n    BigNumber = clone();\n    BigNumber[\"default\"] = BigNumber.BigNumber = BigNumber;\n    // AMD.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return BigNumber;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    // Node.js and other environments that support module.exports.\n    } else {}\n})(void 0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzIiwibWFwcGluZ3MiOiI7QUFBRSxVQUFVQSxZQUFZO0lBQ3RCO0lBRUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZDQyxHQUdDLElBQUlDLFdBQ0ZDLFlBQVksOENBQ1pDLFdBQVdDLEtBQUtDLElBQUksRUFDcEJDLFlBQVlGLEtBQUtHLEtBQUssRUFFdEJDLGlCQUFpQixzQkFDakJDLGdCQUFnQkQsaUJBQWlCLDBEQUVqQ0UsT0FBTyxNQUNQQyxXQUFXLElBQ1hDLG1CQUFtQixrQkFDbkIsd0RBQXdEO0lBQ3hEQyxXQUFXO1FBQUM7UUFBRztRQUFJO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtLQUFLLEVBQ2xGQyxZQUFZLEtBRVosV0FBVztJQUNYLDBGQUEwRjtJQUMxRixzRUFBc0U7SUFDdEVDLE1BQU0sS0FBdUMsaUJBQWlCO0lBR2hFOztHQUVDLEdBQ0QsU0FBU0MsTUFBTUMsWUFBWTtRQUN6QixJQUFJQyxLQUFLQyxhQUFhQyxjQUNwQkMsSUFBSXBCLFVBQVVxQixTQUFTLEdBQUc7WUFBRUMsYUFBYXRCO1lBQVd1QixVQUFVO1lBQU1DLFNBQVM7UUFBSyxHQUNsRkMsTUFBTSxJQUFJekIsVUFBVSxJQUdwQix3RkFBd0Y7UUFHeEYsZ0ZBQWdGO1FBQ2hGLGtFQUFrRTtRQUVsRSwwRUFBMEU7UUFDMUUwQixpQkFBaUIsSUFFakIsbUZBQW1GO1FBQ25GLCtFQUErRTtRQUMvRSwrQkFBK0I7UUFDL0IsNkJBQTZCO1FBQzdCLGtDQUFrQztRQUNsQyxrQ0FBa0M7UUFDbEMsOERBQThEO1FBQzlELGdFQUFnRTtRQUNoRSxrRkFBa0Y7UUFDbEYsNkVBQTZFO1FBQzdFLDZFQUE2RTtRQUM3RUMsZ0JBQWdCLEdBRWhCLDZDQUE2QztRQUU3QyxpRkFBaUY7UUFDakYsa0JB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QyxHQUFHUixLQUFLLE1BQU1JLElBQUlJLEtBQUssQ0FBQ1I7WUFDMUM7UUFDRjtRQUVBLE9BQU9JO0lBQ1Q7SUFHQSxTQUFTO0lBR1R2RCxZQUFZZTtJQUNaZixTQUFTLENBQUMsVUFBVSxHQUFHQSxVQUFVQSxTQUFTLEdBQUdBO0lBRTdDLE9BQU87SUFDUCxJQUFJLElBQXlDLEVBQUU7UUFDN0N3USxtQ0FBTztZQUFjLE9BQU94UTtRQUFXLENBQUM7QUFBQSxrR0FBQztJQUUzQyw4REFBOEQ7SUFDOUQsT0FBTyxFQVVOO0FBQ0gsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb3RpZnktdG8teW91dHViZS8uL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzP2U0N2MiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbiAoZ2xvYmFsT2JqZWN0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuLypcclxuICogICAgICBiaWdudW1iZXIuanMgdjkuMS4yXHJcbiAqICAgICAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMjIgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogICAgICBNSVQgTGljZW5zZWQuXHJcbiAqXHJcbiAqICAgICAgQmlnTnVtYmVyLnByb3RvdHlwZSBtZXRob2RzICAgICB8ICBCaWdOdW1iZXIgbWV0aG9kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGFic29sdXRlVmFsdWUgICAgICAgICAgICBhYnMgICAgfCAgY2xvbmVcclxuICogICAgICBjb21wYXJlZFRvICAgICAgICAgICAgICAgICAgICAgIHwgIGNvbmZpZyAgICAgICAgICAgICAgIHNldFxyXG4gKiAgICAgIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICBkcCAgICAgfCAgICAgIERFQ0lNQUxfUExBQ0VTXHJcbiAqICAgICAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgIGRpdiAgICB8ICAgICAgUk9VTkRJTkdfTU9ERVxyXG4gKiAgICAgIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICBpZGl2ICAgfCAgICAgIEVYUE9ORU5USUFMX0FUXHJcbiAqICAgICAgZXhwb25lbnRpYXRlZEJ5ICAgICAgICAgIHBvdyAgICB8ICAgICAgUkFOR0VcclxuICogICAgICBpbnRlZ2VyVmFsdWUgICAgICAgICAgICAgICAgICAgIHwgICAgICBDUllQVE9cclxuICogICAgICBpc0VxdWFsVG8gICAgICAgICAgICAgICAgZXEgICAgIHwgICAgICBNT0RVTE9fTU9ERVxyXG4gKiAgICAgIGlzRmluaXRlICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIFBPV19QUkVDSVNJT05cclxuICogICAgICBpc0dyZWF0ZXJUaGFuICAgICAgICAgICAgZ3QgICAgIHwgICAgICBGT1JNQVRcclxuICogICAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvICAgZ3RlICAgIHwgICAgICBBTFBIQUJFVFxyXG4gKiAgICAgIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgICAgICAgfCAgaXNCaWdOdW1iZXJcclxuICogICAgICBpc0xlc3NUaGFuICAgICAgICAgICAgICAgbHQgICAgIHwgIG1heGltdW0gICAgICAgICAgICAgIG1heFxyXG4gKiAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG8gICAgICBsdGUgICAgfCAgbWluaW11bSAgICAgICAgICAgICAgbWluXHJcbiAqICAgICAgaXNOYU4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByYW5kb21cclxuICogICAgICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgICAgICAgIHwgIHN1bVxyXG4gKiAgICAgIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGlzWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1pbnVzICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1vZHVsbyAgICAgICAgICAgICAgICAgICBtb2QgICAgfFxyXG4gKiAgICAgIG11bHRpcGxpZWRCeSAgICAgICAgICAgICB0aW1lcyAgfFxyXG4gKiAgICAgIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHBsdXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHByZWNpc2lvbiAgICAgICAgICAgICAgICBzZCAgICAgfFxyXG4gKiAgICAgIHNoaWZ0ZWRCeSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHNxdWFyZVJvb3QgICAgICAgICAgICAgICBzcXJ0ICAgfFxyXG4gKiAgICAgIHRvRXhwb25lbnRpYWwgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRml4ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRnJhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvSlNPTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvUHJlY2lzaW9uICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gIHZhciBCaWdOdW1iZXIsXHJcbiAgICBpc051bWVyaWMgPSAvXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxcclxuICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuXHJcbiAgICBiaWdudW1iZXJFcnJvciA9ICdbQmlnTnVtYmVyIEVycm9yXSAnLFxyXG4gICAgdG9vTWFueURpZ2l0cyA9IGJpZ251bWJlckVycm9yICsgJ051bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6ICcsXHJcblxyXG4gICAgQkFTRSA9IDFlMTQsXHJcbiAgICBMT0dfQkFTRSA9IDE0LFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYsICAgICAgICAgLy8gMl41MyAtIDFcclxuICAgIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gICAgU1FSVF9CQVNFID0gMWU3LFxyXG5cclxuICAgIC8vIEVESVRBQkxFXHJcbiAgICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAgIC8vIHRoZSBhcmd1bWVudHMgdG8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQsIGFuZCB0b1ByZWNpc2lvbi5cclxuICAgIE1BWCA9IDFFOTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0lOVDMyXHJcblxyXG5cclxuICAvKlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsb25lKGNvbmZpZ09iamVjdCkge1xyXG4gICAgdmFyIGRpdiwgY29udmVydEJhc2UsIHBhcnNlTnVtZXJpYyxcclxuICAgICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBCaWdOdW1iZXIsIHRvU3RyaW5nOiBudWxsLCB2YWx1ZU9mOiBudWxsIH0sXHJcbiAgICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUQUJMRSBDT05GSUcgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAgIC8vIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuc2V0LlxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbi5cclxuICAgICAgREVDSU1BTF9QTEFDRVMgPSAyMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcywgYW5kIHdoZW4gdXNpbmdcclxuICAgICAgLy8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQgYW5kIHRvUHJlY2lzaW9uLCBhbmQgcm91bmQgKGRlZmF1bHQgdmFsdWUpLlxyXG4gICAgICAvLyBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAgIC8vIERPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAgIC8vIENFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgICAvLyBIQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAgIC8vIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgICAgLy8gSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAvLyBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgICAgLy8gICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAgIC8vIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgICAgLy8gSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgIC8vIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAgIC8vIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAgIC8vIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgTU9EVUxPX01PREUgPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiB0aGUgZXhwb25lbnRpYXRlZEJ5IG9wZXJhdGlvbi5cclxuICAgICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgIFBPV19QUkVDSVNJT04gPSAwLCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgICAgRk9STUFUID0ge1xyXG4gICAgICAgIHByZWZpeDogJycsXHJcbiAgICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgc3VmZml4OiAnJ1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gVGhlIGFscGhhYmV0IHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi4gSXQgbXVzdCBiZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgbG9uZywgd2l0aCBubyAnKycsXHJcbiAgICAgIC8vICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgIC8vICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJ1xyXG4gICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxyXG4gICAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB0cnVlO1xyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZ051bWJlciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogdiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqIFtiXSB7bnVtYmVyfSBUaGUgYmFzZSBvZiB2LiBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJpZ051bWJlcih2LCBiKSB7XHJcbiAgICAgIHZhciBhbHBoYWJldCwgYywgY2FzZUNoYW5nZWQsIGUsIGksIGlzTnVtLCBsZW4sIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgYG5ld2AuXHJcbiAgICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSByZXR1cm4gbmV3IEJpZ051bWJlcih2LCBiKTtcclxuXHJcbiAgICAgIGlmIChiID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHYgJiYgdi5faXNCaWdOdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgIHgucyA9IHYucztcclxuXHJcbiAgICAgICAgICBpZiAoIXYuYyB8fCB2LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgICB4LmMgPSB2LmMuc2xpY2UoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpICYmIHYgKiAwID09IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgYDEgLyBuYCB0byBoYW5kbGUgbWludXMgemVybyBhbHNvLlxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHYgPSAtdiwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLCB3aGVyZSBuIDwgMjE0NzQ4MzY0OCAoMioqMzEpLlxyXG4gICAgICAgICAgaWYgKHYgPT09IH5+dikge1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgICB4LmMgPSBbdl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYy50ZXN0KHN0ciA9IFN0cmluZyh2KSkpIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSk7XHJcblxyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICAgICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudCwgd2hpbGVcclxuICAgICAgICAvLyBhbHNvIHJvdW5kaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgICAgaWYgKGIgPT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih2KTtcclxuICAgICAgICAgIHJldHVybiByb3VuZCh4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG5cclxuICAgICAgICBpZiAoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICAgIGlmICh2ICogMCAhPSAwKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0sIGIpO1xyXG5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcgJiYgc3RyLnJlcGxhY2UoL14wXFwuMCp8XFwuLywgJycpLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxwaGFiZXQgPSBBTFBIQUJFVC5zbGljZSgwLCBiKTtcclxuICAgICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgc3RyIGlzIGEgdmFsaWQgYmFzZSBiIG51bWJlci5cclxuICAgICAgICAvLyBEb24ndCB1c2UgUmVnRXhwLCBzbyBhbHBoYWJldCBjYW4gY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGMgPSBzdHIuY2hhckF0KGkpKSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmICcuJyBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXQgaGFzIG5vdCBiZSBmb3VuZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgaWYgKGkgPiBlKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gbGVuO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjYXNlQ2hhbmdlZCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBBbGxvdyBlLmcuIGhleGFkZWNpbWFsICdGRicgYXMgd2VsbCBhcyAnZmYnLlxyXG4gICAgICAgICAgICAgIGlmIChzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgICAgICBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWMoeCwgU3RyaW5nKHYpLCBpc051bSwgYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgICBpc051bSA9IGZhbHNlO1xyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ciwgYiwgMTAsIHgucyk7XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgZWxzZSBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4Oyk7XHJcblxyXG4gICAgICBpZiAoc3RyID0gc3RyLnNsaWNlKGksICsrbGVuKSkge1xyXG4gICAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgIGlmIChpc051bSAmJiBCaWdOdW1iZXIuREVCVUcgJiZcclxuICAgICAgICAgIGxlbiA+IDE1ICYmICh2ID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2ICE9PSBtYXRoZmxvb3IodikpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArICh4LnMgKiB2KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgaWYgKChlID0gZSAtIGkgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFOyAgLy8gaSA8IDFcclxuXHJcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgICB4LmMucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaSA9IExPR19CQVNFIC0gKHN0ciA9IHN0ci5zbGljZShpKSkubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcclxuXHJcblxyXG4gICAgQmlnTnVtYmVyLmNsb25lID0gY2xvbmU7XHJcblxyXG4gICAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICAgIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEFjY2VwdCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgKGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzXHJcbiAgICAgKiBhIG51bWJlciwgaXQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIHN0YXRlZCk6XHJcbiAgICAgKlxyXG4gICAgICogICBERUNJTUFMX1BMQUNFUyAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBST1VORElOR19NT0RFICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDhcclxuICAgICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgICAqICAgUkFOR0UgICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggKG5vdCB6ZXJvKSAgb3IgIFstTUFYIHRvIC0xLCAxIHRvIE1BWF1cclxuICAgICAqICAgQ1JZUFRPICAgICAgICAgICB7Ym9vbGVhbn0gICAgICAgICAgdHJ1ZSBvciBmYWxzZVxyXG4gICAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgICAqICAgUE9XX1BSRUNJU0lPTiAgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgQUxQSEFCRVQgICAgICAgICB7c3RyaW5nfSAgICAgICAgICAgQSBzdHJpbmcgb2YgdHdvIG9yIG1vcmUgdW5pcXVlIGNoYXJhY3RlcnMgd2hpY2ggZG9lc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICAgKiAgIEZPUk1BVCAgICAgICAgICAge29iamVjdH0gICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHNvbWUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogICAgIHByZWZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cclxuICAgICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKlxyXG4gICAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgICAqXHJcbiAgICAgKiBFLmcuXHJcbiAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAqXHJcbiAgICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgZXhjZXB0IGZvciBBTFBIQUJFVC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5jb25maWcgPSBCaWdOdW1iZXIuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICB2YXIgcCwgdjtcclxuXHJcbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBERUNJTUFMX1BMQUNFUyB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnREVDSU1BTF9QTEFDRVMnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJPVU5ESU5HX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA4LCBwKTtcclxuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBFWFBPTkVOVElBTF9BVCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF07XHJcbiAgICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIC0xIGluY2x1c2l2ZSwgaW50ZWdlciAxIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJBTkdFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZXxjYW5ub3QgYmUgemVyb306IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDEsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF07XHJcbiAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgTUlOX0VYUCA9IC0oTUFYX0VYUCA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBjYW5ub3QgYmUgemVybzogJyArIHYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQ1JZUFRPJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgPT09ICEhdikge1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgICAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSAhdjtcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IHRydWUgb3IgZmFsc2U6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTU9EVUxPX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOSwgcCk7XHJcbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdQT1dfUFJFQ0lTSU9OJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdGT1JNQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ29iamVjdCcpIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBTFBIQUJFVCB7c3RyaW5nfVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdBTFBIQUJFVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBsZXNzIHRoYW4gdHdvIGNoYXJhY3RlcnMsXHJcbiAgICAgICAgICAgIC8vIG9yIGlmIGl0IGNvbnRhaW5zICcrJywgJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIGEgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ3N0cmluZycgJiYgIS9eLj8kfFsrXFwtLlxcc118KC4pLipcXDEvLnRlc3QodikpIHtcclxuICAgICAgICAgICAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB2LnNsaWNlKDAsIDEwKSA9PSAnMDEyMzQ1Njc4OSc7XHJcbiAgICAgICAgICAgICAgQUxQSEFCRVQgPSB2O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGludmFsaWQ6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBPYmplY3QgZXhwZWN0ZWQ6IHt2fSdcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ09iamVjdCBleHBlY3RlZDogJyArIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIERFQ0lNQUxfUExBQ0VTOiBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICAgIEVYUE9ORU5USUFMX0FUOiBbVE9fRVhQX05FRywgVE9fRVhQX1BPU10sXHJcbiAgICAgICAgUkFOR0U6IFtNSU5fRVhQLCBNQVhfRVhQXSxcclxuICAgICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgICBNT0RVTE9fTU9ERTogTU9EVUxPX01PREUsXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTjogUE9XX1BSRUNJU0lPTixcclxuICAgICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgICBBTFBIQUJFVDogQUxQSEFCRVRcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB2IGlzIGEgQmlnTnVtYmVyIGluc3RhbmNlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIElmIEJpZ051bWJlci5ERUJVRyBpcyB0cnVlLCB0aHJvdyBpZiBhIEJpZ051bWJlciBpbnN0YW5jZSBpcyBub3Qgd2VsbC1mb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogdiB7YW55fVxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBJbnZhbGlkIEJpZ051bWJlcjoge3Z9J1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICBpZiAoIXYgfHwgdi5faXNCaWdOdW1iZXIgIT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgdmFyIGksIG4sXHJcbiAgICAgICAgYyA9IHYuYyxcclxuICAgICAgICBlID0gdi5lLFxyXG4gICAgICAgIHMgPSB2LnM7XHJcblxyXG4gICAgICBvdXQ6IGlmICh7fS50b1N0cmluZy5jYWxsKGMpID09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuXHJcbiAgICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgemVybywgdGhlIEJpZ051bWJlciB2YWx1ZSBtdXN0IGJlIHplcm8uXHJcbiAgICAgICAgICBpZiAoY1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoaSA8IDEpIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAgIC8vaWYgKE1hdGguY2VpbChNYXRoLmxvZyhjWzBdICsgMSkgLyBNYXRoLkxOMTApID09IGkpIHtcclxuICAgICAgICAgIGlmIChTdHJpbmcoY1swXSkubGVuZ3RoID09IGkpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbiA9IGNbaV07XHJcbiAgICAgICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gQkFTRSB8fCBuICE9PSBtYXRoZmxvb3IobikpIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGFzdCBlbGVtZW50IGNhbm5vdCBiZSB6ZXJvLCB1bmxlc3MgaXQgaXMgdGhlIG9ubHkgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKG4gIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdJbnZhbGlkIEJpZ051bWJlcjogJyArIHYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIC0xKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgICAvLyBDaGVjayBpZiBNYXRoLnJhbmRvbSgpIHByb2R1Y2VzIG1vcmUgdGhhbiAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXHJcbiAgICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgICB2YXIgcmFuZG9tNTNiaXRJbnQgPSAoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpICYgMHgxZmZmZmZcclxuICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGMgPSBbXSxcclxuICAgICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAgIGlmIChkcCA9PSBudWxsKSBkcCA9IERFQ0lNQUxfUExBQ0VTO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoayAqPSAyKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XHJcbiAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgNF0gPDwgMTYpICsgKGFbaSArIDVdIDw8IDgpICsgYVtpICsgNl07XHJcblxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgIGRwICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cclxuICAgICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByYW5kLmUgPSBlO1xyXG4gICAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuc3VtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICBzdW0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgICBjb252ZXJ0QmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICogQ29udmVydCBzdHJpbmcgb2YgYmFzZUluIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYmFzZU91dC5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgdmFyIGosXHJcbiAgICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgICBhcnJMLFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgICAgYXJyWzBdICs9IGFscGhhYmV0LmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PSBudWxsKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgdG9TdHJpbmcsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZSAxMCB0byBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICAgIHZhciBhbHBoYWJldCwgZCwgZSwgaywgciwgeCwgeGMsIHksXHJcbiAgICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgICAgeS5jID0gdG9CYXNlT3V0KHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKHguYyksIHguZSwgJzAnKSxcclxuICAgICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICAgID8gKGFscGhhYmV0ID0gQUxQSEFCRVQsIGRlY2ltYWwpXHJcbiAgICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgICBlID0gayA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIC0tZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5jID0geGM7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgICB4YyA9IHguYztcclxuICAgICAgICAgIHIgPSB4LnI7XHJcbiAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGNvbnZlcnRlZCB0byBiYXNlT3V0LlxyXG5cclxuICAgICAgICAvLyBUSGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQ6IHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICAgIGsgPSBiYXNlT3V0IC8gMjtcclxuICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiYgeGNbZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgICAgLy8gemVybywgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBiYXNlIGNvbnZlcnNpb24gaXMgemVybyBvciwgaWYgcm91bmRpbmcgdXAsIGEgdmFsdWVcclxuICAgICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIDFeLWRwIG9yIDBcclxuICAgICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB4YyB0byB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgICAgeGMgPSBbMV0uY29uY2F0KHhjKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsIGFscGhhYmV0LmNoYXJBdCgwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHgsIGssIGJhc2UpIHtcclxuICAgICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICBpID0geC5sZW5ndGgsXHJcbiAgICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOykge1xyXG4gICAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcclxuICAgICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcclxuXHJcbiAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXHJcbiAgICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSAtIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IDA7IHljW2ldID09ICh4Y1tpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICAgICAgaWYgKHljW2ldID4gKHhjW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgICAgcWMucHVzaCgxKTtcclxuICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsaXNlIHhjIGFuZCB5YyBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHljIGlzID49IGJhc2UgLyAyLlxyXG5cclxuICAgICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gaGFuZGxlIG9kZCBiYXNlcyB3aGVyZSB5Y1swXSA9PSAoYmFzZSAvIDIpIC0gMS5cclxuICAgICAgICAgIC8vIGlmIChuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyKSB7XHJcbiAgICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgICAgeWMgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHhjID0gbXVsdGlwbHkoeGMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgIHJlbSA9IHhjLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyByZW1bcmVtTCsrXSA9IDApO1xyXG4gICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICAgIHljMCA9IHljWzBdO1xyXG4gICAgICAgICAgaWYgKHljWzFdID49IGJhc2UgLyAyKSB5YzArKztcclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgIC8vIGVsc2UgaWYgKGJhc2UgPT0gMyAmJiB5YzAgPT0gMSkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgY21wID0gY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXHJcblxyXG4gICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgIC8vICBwcm9kdWN0ID0gZGl2aXNvciBtdWx0aXBsaWVkIGJ5IHRyaWFsIGRpZ2l0IChuKS5cclxuICAgICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3QgaXMgZ3JlYXRlciB0aGFuIHJlbWFpbmRlcjpcclxuICAgICAgICAgICAgICAvLyAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdCwgZGVjcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IHdhcyBsZXNzIHRoYW4gcmVtYWluZGVyIGF0IHRoZSBsYXN0IGNvbXBhcmU6XHJcbiAgICAgICAgICAgICAgLy8gICAgQ29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yLlxyXG4gICAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgICAvLyAgICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIsIGluY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0ID4gcmVtYWluZGVyIHRoZW4gdHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5YywgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3csXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBpZiAobiA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYmFzZSA9PSBCQVNFKSB7XHJcblxyXG4gICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIHJvdW5kKHEsIGRwICsgKHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSArIDEsIHJtLCBtb3JlKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcTtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAgICogbm90YXRpb24gcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAqXHJcbiAgICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgICAqIGk6IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICAgKiBybTogdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXQobiwgaSwgcm0sIGlkKSB7XHJcbiAgICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIGMwID0gbi5jWzBdO1xyXG4gICAgICBuZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgc3RyID0gaWQgPT0gMSB8fCBpZCA9PSAyICYmIChuZSA8PSBUT19FWFBfTkVHIHx8IG5lID49IFRPX0VYUF9QT1MpXHJcbiAgICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIG5lLCAnMCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAgIC8vIG4uZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSB3YXMgcm91bmRlZCB1cC5cclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGZvciAoOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyk7XHJcbiAgICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBpZiAoZSArIDEgPiBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgKz0gZSAtIGxlbjtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICBmdW5jdGlvbiBtYXhPck1pbihhcmdzLCBuKSB7XHJcbiAgICAgIHZhciBrLCB5LFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYXJnc1tpXSk7XHJcbiAgICAgICAgaWYgKCF5LnMgfHwgKGsgPSBjb21wYXJlKHgsIHkpKSA9PT0gbiB8fCBrID09PSAwICYmIHgucyA9PT0gbikge1xyXG4gICAgICAgICAgeCA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGogPSBjLmxlbmd0aDtcclxuXHJcbiAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmFzZSAxMCBleHBvbmVudC4gRmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKChlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgbi5jID0gW24uZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4uZSA9IGU7XHJcbiAgICAgICAgbi5jID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSxcclxuICAgICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxyXG4gICAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgICB2YXIgYmFzZSxcclxuICAgICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICAgIGlmIChpc0luZmluaXR5T3JOYU4udGVzdChzKSkge1xyXG4gICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICghaXNOdW0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSAocDIgPSBwMi50b0xvd2VyQ2FzZSgpKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xyXG4gICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZG90QWZ0ZXIsICckMScpLnJlcGxhY2UoZG90QmVmb3JlLCAnMC4kMScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxyXG4gICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuaSA+PSB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICAgIGZvciAoOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkpO1xyXG4gICAgICAgICAgICAgICAgbiA9IHJkID0gMDtcclxuICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLlxyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cclxuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IG4ucyAqICgyIC0gaXNPZGQobikpIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICAgKi9cclxuICAgIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMucztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC0gMCA9IG5cclxuICAgICAqICBuIC0gTiA9IE5cclxuICAgICAqICBuIC0gSSA9IC1JXHJcbiAgICAgKiAgMCAtIG4gPSAtblxyXG4gICAgICogIDAgLSAwID0gMFxyXG4gICAgICogIDAgLSBOID0gTlxyXG4gICAgICogIDAgLSBJID0gLUlcclxuICAgICAqICBOIC0gbiA9IE5cclxuICAgICAqICBOIC0gMCA9IE5cclxuICAgICAqICBOIC0gTiA9IE5cclxuICAgICAqICBOIC0gSSA9IE5cclxuICAgICAqICBJIC0gbiA9IElcclxuICAgICAqICBJIC0gMCA9IElcclxuICAgICAqICBJIC0gTiA9IE5cclxuICAgICAqICBJIC0gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmICh4TFR5KSB7XHJcbiAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIHhjID0geWM7XHJcbiAgICAgICAgeWMgPSB0O1xyXG4gICAgICAgIHkucyA9IC15LnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB7XHJcbiAgICAgICAgemMgPSB4YztcclxuICAgICAgICB4YyA9IHljO1xyXG4gICAgICAgIHljID0gemM7XHJcbiAgICAgICAgaSA9IHhjTDtcclxuICAgICAgICB4Y0wgPSB5Y0w7XHJcbiAgICAgICAgeWNMID0gaTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChrID0geGNMLCBqID0gaSArIGs7IGogPiBpOykge1xyXG4gICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xyXG4gICAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpjW2pdID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICArK2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHpjLCBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAgICovXHJcbiAgICBQLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgaWYgKGEgLSBiIDwgMCkge1xyXG4gICAgICAgIHQgPSB5YztcclxuICAgICAgICB5YyA9IHhjO1xyXG4gICAgICAgIHhjID0gdDtcclxuICAgICAgICBiID0gYTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgICArK3llO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgICAqXHJcbiAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICAgKi9cclxuICAgIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIHNxcnQoLW4pID0gIE5cclxuICAgICAqICBzcXJ0KE4pID0gIE5cclxuICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYyA9IHguYyxcclxuICAgICAgICBzID0geC5zLFxyXG4gICAgICAgIGUgPSB4LmUsXHJcbiAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICBzID0gZSArIGRwO1xyXG4gICAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogRk9STUFUID0ge1xyXG4gICAgICogICBwcmVmaXg6ICcnLFxyXG4gICAgICogICBncm91cFNpemU6IDMsXHJcbiAgICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAqICAgc3VmZml4OiAnJ1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICAgIGlmICh4LmMpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGcyKSB7XHJcbiAgICAgICAgICBpID0gZzE7XHJcbiAgICAgICAgICBnMSA9IGcyO1xyXG4gICAgICAgICAgZzIgPSBpO1xyXG4gICAgICAgICAgbGVuIC09IGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIG4uZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICAgKi9cclxuICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgICByZXR1cm4gQmlnTnVtYmVyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuICAvLyBUaGVzZSBmdW5jdGlvbnMgZG9uJ3QgbmVlZCBhY2Nlc3MgdG8gdmFyaWFibGVzLFxyXG4gIC8vIGUuZy4gREVDSU1BTF9QTEFDRVMsIGluIHRoZSBzY29wZSBvZiB0aGUgYGNsb25lYCBmdW5jdGlvbiBhYm92ZS5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgIHZhciBpID0gbiB8IDA7XHJcbiAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICB9XHJcblxyXG5cclxuICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgIHZhciBzLCB6LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgIGZvciAoOyBpIDwgajspIHtcclxuICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgICByICs9IHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICAgIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuICBmdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICAgIHZhciBhLCBiLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmMsXHJcbiAgICAgIGkgPSB4LnMsXHJcbiAgICAgIGogPSB5LnMsXHJcbiAgICAgIGsgPSB4LmUsXHJcbiAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICAgIGEgPSBpIDwgMDtcclxuICAgIGIgPSBrID09IGw7XHJcblxyXG4gICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IG1hdGhmbG9vcihuKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG4gIGZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICAgIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgICB2YXIgbGVuLCB6cztcclxuXHJcbiAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICAgIHN0ciArPSB6cztcclxuICAgICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBFWFBPUlRcclxuXHJcblxyXG4gIEJpZ051bWJlciA9IGNsb25lKCk7XHJcbiAgQmlnTnVtYmVyWydkZWZhdWx0J10gPSBCaWdOdW1iZXIuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBBTUQuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlnTnVtYmVyOyB9KTtcclxuXHJcbiAgLy8gTm9kZS5qcyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBCcm93c2VyLlxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWdsb2JhbE9iamVjdCkge1xyXG4gICAgICBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmID8gc2VsZiA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxPYmplY3QuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiJdLCJuYW1lcyI6WyJnbG9iYWxPYmplY3QiLCJCaWdOdW1iZXIiLCJpc051bWVyaWMiLCJtYXRoY2VpbCIsIk1hdGgiLCJjZWlsIiwibWF0aGZsb29yIiwiZmxvb3IiLCJiaWdudW1iZXJFcnJvciIsInRvb01hbnlEaWdpdHMiLCJCQVNFIiwiTE9HX0JBU0UiLCJNQVhfU0FGRV9JTlRFR0VSIiwiUE9XU19URU4iLCJTUVJUX0JBU0UiLCJNQVgiLCJjbG9uZSIsImNvbmZpZ09iamVjdCIsImRpdiIsImNvbnZlcnRCYXNlIiwicGFyc2VOdW1lcmljIiwiUCIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIiwidG9TdHJpbmciLCJ2YWx1ZU9mIiwiT05FIiwiREVDSU1BTF9QTEFDRVMiLCJST1VORElOR19NT0RFIiwiVE9fRVhQX05FRyIsIlRPX0VYUF9QT1MiLCJNSU5fRVhQIiwiTUFYX0VYUCIsIkNSWVBUTyIsIk1PRFVMT19NT0RFIiwiUE9XX1BSRUNJU0lPTiIsIkZPUk1BVCIsInByZWZpeCIsImdyb3VwU2l6ZSIsInNlY29uZGFyeUdyb3VwU2l6ZSIsImdyb3VwU2VwYXJhdG9yIiwiZGVjaW1hbFNlcGFyYXRvciIsImZyYWN0aW9uR3JvdXBTaXplIiwiZnJhY3Rpb25Hcm91cFNlcGFyYXRvciIsInN1ZmZpeCIsIkFMUEhBQkVUIiwiYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzIiwidiIsImIiLCJhbHBoYWJldCIsImMiLCJjYXNlQ2hhbmdlZCIsImUiLCJpIiwiaXNOdW0iLCJsZW4iLCJzdHIiLCJ4IiwiX2lzQmlnTnVtYmVyIiwicyIsInNsaWNlIiwiU3RyaW5nIiwidGVzdCIsImNoYXJDb2RlQXQiLCJpbmRleE9mIiwicmVwbGFjZSIsInNlYXJjaCIsInN1YnN0cmluZyIsImxlbmd0aCIsImludENoZWNrIiwicm91bmQiLCJERUJVRyIsIkVycm9yIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsInB1c2giLCJST1VORF9VUCIsIlJPVU5EX0RPV04iLCJST1VORF9DRUlMIiwiUk9VTkRfRkxPT1IiLCJST1VORF9IQUxGX1VQIiwiUk9VTkRfSEFMRl9ET1dOIiwiUk9VTkRfSEFMRl9FVkVOIiwiUk9VTkRfSEFMRl9DRUlMIiwiUk9VTkRfSEFMRl9GTE9PUiIsIkVVQ0xJRCIsImNvbmZpZyIsInNldCIsIm9iaiIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsInBvcCIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsInJhbmRvbUJ5dGVzIiwiRVhQT05FTlRJQUxfQVQiLCJSQU5HRSIsImlzQmlnTnVtYmVyIiwibiIsIm91dCIsImNhbGwiLCJtYXhpbXVtIiwibWF4IiwibWF4T3JNaW4iLCJhcmd1bWVudHMiLCJtaW5pbXVtIiwibWluIiwicmFuZG9tIiwicG93Ml81MyIsInJhbmRvbTUzYml0SW50IiwiZHAiLCJhIiwiayIsInJhbmQiLCJVaW50MzJBcnJheSIsImNvcHkiLCJzcGxpY2UiLCJzdW0iLCJhcmdzIiwicGx1cyIsImRlY2ltYWwiLCJ0b0Jhc2VPdXQiLCJiYXNlSW4iLCJiYXNlT3V0IiwiaiIsImFyciIsImFyckwiLCJyZXZlcnNlIiwic2lnbiIsImNhbGxlcklzVG9TdHJpbmciLCJkIiwiciIsInhjIiwieSIsInJtIiwicG93IiwidG9GaXhlZFBvaW50IiwiY29lZmZUb1N0cmluZyIsImNvbmNhdCIsIm11bHRpcGx5IiwiYmFzZSIsIm0iLCJ0ZW1wIiwieGxvIiwieGhpIiwiY2FycnkiLCJrbG8iLCJraGkiLCJjb21wYXJlIiwiYUwiLCJiTCIsImNtcCIsInN1YnRyYWN0IiwibW9yZSIsInByb2QiLCJwcm9kTCIsInEiLCJxYyIsInJlbSIsInJlbUwiLCJyZW0wIiwieGkiLCJ4TCIsInljMCIsInlMIiwieXoiLCJ5YyIsIk5hTiIsImJpdEZsb29yIiwiZm9ybWF0IiwiaWQiLCJjMCIsIm5lIiwidG9FeHBvbmVudGlhbCIsIm5vcm1hbGlzZSIsImJhc2VQcmVmaXgiLCJkb3RBZnRlciIsImRvdEJlZm9yZSIsImlzSW5maW5pdHlPck5hTiIsIndoaXRlc3BhY2VPclBsdXMiLCJpc05hTiIsInAxIiwicDIiLCJzZCIsIm5pIiwicmQiLCJwb3dzMTAiLCJhYnNvbHV0ZVZhbHVlIiwiYWJzIiwiY29tcGFyZWRUbyIsImRlY2ltYWxQbGFjZXMiLCJkaXZpZGVkQnkiLCJkaXZpZGVkVG9JbnRlZ2VyQnkiLCJpZGl2IiwiZXhwb25lbnRpYXRlZEJ5IiwiaGFsZiIsImlzTW9kRXhwIiwibklzQmlnIiwibklzTmVnIiwibklzT2RkIiwiaXNJbnRlZ2VyIiwiaXNPZGQiLCJtb2QiLCJ0aW1lcyIsImludGVnZXJWYWx1ZSIsImlzRXF1YWxUbyIsImVxIiwiaXNGaW5pdGUiLCJpc0dyZWF0ZXJUaGFuIiwiZ3QiLCJpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvIiwiZ3RlIiwiaXNMZXNzVGhhbiIsImx0IiwiaXNMZXNzVGhhbk9yRXF1YWxUbyIsImx0ZSIsImlzTmVnYXRpdmUiLCJpc1Bvc2l0aXZlIiwiaXNaZXJvIiwibWludXMiLCJ0IiwieExUeSIsInhlIiwieWUiLCJtb2R1bG8iLCJtdWx0aXBsaWVkQnkiLCJ4Y0wiLCJ5Y0wiLCJ5bG8iLCJ5aGkiLCJ6YyIsInNxcnRCYXNlIiwibmVnYXRlZCIsInByZWNpc2lvbiIsInNoaWZ0ZWRCeSIsInNxdWFyZVJvb3QiLCJzcXJ0IiwicmVwIiwidG9GaXhlZCIsInRvRm9ybWF0Iiwic3BsaXQiLCJnMSIsImcyIiwiaW50UGFydCIsImZyYWN0aW9uUGFydCIsImlzTmVnIiwiaW50RGlnaXRzIiwic3Vic3RyIiwiUmVnRXhwIiwidG9GcmFjdGlvbiIsIm1kIiwiZDAiLCJkMSIsImQyIiwiZXhwIiwibjAiLCJuMSIsInRvTnVtYmVyIiwidG9QcmVjaXNpb24iLCJ0b0pTT04iLCJ6IiwibCIsIm5hbWUiLCJ6cyIsImRlZmluZSIsImFtZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZWxmIiwid2luZG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/bignumber.js/bignumber.js\n");

/***/ })

};
;